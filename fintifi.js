(function (W) { typeof define == "function" && define.amd ? define(W) : W() })((function () {
  "use strict"; var Xl = Object.defineProperty; var Ql = W => { throw TypeError(W) }; var Ug = (W, H, ae) => H in W ? Xl(W, H, { enumerable: !0, configurable: !0, writable: !0, value: ae }) : W[H] = ae; var a = (W, H) => Xl(W, "name", { value: H, configurable: !0 }); var te = (W, H, ae) => Ug(W, typeof H != "symbol" ? H + "" : H, ae), zo = (W, H, ae) => H.has(W) || Ql("Cannot " + ae); var g = (W, H, ae) => (zo(W, H, "read from private field"), ae ? ae.call(W) : H.get(W)), G = (W, H, ae) => H.has(W) ? Ql("Cannot add the same private member more than once") : H instanceof WeakSet ? H.add(W) : H.set(W, ae), R = (W, H, ae, Zt) => (zo(W, H, "write to private field"), Zt ? Zt.call(W, ae) : H.set(W, ae), ae), U = (W, H, ae) => (zo(W, H, "access private method"), ae); var Pt, $e, Dt, we, vt, _t, Oe, dn, bt, He, Fe, yt, rt, J, it, Ke, $t, qe, Lt, x, vn, ed, td, nd, rd, Eo, id, od, ad, _n, Oo, sd, cd, ud, No, bn, er, ld, dd, fd, md, yn, To, pd, Uo, le, Ne, Te, ot, at, wt, hd, Ao, fn, kt, Ue, de, gd, vd, _d, tr, bd, yd; var W = document.createElement("style"); W.textContent = `._wrapper_1j0ct_1{position:fixed;bottom:100px;left:50%;transform:translate(-50%) translateY(20px);opacity:0;z-index:2147483642;box-sizing:border-box;overflow:visible;--width: 360px;--height: 40px;--border-radius: 12px;--side-space: 12px;--history-width: calc(var(--width) - var(--side-space) * 2);--color-1: rgb(57, 182, 255);--color-2: rgb(189, 69, 251);--color-3: rgb(255, 87, 51);--color-4: rgb(255, 214, 0);width:var(--width);height:var(--height);transition:all .3s ease-in-out}._wrapper_1j0ct_1 *{box-sizing:border-box}@media (max-width: 480px){._wrapper_1j0ct_1{width:calc(100vw - 40px);--width: calc(100vw - 40px) }}._wrapper_1j0ct_1 ._background_1j0ct_39{position:absolute;inset:-2px -8px;border-radius:calc(var(--border-radius) + 4px);filter:blur(16px);overflow:hidden}._wrapper_1j0ct_1 ._background_1j0ct_39:before{content:"";z-index:-1;pointer-events:none;position:absolute;width:100%;height:100%;left:0;top:0;background-image:linear-gradient(to bottom left,var(--color-1),var(--color-2),var(--color-1));animation:_mask-running_1j0ct_1 2s linear infinite}._wrapper_1j0ct_1 ._background_1j0ct_39:after{content:"";z-index:-1;pointer-events:none;position:absolute;width:100%;height:100%;left:0;top:0;background-image:linear-gradient(to bottom left,var(--color-2),var(--color-1),var(--color-2));animation:_mask-running_1j0ct_1 2s linear infinite;animation-delay:1s}@keyframes _mask-running_1j0ct_1{0%{transform:translate(-100%)}to{transform:translate(100%)}}._header_1j0ct_99{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;-webkit-user-select:none;user-select:none;position:absolute;inset:0;cursor:pointer;flex-shrink:0;background:#00000080;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);border-radius:var(--border-radius);background-clip:padding-box;box-shadow:0 0 0 2px #fff6,0 0 5px 1px #ffffff4d}._header_1j0ct_99 ._statusSection_1j0ct_121{display:flex;align-items:center;gap:8px;flex:1;min-height:24px}._header_1j0ct_99 ._statusSection_1j0ct_121 ._indicator_1j0ct_128{width:6px;height:6px;border-radius:50%;background:#ffffff80;flex-shrink:0;animation:none}._header_1j0ct_99 ._statusSection_1j0ct_121 ._indicator_1j0ct_128._thinking_1j0ct_137{background:#39b6ff;animation:_pulse_1j0ct_1 .8s ease-in-out infinite}._header_1j0ct_99 ._statusSection_1j0ct_121 ._indicator_1j0ct_128._tool_executing_1j0ct_142{background:#bd45fb;animation:_pulse_1j0ct_1 .6s ease-in-out infinite}._header_1j0ct_99 ._statusSection_1j0ct_121 ._indicator_1j0ct_128._retry_1j0ct_147{background:#ffd600;animation:_retryPulse_1j0ct_1 1s ease-in-out infinite}._header_1j0ct_99 ._statusSection_1j0ct_121 ._indicator_1j0ct_128._completed_1j0ct_153,._header_1j0ct_99 ._statusSection_1j0ct_121 ._indicator_1j0ct_128._input_1j0ct_154,._header_1j0ct_99 ._statusSection_1j0ct_121 ._indicator_1j0ct_128._output_1j0ct_155{background:#22c55e;animation:none}._header_1j0ct_99 ._statusSection_1j0ct_121 ._indicator_1j0ct_128._error_1j0ct_160{background:#ef4444;animation:none}._header_1j0ct_99 ._statusSection_1j0ct_121 ._statusText_1j0ct_166{color:#fff;font-size:12px;line-height:1;font-weight:500;transition:all .3s ease-in-out;position:relative;overflow:hidden;display:flex;align-items:center;min-height:24px}._header_1j0ct_99 ._statusSection_1j0ct_121 ._statusText_1j0ct_166._fadeOut_1j0ct_178{animation:_statusTextFadeOut_1j0ct_1 .3s ease forwards}._header_1j0ct_99 ._statusSection_1j0ct_121 ._statusText_1j0ct_166._fadeIn_1j0ct_182{animation:_statusTextFadeIn_1j0ct_1 .3s ease forwards}._header_1j0ct_99 ._controls_1j0ct_188{display:flex;align-items:center;gap:4px}._header_1j0ct_99 ._controls_1j0ct_188 ._controlButton_1j0ct_193{width:24px;height:24px;border:none;border-radius:4px;background:#ffffff1a;color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:12px;line-height:1}._header_1j0ct_99 ._controls_1j0ct_188 ._controlButton_1j0ct_193:hover{background:#fff3}._header_1j0ct_99 ._controls_1j0ct_188 ._pauseButton_1j0ct_212{font-weight:600}._header_1j0ct_99 ._controls_1j0ct_188 ._pauseButton_1j0ct_212._paused_1j0ct_214{background:#22c55e33;color:#22c55e}._header_1j0ct_99 ._controls_1j0ct_188 ._pauseButton_1j0ct_212._paused_1j0ct_214:hover{background:#22c55e4d}._header_1j0ct_99 ._controls_1j0ct_188 ._stopButton_1j0ct_224{background:#ef444433;color:#ff2929;font-weight:600}._header_1j0ct_99 ._controls_1j0ct_188 ._stopButton_1j0ct_224:hover{background:#ef44444d}@keyframes _statusTextFadeIn_1j0ct_1{0%{opacity:0;transform:translateY(5px)}to{opacity:1;transform:translateY(0)}}@keyframes _statusTextFadeOut_1j0ct_1{0%{opacity:1;transform:translateY(0)}to{opacity:0;transform:translateY(-5px)}}._historySectionWrapper_1j0ct_258{position:absolute;width:var(--history-width);bottom:var(--height);left:var(--side-space);z-index:-2;padding-top:0;visibility:collapse;overflow:hidden;transition:all .2s;background:#02001480;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);text-shadow:0 0 1px rgba(0,0,0,.2);border-top-left-radius:calc(var(--border-radius) + 4px);border-top-right-radius:calc(var(--border-radius) + 4px);border:2px solid rgba(255,255,255,.4);box-shadow:0 4px 16px #0009}._expanded_1j0ct_290 ._historySectionWrapper_1j0ct_258{padding-top:8px;visibility:visible}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258{position:relative;overflow-y:auto;overscroll-behavior:contain;scrollbar-width:none;max-height:0;padding-inline:8px;transition:max-height .2s}._expanded_1j0ct_290 :is(._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258){max-height:400px}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309{padding:8px 10px;margin-bottom:6px;background:linear-gradient(135deg,#ffffff14,#ffffff08);border-radius:8px;border-left:2px solid rgba(57,182,255,.5);font-size:12px;color:#fff;line-height:1.3;position:relative;overflow:hidden;box-shadow:inset 0 1px #ffffff1a,0 1px 3px #0000001a}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309:before{content:"";position:absolute;top:0;left:0;right:0;height:1px;background:linear-gradient(90deg,transparent,rgba(255,255,255,.2),transparent)}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309:hover{background:linear-gradient(135deg,#ffffff1f,#ffffff0f);box-shadow:inset 0 1px #ffffff26,0 2px 4px #00000026}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309:last-child{margin-bottom:10px}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._completed_1j0ct_153,._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._input_1j0ct_154,._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._output_1j0ct_155{border-left-color:#22c55e;background:linear-gradient(135deg,#22c55e1a,#22c55e0d)}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._error_1j0ct_160{border-left-color:#ef4444;background:linear-gradient(135deg,#ef44441a,#ef44440d)}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._retry_1j0ct_147{border-left-color:#ffd600;background:linear-gradient(135deg,#ffd6001a,#ffd6000d)}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._doneSuccess_1j0ct_368{background:linear-gradient(135deg,#22c55e40,#22c55e26,#22c55e14);border:none;border-left:4px solid rgb(34,197,94);box-shadow:0 4px 12px #22c55e4d,inset 0 1px #fff3,0 0 20px #22c55e1a;font-weight:600;color:#dcfce7;padding:10px 12px;margin-bottom:8px;border-radius:8px;position:relative;overflow:hidden}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._doneSuccess_1j0ct_368:before{background:linear-gradient(90deg,transparent,rgba(34,197,94,.4),transparent)}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._doneSuccess_1j0ct_368:after{content:"";position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.1),transparent);animation:_shimmer_1j0ct_1 2s ease-in-out infinite}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._doneSuccess_1j0ct_368 ._historyContent_1j0ct_404 ._statusIcon_1j0ct_405{font-size:16px;animation:_celebrate_1j0ct_1 .8s ease-in-out;filter:drop-shadow(0 2px 4px rgba(34,197,94,.5))}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._doneError_1j0ct_414{background:linear-gradient(135deg,#ef444440,#ef444426,#ef444414);border:none;border-left:4px solid rgb(239,68,68);box-shadow:0 4px 12px #ef44444d,inset 0 1px #fff3,0 0 20px #ef44441a;font-weight:600;color:#fee2e2;padding:10px 12px;margin-bottom:8px;border-radius:8px;position:relative;overflow:hidden}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._doneError_1j0ct_414:before{background:linear-gradient(90deg,transparent,rgba(239,68,68,.4),transparent)}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309._doneError_1j0ct_414 ._historyContent_1j0ct_404 ._statusIcon_1j0ct_405{font-size:16px;filter:drop-shadow(0 2px 4px rgba(239,68,68,.5))}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309 ._historyContent_1j0ct_404{display:flex;align-items:center;gap:8px;word-break:break-all;white-space:pre-wrap}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309 ._historyContent_1j0ct_404 ._statusIcon_1j0ct_405{font-size:12px;flex-shrink:0;line-height:1;transition:all .3s ease}._historySectionWrapper_1j0ct_258 ._historySection_1j0ct_258 ._historyItem_1j0ct_309 ._historyMeta_1j0ct_465{font-size:10px;color:#fff9;margin-top:8px;line-height:1}@keyframes _pulse_1j0ct_1{0%,to{opacity:1;transform:scale(1)}50%{opacity:.4;transform:scale(1.3)}}@keyframes _retryPulse_1j0ct_1{0%,to{opacity:1;transform:scale(1) rotate(0)}25%{opacity:.6;transform:scale(1.2) rotate(90deg)}50%{opacity:.8;transform:scale(1.1) rotate(180deg)}75%{opacity:.6;transform:scale(1.2) rotate(270deg)}}@keyframes _celebrate_1j0ct_1{0%,to{transform:scale(1)}25%{transform:scale(1.2) rotate(-5deg)}75%{transform:scale(1.2) rotate(5deg)}}@keyframes _shimmer_1j0ct_1{0%{left:-100%}to{left:100%}}._inputSectionWrapper_1j0ct_535{position:absolute;width:var(--history-width);top:var(--height);left:var(--side-space);z-index:-1;visibility:visible;overflow:hidden;height:48px;transition:all .2s;background:#bababa33;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);border-bottom-left-radius:calc(var(--border-radius) + 4px);border-bottom-right-radius:calc(var(--border-radius) + 4px);border:2px solid rgba(255,255,255,.3);box-shadow:0 1px 16px #0006}._inputSectionWrapper_1j0ct_535._hidden_1j0ct_558{visibility:collapse;height:0}._inputSectionWrapper_1j0ct_535 ._inputSection_1j0ct_535{display:flex;align-items:center;gap:4px;padding:8px}._inputSectionWrapper_1j0ct_535 ._inputSection_1j0ct_535 ._taskInput_1j0ct_569{flex:1;background:#fff6;border:1px solid rgba(255,255,255,.3);border-radius:10px;padding-inline:10px;color:#141414;font-size:12px;height:28px;line-height:1;outline:none;transition:all .2s ease}._inputSectionWrapper_1j0ct_535 ._inputSection_1j0ct_535 ._taskInput_1j0ct_569::placeholder{color:#353535}._inputSectionWrapper_1j0ct_535 ._inputSection_1j0ct_535 ._taskInput_1j0ct_569:focus{background:#fffc;border-color:#39b6ff99;box-shadow:0 0 0 2px #39b6ff33}._wrapper_1oy2s_1{position:fixed;inset:0;z-index:2147483641;cursor:not-allowed;overflow:hidden;display:none}._cursor_1vrf3_2{position:absolute;width:var(--cursor-size, 75px);height:var(--cursor-size, 75px);pointer-events:none;z-index:10000;transform:translate(-30%,-30%);animation:_cursor-enter_1vrf3_1 .3s ease-out forwards}._cursorBorder_1vrf3_13{position:absolute;inset:0;background:linear-gradient(45deg,#39b6ff,#bd45fb);-webkit-mask-image:url(https://img.alicdn.com/imgextra/i1/O1CN01YHLVYR1LvqWIyo5kH_!!6000000001362-2-tps-202-202.png);mask-image:url(https://img.alicdn.com/imgextra/i1/O1CN01YHLVYR1LvqWIyo5kH_!!6000000001362-2-tps-202-202.png);-webkit-mask-size:100% 100%;mask-size:100% 100%;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;animation:_cursor-breathe_1vrf3_1 2s ease-in-out infinite}._cursorFilling_1vrf3_23{position:absolute;inset:0;background:url(https://img.alicdn.com/imgextra/i3/O1CN01JZOqOS1Tu1sIKbPLW_!!6000000002441-2-tps-202-202.png);background-size:100% 100%;background-repeat:no-repeat}._cursorRipple_1vrf3_31{position:absolute;inset:0;pointer-events:none}._cursor_1vrf3_2._clicking_1vrf3_37 ._cursorRipple_1vrf3_31:after{content:"";position:absolute;width:100%;height:100%;left:-30%;top:-30%;border:4px solid rgba(57,182,255,1);border-radius:50%;animation:_cursor-ripple_1vrf3_1 .3s ease-out forwards}@keyframes _cursor-breathe_1vrf3_1{0%,to{transform:scale(1);opacity:.9}50%{transform:scale(1.05);opacity:1}}@keyframes _cursor-rotate_1vrf3_1{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes _cursor-enter_1vrf3_1{0%{transform:translate(-30%,-30%) scale(.5);opacity:0}to{transform:translate(-30%,-30%) scale(1);opacity:1}}@keyframes _cursor-ripple_1vrf3_1{0%{transform:scale(0);opacity:1}to{transform:scale(2);opacity:0}}
/*$vite$:1*/`, document.head.appendChild(W); const H = 10, ae = a((e = 0) => n => `\x1B[${n + e}m`, "wrapAnsi16"), Zt = a((e = 0) => n => `\x1B[${38 + e};5;${n}m`, "wrapAnsi256"), Po = a((e = 0) => (n, r, i) => `\x1B[${38 + e};2;${n};${r};${i}m`, "wrapAnsi16m"), Q = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], gray: [90, 39], grey: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgGray: [100, 49], bgGrey: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } }; Object.keys(Q.modifier); const $d = Object.keys(Q.color), wd = Object.keys(Q.bgColor);[...$d, ...wd]; function kd() { const e = new Map; for (const [n, r] of Object.entries(Q)) { for (const [i, t] of Object.entries(r)) Q[i] = { open: `\x1B[${t[0]}m`, close: `\x1B[${t[1]}m` }, r[i] = Q[i], e.set(t[0], t[1]); Object.defineProperty(Q, n, { value: r, enumerable: !1 }) } return Object.defineProperty(Q, "codes", { value: e, enumerable: !1 }), Q.color.close = "\x1B[39m", Q.bgColor.close = "\x1B[49m", Q.color.ansi = ae(), Q.color.ansi256 = Zt(), Q.color.ansi16m = Po(), Q.bgColor.ansi = ae(H), Q.bgColor.ansi256 = Zt(H), Q.bgColor.ansi16m = Po(H), Object.defineProperties(Q, { rgbToAnsi256: { value(n, r, i) { return n === r && r === i ? n < 8 ? 16 : n > 248 ? 231 : Math.round((n - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(n / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(i / 255 * 5) }, enumerable: !1 }, hexToRgb: { value(n) { const r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(n.toString(16)); if (!r) return [0, 0, 0]; let [i] = r; i.length === 3 && (i = [...i].map(o => o + o).join("")); const t = Number.parseInt(i, 16); return [t >> 16 & 255, t >> 8 & 255, t & 255] }, enumerable: !1 }, hexToAnsi256: { value: a(n => Q.rgbToAnsi256(...Q.hexToRgb(n)), "value"), enumerable: !1 }, ansi256ToAnsi: { value(n) { if (n < 8) return 30 + n; if (n < 16) return 90 + (n - 8); let r, i, t; if (n >= 232) r = ((n - 232) * 10 + 8) / 255, i = r, t = r; else { n -= 16; const c = n % 36; r = Math.floor(n / 36) / 5, i = Math.floor(c / 6) / 5, t = c % 6 / 5 } const o = Math.max(r, i, t) * 2; if (o === 0) return 30; let s = 30 + (Math.round(t) << 2 | Math.round(i) << 1 | Math.round(r)); return o === 2 && (s += 60), s }, enumerable: !1 }, rgbToAnsi: { value: a((n, r, i) => Q.ansi256ToAnsi(Q.rgbToAnsi256(n, r, i)), "value"), enumerable: !1 }, hexToAnsi: { value: a(n => Q.ansi256ToAnsi(Q.hexToAnsi256(n)), "value"), enumerable: !1 } }), Q } a(kd, "assembleStyles"); const Me = kd(), Do = (() => { if (!("navigator" in globalThis)) return 0; if (globalThis.navigator.userAgentData) { const e = navigator.userAgentData.brands.find(({ brand: n }) => n === "Chromium"); if (e && e.version > 93) return 3 } return /\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent) ? 1 : 0 })(), Lo = Do !== 0 && { level: Do }, xd = { stdout: Lo, stderr: Lo }; function Id(e, n, r) { let i = e.indexOf(n); if (i === -1) return e; const t = n.length; let o = 0, s = ""; do s += e.slice(o, i) + n + r, o = i + t, i = e.indexOf(n, o); while (i !== -1); return s += e.slice(o), s } a(Id, "stringReplaceAll"); function Sd(e, n, r, i) {
    let t = 0, o = ""; do {
      const s = e[i - 1] === "\r"; o += e.slice(t, s ? i - 1 : i) + n + (s ? `\r
`: `
`) + r, t = i + 1, i = e.indexOf(`
`, t)
    } while (i !== -1); return o += e.slice(t), o
  } a(Sd, "stringEncaseCRLFWithFirstIndex"); const { stdout: Ro, stderr: Co } = xd, nr = Symbol("GENERATOR"), It = Symbol("STYLER"), Mt = Symbol("IS_EMPTY"), Zo = ["ansi", "ansi", "ansi256", "ansi16m"], St = Object.create(null), jd = a((e, n = {}) => { if (n.level && !(Number.isInteger(n.level) && n.level >= 0 && n.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3"); const r = Ro ? Ro.level : 0; e.level = n.level === void 0 ? r : n.level }, "applyOptions"), zd = a(e => { const n = a((...r) => r.join(" "), "chalk"); return jd(n, e), Object.setPrototypeOf(n, Ft.prototype), n }, "chalkFactory"); function Ft(e) { return zd(e) } a(Ft, "createChalk"), Object.setPrototypeOf(Ft.prototype, Function.prototype); for (const [e, n] of Object.entries(Me)) St[e] = { get() { const r = $n(this, ir(n.open, n.close, this[It]), this[Mt]); return Object.defineProperty(this, e, { value: r }), r } }; St.visible = { get() { const e = $n(this, this[It], !0); return Object.defineProperty(this, "visible", { value: e }), e } }; const rr = a((e, n, r, ...i) => e === "rgb" ? n === "ansi16m" ? Me[r].ansi16m(...i) : n === "ansi256" ? Me[r].ansi256(Me.rgbToAnsi256(...i)) : Me[r].ansi(Me.rgbToAnsi(...i)) : e === "hex" ? rr("rgb", n, r, ...Me.hexToRgb(...i)) : Me[r][e](...i), "getModelAnsi"), Ed = ["rgb", "hex", "ansi256"]; for (const e of Ed) { St[e] = { get() { const { level: r } = this; return function (...i) { const t = ir(rr(e, Zo[r], "color", ...i), Me.color.close, this[It]); return $n(this, t, this[Mt]) } } }; const n = "bg" + e[0].toUpperCase() + e.slice(1); St[n] = { get() { const { level: r } = this; return function (...i) { const t = ir(rr(e, Zo[r], "bgColor", ...i), Me.bgColor.close, this[It]); return $n(this, t, this[Mt]) } } } } const Od = Object.defineProperties(() => { }, { ...St, level: { enumerable: !0, get() { return this[nr].level }, set(e) { this[nr].level = e } } }), ir = a((e, n, r) => { let i, t; return r === void 0 ? (i = e, t = n) : (i = r.openAll + e, t = n + r.closeAll), { open: e, close: n, openAll: i, closeAll: t, parent: r } }, "createStyler"), $n = a((e, n, r) => { const i = a((...t) => Nd(i, t.length === 1 ? "" + t[0] : t.join(" ")), "builder"); return Object.setPrototypeOf(i, Od), i[nr] = e, i[It] = n, i[Mt] = r, i }, "createBuilder"), Nd = a((e, n) => {
    if (e.level <= 0 || !n) return e[Mt] ? "" : n; let r = e[It]; if (r === void 0) return n; const { openAll: i, closeAll: t } = r; if (n.includes("\x1B")) for (; r !== void 0;)n = Id(n, r.close, r.open), r = r.parent; const o = n.indexOf(`
`); return o !== -1 && (n = Sd(n, t, i, o)), i + n + t
  }, "applyStyle"); Object.defineProperties(Ft.prototype, St); const ge = Ft(); Ft({ level: Co ? Co.level : 0 }); const Mo = Object.freeze({ status: "aborted" }); function d(e, n, r) { function i(u, p) { var m; Object.defineProperty(u, "_zod", { value: u._zod ?? {}, enumerable: !1 }), (m = u._zod).traits ?? (m.traits = new Set), u._zod.traits.add(e), n(u, p); for (const f in s.prototype) f in u || Object.defineProperty(u, f, { value: s.prototype[f].bind(u) }); u._zod.constr = s, u._zod.def = p } a(i, "init"); const t = r?.Parent ?? Object, c = class c extends t { }; a(c, "Definition"); let o = c; Object.defineProperty(o, "name", { value: e }); function s(u) { var p; const m = r?.Parent ? new o : this; i(m, u), (p = m._zod).deferred ?? (p.deferred = []); for (const f of m._zod.deferred) f(); return m } return a(s, "_"), Object.defineProperty(s, "init", { value: i }), Object.defineProperty(s, Symbol.hasInstance, { value: a(u => r?.Parent && u instanceof r.Parent ? !0 : u?._zod?.traits?.has(e), "value") }), Object.defineProperty(s, "name", { value: e }), s } a(d, "$constructor"); const Fo = Symbol("zod_brand"), fo = class fo extends Error { constructor() { super("Encountered Promise during synchronous parse. Use .parseAsync() instead.") } }; a(fo, "$ZodAsyncError"); let We = fo; const mo = class mo extends Error { constructor(n) { super(`Encountered unidirectional transform during encode: ${n}`), this.name = "ZodEncodeError" } }; a(mo, "$ZodEncodeError"); let jt = mo; const wn = {}; function fe(e) { return e && Object.assign(wn, e), wn } a(fe, "config"); function Td(e) { return e } a(Td, "assertEqual"); function Ud(e) { return e } a(Ud, "assertNotEqual"); function Ad(e) { } a(Ad, "assertIs"); function Pd(e) { throw new Error } a(Pd, "assertNever"); function Dd(e) { } a(Dd, "assert$1"); function or(e) { const n = Object.values(e).filter(i => typeof i == "number"); return Object.entries(e).filter(([i, t]) => n.indexOf(+i) === -1).map(([i, t]) => t) } a(or, "getEnumValues"); function $(e, n = "|") { return e.map(r => P(r)).join(n) } a($, "joinValues"); function kn(e, n) { return typeof n == "bigint" ? n.toString() : n } a(kn, "jsonStringifyReplacer"); function Bt(e) { return { get value() { { const n = e(); return Object.defineProperty(this, "value", { value: n }), n } } } } a(Bt, "cached"); function ut(e) { return e == null } a(ut, "nullish$1"); function xn(e) { const n = e.startsWith("^") ? 1 : 0, r = e.endsWith("$") ? e.length - 1 : e.length; return e.slice(n, r) } a(xn, "cleanRegex"); function Bo(e, n) { const r = (e.toString().split(".")[1] || "").length, i = n.toString(); let t = (i.split(".")[1] || "").length; if (t === 0 && /\d?e-\d?/.test(i)) { const u = i.match(/\d?e-(\d?)/); u?.[1] && (t = Number.parseInt(u[1])) } const o = r > t ? r : t, s = Number.parseInt(e.toFixed(o).replace(".", "")), c = Number.parseInt(n.toFixed(o).replace(".", "")); return s % c / 10 ** o } a(Bo, "floatSafeRemainder"); const Wo = Symbol("evaluating"); function F(e, n, r) { let i; Object.defineProperty(e, n, { get() { if (i !== Wo) return i === void 0 && (i = Wo, i = r()), i }, set(t) { Object.defineProperty(e, n, { value: t }) }, configurable: !0 }) } a(F, "defineLazy"); function Ld(e) { return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e)) } a(Ld, "objectClone"); function Qe(e, n, r) { Object.defineProperty(e, n, { value: r, writable: !0, enumerable: !0, configurable: !0 }) } a(Qe, "assignProp"); function Ge(...e) { const n = {}; for (const r of e) { const i = Object.getOwnPropertyDescriptors(r); Object.assign(n, i) } return Object.defineProperties({}, n) } a(Ge, "mergeDefs"); function Rd(e) { return Ge(e._zod.def) } a(Rd, "cloneDef"); function Cd(e, n) { return n ? n.reduce((r, i) => r?.[i], e) : e } a(Cd, "getElementAtPath"); function Zd(e) { const n = Object.keys(e), r = n.map(i => e[i]); return Promise.all(r).then(i => { const t = {}; for (let o = 0; o < n.length; o++)t[n[o]] = i[o]; return t }) } a(Zd, "promiseAllObject"); function Md(e = 10) { const n = "abcdefghijklmnopqrstuvwxyz"; let r = ""; for (let i = 0; i < e; i++)r += n[Math.floor(Math.random() * n.length)]; return r } a(Md, "randomString"); function ar(e) { return JSON.stringify(e) } a(ar, "esc"); const sr = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => { }; function zt(e) { return typeof e == "object" && e !== null && !Array.isArray(e) } a(zt, "isObject"); const Go = Bt(() => { if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare")) return !1; try { const e = Function; return new e(""), !0 } catch { return !1 } }); function lt(e) { if (zt(e) === !1) return !1; const n = e.constructor; if (n === void 0) return !0; const r = n.prototype; return !(zt(r) === !1 || Object.prototype.hasOwnProperty.call(r, "isPrototypeOf") === !1) } a(lt, "isPlainObject"); function In(e) { return lt(e) ? { ...e } : Array.isArray(e) ? [...e] : e } a(In, "shallowClone"); function Fd(e) { let n = 0; for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && n++; return n } a(Fd, "numKeys"); const Bd = a(e => { const n = typeof e; switch (n) { case "undefined": return "undefined"; case "string": return "string"; case "number": return Number.isNaN(e) ? "nan" : "number"; case "boolean": return "boolean"; case "function": return "function"; case "bigint": return "bigint"; case "symbol": return "symbol"; case "object": return Array.isArray(e) ? "array" : e === null ? "null" : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? "promise" : typeof Map < "u" && e instanceof Map ? "map" : typeof Set < "u" && e instanceof Set ? "set" : typeof Date < "u" && e instanceof Date ? "date" : typeof File < "u" && e instanceof File ? "file" : "object"; default: throw new Error(`Unknown data type: ${n}`) } }, "getParsedType"), Sn = new Set(["string", "number", "symbol"]), Vo = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]); function et(e) { return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") } a(et, "escapeRegex"); function Ie(e, n, r) { const i = new e._zod.constr(n ?? e._zod.def); return (!n || r?.parent) && (i._zod.parent = e), i } a(Ie, "clone"); function _(e) { const n = e; if (!n) return {}; if (typeof n == "string") return { error: a(() => n, "error") }; if (n?.message !== void 0) { if (n?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params"); n.error = n.message } return delete n.message, typeof n.error == "string" ? { ...n, error: a(() => n.error, "error") } : n } a(_, "normalizeParams"); function Wd(e) { let n; return new Proxy({}, { get(r, i, t) { return n ?? (n = e()), Reflect.get(n, i, t) }, set(r, i, t, o) { return n ?? (n = e()), Reflect.set(n, i, t, o) }, has(r, i) { return n ?? (n = e()), Reflect.has(n, i) }, deleteProperty(r, i) { return n ?? (n = e()), Reflect.deleteProperty(n, i) }, ownKeys(r) { return n ?? (n = e()), Reflect.ownKeys(n) }, getOwnPropertyDescriptor(r, i) { return n ?? (n = e()), Reflect.getOwnPropertyDescriptor(n, i) }, defineProperty(r, i, t) { return n ?? (n = e()), Reflect.defineProperty(n, i, t) } }) } a(Wd, "createTransparentProxy"); function P(e) { return typeof e == "bigint" ? e.toString() + "n" : typeof e == "string" ? `"${e}"` : `${e}` } a(P, "stringifyPrimitive"); function Jo(e) { return Object.keys(e).filter(n => e[n]._zod.optin === "optional" && e[n]._zod.optout === "optional") } a(Jo, "optionalKeys"); const Ho = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] }, Ko = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] }; function qo(e, n) { const r = e._zod.def, i = Ge(e._zod.def, { get shape() { const t = {}; for (const o in n) { if (!(o in r.shape)) throw new Error(`Unrecognized key: "${o}"`); n[o] && (t[o] = r.shape[o]) } return Qe(this, "shape", t), t }, checks: [] }); return Ie(e, i) } a(qo, "pick"); function Yo(e, n) { const r = e._zod.def, i = Ge(e._zod.def, { get shape() { const t = { ...e._zod.def.shape }; for (const o in n) { if (!(o in r.shape)) throw new Error(`Unrecognized key: "${o}"`); n[o] && delete t[o] } return Qe(this, "shape", t), t }, checks: [] }); return Ie(e, i) } a(Yo, "omit"); function Xo(e, n) { if (!lt(n)) throw new Error("Invalid input to extend: expected a plain object"); const r = e._zod.def.checks; if (r && r.length > 0) throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead."); const t = Ge(e._zod.def, { get shape() { const o = { ...e._zod.def.shape, ...n }; return Qe(this, "shape", o), o }, checks: [] }); return Ie(e, t) } a(Xo, "extend"); function Qo(e, n) { if (!lt(n)) throw new Error("Invalid input to safeExtend: expected a plain object"); const r = { ...e._zod.def, get shape() { const i = { ...e._zod.def.shape, ...n }; return Qe(this, "shape", i), i }, checks: e._zod.def.checks }; return Ie(e, r) } a(Qo, "safeExtend"); function ea(e, n) { const r = Ge(e._zod.def, { get shape() { const i = { ...e._zod.def.shape, ...n._zod.def.shape }; return Qe(this, "shape", i), i }, get catchall() { return n._zod.def.catchall }, checks: [] }); return Ie(e, r) } a(ea, "merge"); function ta(e, n, r) { const i = Ge(n._zod.def, { get shape() { const t = n._zod.def.shape, o = { ...t }; if (r) for (const s in r) { if (!(s in t)) throw new Error(`Unrecognized key: "${s}"`); r[s] && (o[s] = e ? new e({ type: "optional", innerType: t[s] }) : t[s]) } else for (const s in t) o[s] = e ? new e({ type: "optional", innerType: t[s] }) : t[s]; return Qe(this, "shape", o), o }, checks: [] }); return Ie(n, i) } a(ta, "partial"); function na(e, n, r) { const i = Ge(n._zod.def, { get shape() { const t = n._zod.def.shape, o = { ...t }; if (r) for (const s in r) { if (!(s in o)) throw new Error(`Unrecognized key: "${s}"`); r[s] && (o[s] = new e({ type: "nonoptional", innerType: t[s] })) } else for (const s in t) o[s] = new e({ type: "nonoptional", innerType: t[s] }); return Qe(this, "shape", o), o }, checks: [] }); return Ie(n, i) } a(na, "required"); function dt(e, n = 0) { if (e.aborted === !0) return !0; for (let r = n; r < e.issues.length; r++)if (e.issues[r]?.continue !== !0) return !0; return !1 } a(dt, "aborted"); function je(e, n) { return n.map(r => { var i; return (i = r).path ?? (i.path = []), r.path.unshift(e), r }) } a(je, "prefixIssues"); function Wt(e) { return typeof e == "string" ? e : e?.message } a(Wt, "unwrapMessage"); function ze(e, n, r) { const i = { ...e, path: e.path ?? [] }; if (!e.message) { const t = Wt(e.inst?._zod.def?.error?.(e)) ?? Wt(n?.error?.(e)) ?? Wt(r.customError?.(e)) ?? Wt(r.localeError?.(e)) ?? "Invalid input"; i.message = t } return delete i.inst, delete i.continue, n?.reportInput || delete i.input, i } a(ze, "finalizeIssue"); function jn(e) { return e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof File ? "file" : "unknown" } a(jn, "getSizableOrigin"); function zn(e) { return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown" } a(zn, "getLengthableOrigin"); function Et(...e) { const [n, r, i] = e; return typeof n == "string" ? { message: n, code: "custom", input: r, inst: i } : { ...n } } a(Et, "issue"); function Gd(e) { return Object.entries(e).filter(([n, r]) => Number.isNaN(Number.parseInt(n, 10))).map(n => n[1]) } a(Gd, "cleanEnum"); function ra(e) { const n = atob(e), r = new Uint8Array(n.length); for (let i = 0; i < n.length; i++)r[i] = n.charCodeAt(i); return r } a(ra, "base64ToUint8Array"); function ia(e) { let n = ""; for (let r = 0; r < e.length; r++)n += String.fromCharCode(e[r]); return btoa(n) } a(ia, "uint8ArrayToBase64"); function Vd(e) { const n = e.replace(/-/g, "+").replace(/_/g, "/"), r = "=".repeat((4 - n.length % 4) % 4); return ra(n + r) } a(Vd, "base64urlToUint8Array"); function Jd(e) { return ia(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "") } a(Jd, "uint8ArrayToBase64url"); function Hd(e) { const n = e.replace(/^0x/, ""); if (n.length % 2 !== 0) throw new Error("Invalid hex string length"); const r = new Uint8Array(n.length / 2); for (let i = 0; i < n.length; i += 2)r[i / 2] = Number.parseInt(n.slice(i, i + 2), 16); return r } a(Hd, "hexToUint8Array"); function Kd(e) { return Array.from(e).map(n => n.toString(16).padStart(2, "0")).join("") } a(Kd, "uint8ArrayToHex"); const po = class po { constructor(...n) { } }; a(po, "Class"); let cr = po; const oa = Object.freeze(Object.defineProperty({ __proto__: null, BIGINT_FORMAT_RANGES: Ko, Class: cr, NUMBER_FORMAT_RANGES: Ho, aborted: dt, allowsEval: Go, assert: Dd, assertEqual: Td, assertIs: Ad, assertNever: Pd, assertNotEqual: Ud, assignProp: Qe, base64ToUint8Array: ra, base64urlToUint8Array: Vd, cached: Bt, captureStackTrace: sr, cleanEnum: Gd, cleanRegex: xn, clone: Ie, cloneDef: Rd, createTransparentProxy: Wd, defineLazy: F, esc: ar, escapeRegex: et, extend: Xo, finalizeIssue: ze, floatSafeRemainder: Bo, getElementAtPath: Cd, getEnumValues: or, getLengthableOrigin: zn, getParsedType: Bd, getSizableOrigin: jn, hexToUint8Array: Hd, isObject: zt, isPlainObject: lt, issue: Et, joinValues: $, jsonStringifyReplacer: kn, merge: ea, mergeDefs: Ge, normalizeParams: _, nullish: ut, numKeys: Fd, objectClone: Ld, omit: Yo, optionalKeys: Jo, partial: ta, pick: qo, prefixIssues: je, primitiveTypes: Vo, promiseAllObject: Zd, propertyKeyTypes: Sn, randomString: Md, required: na, safeExtend: Qo, shallowClone: In, stringifyPrimitive: P, uint8ArrayToBase64: ia, uint8ArrayToBase64url: Jd, uint8ArrayToHex: Kd, unwrapMessage: Wt }, Symbol.toStringTag, { value: "Module" })), aa = a((e, n) => { e.name = "$ZodError", Object.defineProperty(e, "_zod", { value: e._zod, enumerable: !1 }), Object.defineProperty(e, "issues", { value: n, enumerable: !1 }), e.message = JSON.stringify(n, kn, 2), Object.defineProperty(e, "toString", { value: a(() => e.message, "value"), enumerable: !1 }) }, "initializer$1"), ur = d("$ZodError", aa), ve = d("$ZodError", aa, { Parent: Error }); function lr(e, n = r => r.message) { const r = {}, i = []; for (const t of e.issues) t.path.length > 0 ? (r[t.path[0]] = r[t.path[0]] || [], r[t.path[0]].push(n(t))) : i.push(n(t)); return { formErrors: i, fieldErrors: r } } a(lr, "flattenError"); function dr(e, n = r => r.message) { const r = { _errors: [] }, i = a(t => { for (const o of t.issues) if (o.code === "invalid_union" && o.errors.length) o.errors.map(s => i({ issues: s })); else if (o.code === "invalid_key") i({ issues: o.issues }); else if (o.code === "invalid_element") i({ issues: o.issues }); else if (o.path.length === 0) r._errors.push(n(o)); else { let s = r, c = 0; for (; c < o.path.length;) { const u = o.path[c]; c === o.path.length - 1 ? (s[u] = s[u] || { _errors: [] }, s[u]._errors.push(n(o))) : s[u] = s[u] || { _errors: [] }, s = s[u], c++ } } }, "processError"); return i(e), r } a(dr, "formatError"); function sa(e, n = r => r.message) { const r = { errors: [] }, i = a((t, o = []) => { var s, c; for (const u of t.issues) if (u.code === "invalid_union" && u.errors.length) u.errors.map(p => i({ issues: p }, u.path)); else if (u.code === "invalid_key") i({ issues: u.issues }, u.path); else if (u.code === "invalid_element") i({ issues: u.issues }, u.path); else { const p = [...o, ...u.path]; if (p.length === 0) { r.errors.push(n(u)); continue } let m = r, f = 0; for (; f < p.length;) { const b = p[f], v = f === p.length - 1; typeof b == "string" ? (m.properties ?? (m.properties = {}), (s = m.properties)[b] ?? (s[b] = { errors: [] }), m = m.properties[b]) : (m.items ?? (m.items = []), (c = m.items)[b] ?? (c[b] = { errors: [] }), m = m.items[b]), v && m.errors.push(n(u)), f++ } } }, "processError"); return i(e), r } a(sa, "treeifyError"); function ca(e) { const n = [], r = e.map(i => typeof i == "object" ? i.key : i); for (const i of r) typeof i == "number" ? n.push(`[${i}]`) : typeof i == "symbol" ? n.push(`[${JSON.stringify(String(i))}]`) : /[^\w$]/.test(i) ? n.push(`[${JSON.stringify(i)}]`) : (n.length && n.push("."), n.push(i)); return n.join("") } a(ca, "toDotPath"); function ua(e) {
    const n = [], r = [...e.issues].sort((i, t) => (i.path ?? []).length - (t.path ?? []).length); for (const i of r) n.push(`Bot– ${i.message}`), i.path?.length && n.push(`  â†’ at ${ca(i.path)}`); return n.join(`
`)
  } a(ua, "prettifyError"); const Gt = a(e => (n, r, i, t) => { const o = i ? Object.assign(i, { async: !1 }) : { async: !1 }, s = n._zod.run({ value: r, issues: [] }, o); if (s instanceof Promise) throw new We; if (s.issues.length) { const c = new (t?.Err ?? e)(s.issues.map(u => ze(u, o, fe()))); throw sr(c, t?.callee), c } return s.value }, "_parse"), fr = Gt(ve), Vt = a(e => async (n, r, i, t) => { const o = i ? Object.assign(i, { async: !0 }) : { async: !0 }; let s = n._zod.run({ value: r, issues: [] }, o); if (s instanceof Promise && (s = await s), s.issues.length) { const c = new (t?.Err ?? e)(s.issues.map(u => ze(u, o, fe()))); throw sr(c, t?.callee), c } return s.value }, "_parseAsync"), mr = Vt(ve), Jt = a(e => (n, r, i) => { const t = i ? { ...i, async: !1 } : { async: !1 }, o = n._zod.run({ value: r, issues: [] }, t); if (o instanceof Promise) throw new We; return o.issues.length ? { success: !1, error: new (e ?? ur)(o.issues.map(s => ze(s, t, fe()))) } : { success: !0, data: o.value } }, "_safeParse"), la = Jt(ve), Ht = a(e => async (n, r, i) => { const t = i ? Object.assign(i, { async: !0 }) : { async: !0 }; let o = n._zod.run({ value: r, issues: [] }, t); return o instanceof Promise && (o = await o), o.issues.length ? { success: !1, error: new e(o.issues.map(s => ze(s, t, fe()))) } : { success: !0, data: o.value } }, "_safeParseAsync"), da = Ht(ve), pr = a(e => (n, r, i) => { const t = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" }; return Gt(e)(n, r, t) }, "_encode"), qd = pr(ve), hr = a(e => (n, r, i) => Gt(e)(n, r, i), "_decode"), Yd = hr(ve), gr = a(e => async (n, r, i) => { const t = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" }; return Vt(e)(n, r, t) }, "_encodeAsync"), Xd = gr(ve), vr = a(e => async (n, r, i) => Vt(e)(n, r, i), "_decodeAsync"), Qd = vr(ve), _r = a(e => (n, r, i) => { const t = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" }; return Jt(e)(n, r, t) }, "_safeEncode"), ef = _r(ve), br = a(e => (n, r, i) => Jt(e)(n, r, i), "_safeDecode"), tf = br(ve), yr = a(e => async (n, r, i) => { const t = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" }; return Ht(e)(n, r, t) }, "_safeEncodeAsync"), nf = yr(ve), $r = a(e => async (n, r, i) => Ht(e)(n, r, i), "_safeDecodeAsync"), rf = $r(ve), fa = /^[cC][^\s-]{8,}$/, ma = /^[0-9a-z]+$/, pa = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, ha = /^[0-9a-vA-V]{20}$/, ga = /^[A-Za-z0-9]{27}$/, va = /^[a-zA-Z0-9_-]{21}$/, _a = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, of = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, ba = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, Ot = a(e => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, "uuid$1"), af = Ot(4), sf = Ot(6), cf = Ot(7), ya = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, uf = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, lf = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, $a = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, df = $a, ff = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, mf = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$"; function wa() { return new RegExp(mf, "u") } a(wa, "emoji$1"); const ka = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, xa = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, Ia = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Sa = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, ja = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, wr = /^[A-Za-z0-9_-]*$/, kr = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, za = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, Ea = /^\+(?:[0-9]){6,14}[0-9]$/, Oa = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", Na = new RegExp(`^${Oa}$`); function Ta(e) { const n = "(?:[01]\\d|2[0-3]):[0-5]\\d"; return typeof e.precision == "number" ? e.precision === -1 ? `${n}` : e.precision === 0 ? `${n}:[0-5]\\d` : `${n}:[0-5]\\d\\.\\d{${e.precision}}` : `${n}(?::[0-5]\\d(?:\\.\\d+)?)?` } a(Ta, "timeSource"); function Ua(e) { return new RegExp(`^${Ta(e)}$`) } a(Ua, "time$1"); function Aa(e) { const n = Ta({ precision: e.precision }), r = ["Z"]; e.local && r.push(""), e.offset && r.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)"); const i = `${n}(?:${r.join("|")})`; return new RegExp(`^${Oa}T(?:${i})$`) } a(Aa, "datetime$1"); const Pa = a(e => { const n = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*"; return new RegExp(`^${n}$`) }, "string$2"), Da = /^-?\d+n?$/, La = /^-?\d+$/, Ra = /^-?\d+(?:\.\d+)?/, Ca = /^(?:true|false)$/i, Za = /^null$/i, Ma = /^undefined$/i, Fa = /^[^A-Z]*$/, Ba = /^[^a-z]*$/, Wa = /^[0-9a-fA-F]*$/; function Kt(e, n) { return new RegExp(`^[A-Za-z0-9+/]{${e}}${n}$`) } a(Kt, "fixedBase64"); function qt(e) { return new RegExp(`^[A-Za-z0-9_-]{${e}}$`) } a(qt, "fixedBase64url"); const xr = Object.freeze(Object.defineProperty({ __proto__: null, base64: ja, base64url: wr, bigint: Da, boolean: Ca, browserEmail: ff, cidrv4: Ia, cidrv6: Sa, cuid: fa, cuid2: ma, date: Na, datetime: Aa, domain: za, duration: _a, e164: Ea, email: ya, emoji: wa, extendedDuration: of, guid: ba, hex: Wa, hostname: kr, html5Email: uf, idnEmail: df, integer: La, ipv4: ka, ipv6: xa, ksuid: ga, lowercase: Fa, md5_base64: Kt(22, "=="), md5_base64url: qt(22), md5_hex: /^[0-9a-fA-F]{32}$/, nanoid: va, null: Za, number: Ra, rfc5322Email: lf, sha1_base64: Kt(27, "="), sha1_base64url: qt(27), sha1_hex: /^[0-9a-fA-F]{40}$/, sha256_base64: Kt(43, "="), sha256_base64url: qt(43), sha256_hex: /^[0-9a-fA-F]{64}$/, sha384_base64: Kt(64, ""), sha384_base64url: qt(64), sha384_hex: /^[0-9a-fA-F]{96}$/, sha512_base64: Kt(86, "=="), sha512_base64url: qt(86), sha512_hex: /^[0-9a-fA-F]{128}$/, string: Pa, time: Ua, ulid: pa, undefined: Ma, unicodeEmail: $a, uppercase: Ba, uuid: Ot, uuid4: af, uuid6: sf, uuid7: cf, xid: ha }, Symbol.toStringTag, { value: "Module" })), ne = d("$ZodCheck", (e, n) => { var r; e._zod ?? (e._zod = {}), e._zod.def = n, (r = e._zod).onattach ?? (r.onattach = []) }), Ga = { number: "number", bigint: "bigint", object: "date" }, Ir = d("$ZodCheckLessThan", (e, n) => { ne.init(e, n); const r = Ga[typeof n.value]; e._zod.onattach.push(i => { const t = i._zod.bag, o = (n.inclusive ? t.maximum : t.exclusiveMaximum) ?? Number.POSITIVE_INFINITY; n.value < o && (n.inclusive ? t.maximum = n.value : t.exclusiveMaximum = n.value) }), e._zod.check = i => { (n.inclusive ? i.value <= n.value : i.value < n.value) || i.issues.push({ origin: r, code: "too_big", maximum: n.value, input: i.value, inclusive: n.inclusive, inst: e, continue: !n.abort }) } }), Sr = d("$ZodCheckGreaterThan", (e, n) => { ne.init(e, n); const r = Ga[typeof n.value]; e._zod.onattach.push(i => { const t = i._zod.bag, o = (n.inclusive ? t.minimum : t.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY; n.value > o && (n.inclusive ? t.minimum = n.value : t.exclusiveMinimum = n.value) }), e._zod.check = i => { (n.inclusive ? i.value >= n.value : i.value > n.value) || i.issues.push({ origin: r, code: "too_small", minimum: n.value, input: i.value, inclusive: n.inclusive, inst: e, continue: !n.abort }) } }), Va = d("$ZodCheckMultipleOf", (e, n) => { ne.init(e, n), e._zod.onattach.push(r => { var i; (i = r._zod.bag).multipleOf ?? (i.multipleOf = n.value) }), e._zod.check = r => { if (typeof r.value != typeof n.value) throw new Error("Cannot mix number and bigint in multiple_of check."); (typeof r.value == "bigint" ? r.value % n.value === BigInt(0) : Bo(r.value, n.value) === 0) || r.issues.push({ origin: typeof r.value, code: "not_multiple_of", divisor: n.value, input: r.value, inst: e, continue: !n.abort }) } }), Ja = d("$ZodCheckNumberFormat", (e, n) => { ne.init(e, n), n.format = n.format || "float64"; const r = n.format?.includes("int"), i = r ? "int" : "number", [t, o] = Ho[n.format]; e._zod.onattach.push(s => { const c = s._zod.bag; c.format = n.format, c.minimum = t, c.maximum = o, r && (c.pattern = La) }), e._zod.check = s => { const c = s.value; if (r) { if (!Number.isInteger(c)) { s.issues.push({ expected: i, format: n.format, code: "invalid_type", continue: !1, input: c, inst: e }); return } if (!Number.isSafeInteger(c)) { c > 0 ? s.issues.push({ input: c, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: i, continue: !n.abort }) : s.issues.push({ input: c, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: i, continue: !n.abort }); return } } c < t && s.issues.push({ origin: "number", input: c, code: "too_small", minimum: t, inclusive: !0, inst: e, continue: !n.abort }), c > o && s.issues.push({ origin: "number", input: c, code: "too_big", maximum: o, inst: e }) } }), Ha = d("$ZodCheckBigIntFormat", (e, n) => { ne.init(e, n); const [r, i] = Ko[n.format]; e._zod.onattach.push(t => { const o = t._zod.bag; o.format = n.format, o.minimum = r, o.maximum = i }), e._zod.check = t => { const o = t.value; o < r && t.issues.push({ origin: "bigint", input: o, code: "too_small", minimum: r, inclusive: !0, inst: e, continue: !n.abort }), o > i && t.issues.push({ origin: "bigint", input: o, code: "too_big", maximum: i, inst: e }) } }), Ka = d("$ZodCheckMaxSize", (e, n) => { var r; ne.init(e, n), (r = e._zod.def).when ?? (r.when = i => { const t = i.value; return !ut(t) && t.size !== void 0 }), e._zod.onattach.push(i => { const t = i._zod.bag.maximum ?? Number.POSITIVE_INFINITY; n.maximum < t && (i._zod.bag.maximum = n.maximum) }), e._zod.check = i => { const t = i.value; t.size <= n.maximum || i.issues.push({ origin: jn(t), code: "too_big", maximum: n.maximum, inclusive: !0, input: t, inst: e, continue: !n.abort }) } }), qa = d("$ZodCheckMinSize", (e, n) => { var r; ne.init(e, n), (r = e._zod.def).when ?? (r.when = i => { const t = i.value; return !ut(t) && t.size !== void 0 }), e._zod.onattach.push(i => { const t = i._zod.bag.minimum ?? Number.NEGATIVE_INFINITY; n.minimum > t && (i._zod.bag.minimum = n.minimum) }), e._zod.check = i => { const t = i.value; t.size >= n.minimum || i.issues.push({ origin: jn(t), code: "too_small", minimum: n.minimum, inclusive: !0, input: t, inst: e, continue: !n.abort }) } }), Ya = d("$ZodCheckSizeEquals", (e, n) => { var r; ne.init(e, n), (r = e._zod.def).when ?? (r.when = i => { const t = i.value; return !ut(t) && t.size !== void 0 }), e._zod.onattach.push(i => { const t = i._zod.bag; t.minimum = n.size, t.maximum = n.size, t.size = n.size }), e._zod.check = i => { const t = i.value, o = t.size; if (o === n.size) return; const s = o > n.size; i.issues.push({ origin: jn(t), ...s ? { code: "too_big", maximum: n.size } : { code: "too_small", minimum: n.size }, inclusive: !0, exact: !0, input: i.value, inst: e, continue: !n.abort }) } }), Xa = d("$ZodCheckMaxLength", (e, n) => { var r; ne.init(e, n), (r = e._zod.def).when ?? (r.when = i => { const t = i.value; return !ut(t) && t.length !== void 0 }), e._zod.onattach.push(i => { const t = i._zod.bag.maximum ?? Number.POSITIVE_INFINITY; n.maximum < t && (i._zod.bag.maximum = n.maximum) }), e._zod.check = i => { const t = i.value; if (t.length <= n.maximum) return; const s = zn(t); i.issues.push({ origin: s, code: "too_big", maximum: n.maximum, inclusive: !0, input: t, inst: e, continue: !n.abort }) } }), Qa = d("$ZodCheckMinLength", (e, n) => { var r; ne.init(e, n), (r = e._zod.def).when ?? (r.when = i => { const t = i.value; return !ut(t) && t.length !== void 0 }), e._zod.onattach.push(i => { const t = i._zod.bag.minimum ?? Number.NEGATIVE_INFINITY; n.minimum > t && (i._zod.bag.minimum = n.minimum) }), e._zod.check = i => { const t = i.value; if (t.length >= n.minimum) return; const s = zn(t); i.issues.push({ origin: s, code: "too_small", minimum: n.minimum, inclusive: !0, input: t, inst: e, continue: !n.abort }) } }), es = d("$ZodCheckLengthEquals", (e, n) => { var r; ne.init(e, n), (r = e._zod.def).when ?? (r.when = i => { const t = i.value; return !ut(t) && t.length !== void 0 }), e._zod.onattach.push(i => { const t = i._zod.bag; t.minimum = n.length, t.maximum = n.length, t.length = n.length }), e._zod.check = i => { const t = i.value, o = t.length; if (o === n.length) return; const s = zn(t), c = o > n.length; i.issues.push({ origin: s, ...c ? { code: "too_big", maximum: n.length } : { code: "too_small", minimum: n.length }, inclusive: !0, exact: !0, input: i.value, inst: e, continue: !n.abort }) } }), Yt = d("$ZodCheckStringFormat", (e, n) => { var r, i; ne.init(e, n), e._zod.onattach.push(t => { const o = t._zod.bag; o.format = n.format, n.pattern && (o.patterns ?? (o.patterns = new Set), o.patterns.add(n.pattern)) }), n.pattern ? (r = e._zod).check ?? (r.check = t => { n.pattern.lastIndex = 0, !n.pattern.test(t.value) && t.issues.push({ origin: "string", code: "invalid_format", format: n.format, input: t.value, ...n.pattern ? { pattern: n.pattern.toString() } : {}, inst: e, continue: !n.abort }) }) : (i = e._zod).check ?? (i.check = () => { }) }), ts = d("$ZodCheckRegex", (e, n) => { Yt.init(e, n), e._zod.check = r => { n.pattern.lastIndex = 0, !n.pattern.test(r.value) && r.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: r.value, pattern: n.pattern.toString(), inst: e, continue: !n.abort }) } }), ns = d("$ZodCheckLowerCase", (e, n) => { n.pattern ?? (n.pattern = Fa), Yt.init(e, n) }), rs = d("$ZodCheckUpperCase", (e, n) => { n.pattern ?? (n.pattern = Ba), Yt.init(e, n) }), is = d("$ZodCheckIncludes", (e, n) => { ne.init(e, n); const r = et(n.includes), i = new RegExp(typeof n.position == "number" ? `^.{${n.position}}${r}` : r); n.pattern = i, e._zod.onattach.push(t => { const o = t._zod.bag; o.patterns ?? (o.patterns = new Set), o.patterns.add(i) }), e._zod.check = t => { t.value.includes(n.includes, n.position) || t.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: n.includes, input: t.value, inst: e, continue: !n.abort }) } }), os = d("$ZodCheckStartsWith", (e, n) => { ne.init(e, n); const r = new RegExp(`^${et(n.prefix)}.*`); n.pattern ?? (n.pattern = r), e._zod.onattach.push(i => { const t = i._zod.bag; t.patterns ?? (t.patterns = new Set), t.patterns.add(r) }), e._zod.check = i => { i.value.startsWith(n.prefix) || i.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: n.prefix, input: i.value, inst: e, continue: !n.abort }) } }), as = d("$ZodCheckEndsWith", (e, n) => { ne.init(e, n); const r = new RegExp(`.*${et(n.suffix)}$`); n.pattern ?? (n.pattern = r), e._zod.onattach.push(i => { const t = i._zod.bag; t.patterns ?? (t.patterns = new Set), t.patterns.add(r) }), e._zod.check = i => { i.value.endsWith(n.suffix) || i.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: n.suffix, input: i.value, inst: e, continue: !n.abort }) } }); function ss(e, n, r) { e.issues.length && n.issues.push(...je(r, e.issues)) } a(ss, "handleCheckPropertyResult"); const cs = d("$ZodCheckProperty", (e, n) => { ne.init(e, n), e._zod.check = r => { const i = n.schema._zod.run({ value: r.value[n.property], issues: [] }, {}); if (i instanceof Promise) return i.then(t => ss(t, r, n.property)); ss(i, r, n.property) } }), us = d("$ZodCheckMimeType", (e, n) => { ne.init(e, n); const r = new Set(n.mime); e._zod.onattach.push(i => { i._zod.bag.mime = n.mime }), e._zod.check = i => { r.has(i.value.type) || i.issues.push({ code: "invalid_value", values: n.mime, input: i.value.type, inst: e, continue: !n.abort }) } }), ls = d("$ZodCheckOverwrite", (e, n) => { ne.init(e, n), e._zod.check = r => { r.value = n.tx(r.value) } }), ho = class ho {
    constructor(n = []) { this.content = [], this.indent = 0, this && (this.args = n) } indented(n) { this.indent += 1, n(this), this.indent -= 1 } write(n) {
      if (typeof n == "function") { n(this, { execution: "sync" }), n(this, { execution: "async" }); return } const i = n.split(`
`).filter(s => s), t = Math.min(...i.map(s => s.length - s.trimStart().length)), o = i.map(s => s.slice(t)).map(s => " ".repeat(this.indent * 2) + s); for (const s of o) this.content.push(s)
    } compile() {
      const n = Function, r = this?.args, t = [...(this?.content ?? [""]).map(o => `  ${o}`)]; return new n(...r, t.join(`
`))
    }
  }; a(ho, "Doc"); let En = ho; const ds = { major: 4, minor: 1, patch: 12 }, D = d("$ZodType", (e, n) => { var r; e ?? (e = {}), e._zod.def = n, e._zod.bag = e._zod.bag || {}, e._zod.version = ds; const i = [...e._zod.def.checks ?? []]; e._zod.traits.has("$ZodCheck") && i.unshift(e); for (const t of i) for (const o of t._zod.onattach) o(e); if (i.length === 0) (r = e._zod).deferred ?? (r.deferred = []), e._zod.deferred?.push(() => { e._zod.run = e._zod.parse }); else { const t = a((s, c, u) => { let p = dt(s), m; for (const f of c) { if (f._zod.def.when) { if (!f._zod.def.when(s)) continue } else if (p) continue; const b = s.issues.length, v = f._zod.check(s); if (v instanceof Promise && u?.async === !1) throw new We; if (m || v instanceof Promise) m = (m ?? Promise.resolve()).then(async () => { await v, s.issues.length !== b && (p || (p = dt(s, b))) }); else { if (s.issues.length === b) continue; p || (p = dt(s, b)) } } return m ? m.then(() => s) : s }, "runChecks"), o = a((s, c, u) => { if (dt(s)) return s.aborted = !0, s; const p = t(c, i, u); if (p instanceof Promise) { if (u.async === !1) throw new We; return p.then(m => e._zod.parse(m, u)) } return e._zod.parse(p, u) }, "handleCanaryResult"); e._zod.run = (s, c) => { if (c.skipChecks) return e._zod.parse(s, c); if (c.direction === "backward") { const p = e._zod.parse({ value: s.value, issues: [] }, { ...c, skipChecks: !0 }); return p instanceof Promise ? p.then(m => o(m, s, c)) : o(p, s, c) } const u = e._zod.parse(s, c); if (u instanceof Promise) { if (c.async === !1) throw new We; return u.then(p => t(p, i, c)) } return t(u, i, c) } } e["~standard"] = { validate: a(t => { try { const o = la(e, t); return o.success ? { value: o.data } : { issues: o.error?.issues } } catch { return da(e, t).then(s => s.success ? { value: s.data } : { issues: s.error?.issues }) } }, "validate"), vendor: "zod", version: 1 } }), Xt = d("$ZodString", (e, n) => { D.init(e, n), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? Pa(e._zod.bag), e._zod.parse = (r, i) => { if (n.coerce) try { r.value = String(r.value) } catch { } return typeof r.value == "string" || r.issues.push({ expected: "string", code: "invalid_type", input: r.value, inst: e }), r } }), q = d("$ZodStringFormat", (e, n) => { Yt.init(e, n), Xt.init(e, n) }), fs = d("$ZodGUID", (e, n) => { n.pattern ?? (n.pattern = ba), q.init(e, n) }), ms = d("$ZodUUID", (e, n) => { if (n.version) { const i = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[n.version]; if (i === void 0) throw new Error(`Invalid UUID version: "${n.version}"`); n.pattern ?? (n.pattern = Ot(i)) } else n.pattern ?? (n.pattern = Ot()); q.init(e, n) }), ps = d("$ZodEmail", (e, n) => { n.pattern ?? (n.pattern = ya), q.init(e, n) }), hs = d("$ZodURL", (e, n) => { q.init(e, n), e._zod.check = r => { try { const i = r.value.trim(), t = new URL(i); n.hostname && (n.hostname.lastIndex = 0, n.hostname.test(t.hostname) || r.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: kr.source, input: r.value, inst: e, continue: !n.abort })), n.protocol && (n.protocol.lastIndex = 0, n.protocol.test(t.protocol.endsWith(":") ? t.protocol.slice(0, -1) : t.protocol) || r.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: n.protocol.source, input: r.value, inst: e, continue: !n.abort })), n.normalize ? r.value = t.href : r.value = i; return } catch { r.issues.push({ code: "invalid_format", format: "url", input: r.value, inst: e, continue: !n.abort }) } } }), gs = d("$ZodEmoji", (e, n) => { n.pattern ?? (n.pattern = wa()), q.init(e, n) }), vs = d("$ZodNanoID", (e, n) => { n.pattern ?? (n.pattern = va), q.init(e, n) }), _s = d("$ZodCUID", (e, n) => { n.pattern ?? (n.pattern = fa), q.init(e, n) }), bs = d("$ZodCUID2", (e, n) => { n.pattern ?? (n.pattern = ma), q.init(e, n) }), ys = d("$ZodULID", (e, n) => { n.pattern ?? (n.pattern = pa), q.init(e, n) }), $s = d("$ZodXID", (e, n) => { n.pattern ?? (n.pattern = ha), q.init(e, n) }), ws = d("$ZodKSUID", (e, n) => { n.pattern ?? (n.pattern = ga), q.init(e, n) }), ks = d("$ZodISODateTime", (e, n) => { n.pattern ?? (n.pattern = Aa(n)), q.init(e, n) }), xs = d("$ZodISODate", (e, n) => { n.pattern ?? (n.pattern = Na), q.init(e, n) }), Is = d("$ZodISOTime", (e, n) => { n.pattern ?? (n.pattern = Ua(n)), q.init(e, n) }), Ss = d("$ZodISODuration", (e, n) => { n.pattern ?? (n.pattern = _a), q.init(e, n) }), js = d("$ZodIPv4", (e, n) => { n.pattern ?? (n.pattern = ka), q.init(e, n), e._zod.onattach.push(r => { const i = r._zod.bag; i.format = "ipv4" }) }), zs = d("$ZodIPv6", (e, n) => { n.pattern ?? (n.pattern = xa), q.init(e, n), e._zod.onattach.push(r => { const i = r._zod.bag; i.format = "ipv6" }), e._zod.check = r => { try { new URL(`http://[${r.value}]`) } catch { r.issues.push({ code: "invalid_format", format: "ipv6", input: r.value, inst: e, continue: !n.abort }) } } }), Es = d("$ZodCIDRv4", (e, n) => { n.pattern ?? (n.pattern = Ia), q.init(e, n) }), Os = d("$ZodCIDRv6", (e, n) => { n.pattern ?? (n.pattern = Sa), q.init(e, n), e._zod.check = r => { const i = r.value.split("/"); try { if (i.length !== 2) throw new Error; const [t, o] = i; if (!o) throw new Error; const s = Number(o); if (`${s}` !== o) throw new Error; if (s < 0 || s > 128) throw new Error; new URL(`http://[${t}]`) } catch { r.issues.push({ code: "invalid_format", format: "cidrv6", input: r.value, inst: e, continue: !n.abort }) } } }); function jr(e) { if (e === "") return !0; if (e.length % 4 !== 0) return !1; try { return atob(e), !0 } catch { return !1 } } a(jr, "isValidBase64"); const Ns = d("$ZodBase64", (e, n) => { n.pattern ?? (n.pattern = ja), q.init(e, n), e._zod.onattach.push(r => { r._zod.bag.contentEncoding = "base64" }), e._zod.check = r => { jr(r.value) || r.issues.push({ code: "invalid_format", format: "base64", input: r.value, inst: e, continue: !n.abort }) } }); function Ts(e) { if (!wr.test(e)) return !1; const n = e.replace(/[-_]/g, i => i === "-" ? "+" : "/"), r = n.padEnd(Math.ceil(n.length / 4) * 4, "="); return jr(r) } a(Ts, "isValidBase64URL"); const Us = d("$ZodBase64URL", (e, n) => { n.pattern ?? (n.pattern = wr), q.init(e, n), e._zod.onattach.push(r => { r._zod.bag.contentEncoding = "base64url" }), e._zod.check = r => { Ts(r.value) || r.issues.push({ code: "invalid_format", format: "base64url", input: r.value, inst: e, continue: !n.abort }) } }), As = d("$ZodE164", (e, n) => { n.pattern ?? (n.pattern = Ea), q.init(e, n) }); function Ps(e, n = null) { try { const r = e.split("."); if (r.length !== 3) return !1; const [i] = r; if (!i) return !1; const t = JSON.parse(atob(i)); return !("typ" in t && t?.typ !== "JWT" || !t.alg || n && (!("alg" in t) || t.alg !== n)) } catch { return !1 } } a(Ps, "isValidJWT"); const Ds = d("$ZodJWT", (e, n) => { q.init(e, n), e._zod.check = r => { Ps(r.value, n.alg) || r.issues.push({ code: "invalid_format", format: "jwt", input: r.value, inst: e, continue: !n.abort }) } }), Ls = d("$ZodCustomStringFormat", (e, n) => { q.init(e, n), e._zod.check = r => { n.fn(r.value) || r.issues.push({ code: "invalid_format", format: n.format, input: r.value, inst: e, continue: !n.abort }) } }), zr = d("$ZodNumber", (e, n) => { D.init(e, n), e._zod.pattern = e._zod.bag.pattern ?? Ra, e._zod.parse = (r, i) => { if (n.coerce) try { r.value = Number(r.value) } catch { } const t = r.value; if (typeof t == "number" && !Number.isNaN(t) && Number.isFinite(t)) return r; const o = typeof t == "number" ? Number.isNaN(t) ? "NaN" : Number.isFinite(t) ? void 0 : "Infinity" : void 0; return r.issues.push({ expected: "number", code: "invalid_type", input: t, inst: e, ...o ? { received: o } : {} }), r } }), Rs = d("$ZodNumber", (e, n) => { Ja.init(e, n), zr.init(e, n) }), Er = d("$ZodBoolean", (e, n) => { D.init(e, n), e._zod.pattern = Ca, e._zod.parse = (r, i) => { if (n.coerce) try { r.value = !!r.value } catch { } const t = r.value; return typeof t == "boolean" || r.issues.push({ expected: "boolean", code: "invalid_type", input: t, inst: e }), r } }), Or = d("$ZodBigInt", (e, n) => { D.init(e, n), e._zod.pattern = Da, e._zod.parse = (r, i) => { if (n.coerce) try { r.value = BigInt(r.value) } catch { } return typeof r.value == "bigint" || r.issues.push({ expected: "bigint", code: "invalid_type", input: r.value, inst: e }), r } }), Cs = d("$ZodBigInt", (e, n) => { Ha.init(e, n), Or.init(e, n) }), Zs = d("$ZodSymbol", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => { const t = r.value; return typeof t == "symbol" || r.issues.push({ expected: "symbol", code: "invalid_type", input: t, inst: e }), r } }), Ms = d("$ZodUndefined", (e, n) => { D.init(e, n), e._zod.pattern = Ma, e._zod.values = new Set([void 0]), e._zod.optin = "optional", e._zod.optout = "optional", e._zod.parse = (r, i) => { const t = r.value; return typeof t > "u" || r.issues.push({ expected: "undefined", code: "invalid_type", input: t, inst: e }), r } }), Fs = d("$ZodNull", (e, n) => { D.init(e, n), e._zod.pattern = Za, e._zod.values = new Set([null]), e._zod.parse = (r, i) => { const t = r.value; return t === null || r.issues.push({ expected: "null", code: "invalid_type", input: t, inst: e }), r } }), Bs = d("$ZodAny", (e, n) => { D.init(e, n), e._zod.parse = r => r }), Ws = d("$ZodUnknown", (e, n) => { D.init(e, n), e._zod.parse = r => r }), Gs = d("$ZodNever", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => (r.issues.push({ expected: "never", code: "invalid_type", input: r.value, inst: e }), r) }), Vs = d("$ZodVoid", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => { const t = r.value; return typeof t > "u" || r.issues.push({ expected: "void", code: "invalid_type", input: t, inst: e }), r } }), Js = d("$ZodDate", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => { if (n.coerce) try { r.value = new Date(r.value) } catch { } const t = r.value, o = t instanceof Date; return o && !Number.isNaN(t.getTime()) || r.issues.push({ expected: "date", code: "invalid_type", input: t, ...o ? { received: "Invalid Date" } : {}, inst: e }), r } }); function Hs(e, n, r) { e.issues.length && n.issues.push(...je(r, e.issues)), n.value[r] = e.value } a(Hs, "handleArrayResult"); const Ks = d("$ZodArray", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => { const t = r.value; if (!Array.isArray(t)) return r.issues.push({ expected: "array", code: "invalid_type", input: t, inst: e }), r; r.value = Array(t.length); const o = []; for (let s = 0; s < t.length; s++) { const c = t[s], u = n.element._zod.run({ value: c, issues: [] }, i); u instanceof Promise ? o.push(u.then(p => Hs(p, r, s))) : Hs(u, r, s) } return o.length ? Promise.all(o).then(() => r) : r } }); function On(e, n, r, i) { e.issues.length && n.issues.push(...je(r, e.issues)), e.value === void 0 ? r in i && (n.value[r] = void 0) : n.value[r] = e.value } a(On, "handlePropertyResult"); function qs(e) { const n = Object.keys(e.shape); for (const i of n) if (!e.shape?.[i]?._zod?.traits?.has("$ZodType")) throw new Error(`Invalid element at key "${i}": expected a Zod schema`); const r = Jo(e.shape); return { ...e, keys: n, keySet: new Set(n), numKeys: n.length, optionalKeys: new Set(r) } } a(qs, "normalizeDef"); function Ys(e, n, r, i, t, o) { const s = [], c = t.keySet, u = t.catchall._zod, p = u.def.type; for (const m of Object.keys(n)) { if (c.has(m)) continue; if (p === "never") { s.push(m); continue } const f = u.run({ value: n[m], issues: [] }, i); f instanceof Promise ? e.push(f.then(b => On(b, r, m, n))) : On(f, r, m, n) } return s.length && r.issues.push({ code: "unrecognized_keys", keys: s, input: n, inst: o }), e.length ? Promise.all(e).then(() => r) : r } a(Ys, "handleCatchall"); const Xs = d("$ZodObject", (e, n) => { if (D.init(e, n), !Object.getOwnPropertyDescriptor(n, "shape")?.get) { const c = n.shape; Object.defineProperty(n, "shape", { get: a(() => { const u = { ...c }; return Object.defineProperty(n, "shape", { value: u }), u }, "get") }) } const i = Bt(() => qs(n)); F(e._zod, "propValues", () => { const c = n.shape, u = {}; for (const p in c) { const m = c[p]._zod; if (m.values) { u[p] ?? (u[p] = new Set); for (const f of m.values) u[p].add(f) } } return u }); const t = zt, o = n.catchall; let s; e._zod.parse = (c, u) => { s ?? (s = i.value); const p = c.value; if (!t(p)) return c.issues.push({ expected: "object", code: "invalid_type", input: p, inst: e }), c; c.value = {}; const m = [], f = s.shape; for (const b of s.keys) { const h = f[b]._zod.run({ value: p[b], issues: [] }, u); h instanceof Promise ? m.push(h.then(y => On(y, c, b, p))) : On(h, c, b, p) } return o ? Ys(m, p, c, u, i.value, e) : m.length ? Promise.all(m).then(() => c) : c } }), Qs = d("$ZodObjectJIT", (e, n) => {
    Xs.init(e, n); const r = e._zod.parse, i = Bt(() => qs(n)), t = a(b => {
      const v = new En(["shape", "payload", "ctx"]), h = i.value, y = a(z => { const I = ar(z); return `shape[${I}]._zod.run({ value: input[${I}], issues: [] }, ctx)` }, "parseStr"); v.write("const input = payload.value;"); const w = Object.create(null); let j = 0; for (const z of h.keys) w[z] = `key_${j++}`; v.write("const newResult = {};"); for (const z of h.keys) {
        const I = w[z], M = ar(z); v.write(`const ${I} = ${y(z)};`), v.write(`
        if (${I}.issues.length) {
          payload.issues = payload.issues.concat(${I}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${M}, ...iss.path] : [${M}]
          })));
        }
        
        
        if (${I}.value === undefined) {
          if (${M} in input) {
            newResult[${M}] = undefined;
          }
        } else {
          newResult[${M}] = ${I}.value;
        }
        
      `)
      } v.write("payload.value = newResult;"), v.write("return payload;"); const A = v.compile(); return (z, I) => A(b, z, I)
    }, "generateFastpass"); let o; const s = zt, c = !wn.jitless, p = c && Go.value, m = n.catchall; let f; e._zod.parse = (b, v) => { f ?? (f = i.value); const h = b.value; return s(h) ? c && p && v?.async === !1 && v.jitless !== !0 ? (o || (o = t(n.shape)), b = o(b, v), m ? Ys([], h, b, v, f, e) : b) : r(b, v) : (b.issues.push({ expected: "object", code: "invalid_type", input: h, inst: e }), b) }
  }); function ec(e, n, r, i) { for (const o of e) if (o.issues.length === 0) return n.value = o.value, n; const t = e.filter(o => !dt(o)); return t.length === 1 ? (n.value = t[0].value, t[0]) : (n.issues.push({ code: "invalid_union", input: n.value, inst: r, errors: e.map(o => o.issues.map(s => ze(s, i, fe()))) }), n) } a(ec, "handleUnionResults"); const Nr = d("$ZodUnion", (e, n) => { D.init(e, n), F(e._zod, "optin", () => n.options.some(t => t._zod.optin === "optional") ? "optional" : void 0), F(e._zod, "optout", () => n.options.some(t => t._zod.optout === "optional") ? "optional" : void 0), F(e._zod, "values", () => { if (n.options.every(t => t._zod.values)) return new Set(n.options.flatMap(t => Array.from(t._zod.values))) }), F(e._zod, "pattern", () => { if (n.options.every(t => t._zod.pattern)) { const t = n.options.map(o => o._zod.pattern); return new RegExp(`^(${t.map(o => xn(o.source)).join("|")})$`) } }); const r = n.options.length === 1, i = n.options[0]._zod.run; e._zod.parse = (t, o) => { if (r) return i(t, o); let s = !1; const c = []; for (const u of n.options) { const p = u._zod.run({ value: t.value, issues: [] }, o); if (p instanceof Promise) c.push(p), s = !0; else { if (p.issues.length === 0) return p; c.push(p) } } return s ? Promise.all(c).then(u => ec(u, t, e, o)) : ec(c, t, e, o) } }), tc = d("$ZodDiscriminatedUnion", (e, n) => { Nr.init(e, n); const r = e._zod.parse; F(e._zod, "propValues", () => { const t = {}; for (const o of n.options) { const s = o._zod.propValues; if (!s || Object.keys(s).length === 0) throw new Error(`Invalid discriminated union option at index "${n.options.indexOf(o)}"`); for (const [c, u] of Object.entries(s)) { t[c] || (t[c] = new Set); for (const p of u) t[c].add(p) } } return t }); const i = Bt(() => { const t = n.options, o = new Map; for (const s of t) { const c = s._zod.propValues?.[n.discriminator]; if (!c || c.size === 0) throw new Error(`Invalid discriminated union option at index "${n.options.indexOf(s)}"`); for (const u of c) { if (o.has(u)) throw new Error(`Duplicate discriminator value "${String(u)}"`); o.set(u, s) } } return o }); e._zod.parse = (t, o) => { const s = t.value; if (!zt(s)) return t.issues.push({ code: "invalid_type", expected: "object", input: s, inst: e }), t; const c = i.value.get(s?.[n.discriminator]); return c ? c._zod.run(t, o) : n.unionFallback ? r(t, o) : (t.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", discriminator: n.discriminator, input: s, path: [n.discriminator], inst: e }), t) } }), nc = d("$ZodIntersection", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => { const t = r.value, o = n.left._zod.run({ value: t, issues: [] }, i), s = n.right._zod.run({ value: t, issues: [] }, i); return o instanceof Promise || s instanceof Promise ? Promise.all([o, s]).then(([u, p]) => rc(r, u, p)) : rc(r, o, s) } }); function Tr(e, n) { if (e === n) return { valid: !0, data: e }; if (e instanceof Date && n instanceof Date && +e == +n) return { valid: !0, data: e }; if (lt(e) && lt(n)) { const r = Object.keys(n), i = Object.keys(e).filter(o => r.indexOf(o) !== -1), t = { ...e, ...n }; for (const o of i) { const s = Tr(e[o], n[o]); if (!s.valid) return { valid: !1, mergeErrorPath: [o, ...s.mergeErrorPath] }; t[o] = s.data } return { valid: !0, data: t } } if (Array.isArray(e) && Array.isArray(n)) { if (e.length !== n.length) return { valid: !1, mergeErrorPath: [] }; const r = []; for (let i = 0; i < e.length; i++) { const t = e[i], o = n[i], s = Tr(t, o); if (!s.valid) return { valid: !1, mergeErrorPath: [i, ...s.mergeErrorPath] }; r.push(s.data) } return { valid: !0, data: r } } return { valid: !1, mergeErrorPath: [] } } a(Tr, "mergeValues"); function rc(e, n, r) { if (n.issues.length && e.issues.push(...n.issues), r.issues.length && e.issues.push(...r.issues), dt(e)) return e; const i = Tr(n.value, r.value); if (!i.valid) throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(i.mergeErrorPath)}`); return e.value = i.data, e } a(rc, "handleIntersectionResults"); const Ur = d("$ZodTuple", (e, n) => { D.init(e, n); const r = n.items, i = r.length - [...r].reverse().findIndex(t => t._zod.optin !== "optional"); e._zod.parse = (t, o) => { const s = t.value; if (!Array.isArray(s)) return t.issues.push({ input: s, inst: e, expected: "tuple", code: "invalid_type" }), t; t.value = []; const c = []; if (!n.rest) { const p = s.length > r.length, m = s.length < i - 1; if (p || m) return t.issues.push({ ...p ? { code: "too_big", maximum: r.length } : { code: "too_small", minimum: r.length }, input: s, inst: e, origin: "array" }), t } let u = -1; for (const p of r) { if (u++, u >= s.length && u >= i) continue; const m = p._zod.run({ value: s[u], issues: [] }, o); m instanceof Promise ? c.push(m.then(f => Nn(f, t, u))) : Nn(m, t, u) } if (n.rest) { const p = s.slice(r.length); for (const m of p) { u++; const f = n.rest._zod.run({ value: m, issues: [] }, o); f instanceof Promise ? c.push(f.then(b => Nn(b, t, u))) : Nn(f, t, u) } } return c.length ? Promise.all(c).then(() => t) : t } }); function Nn(e, n, r) { e.issues.length && n.issues.push(...je(r, e.issues)), n.value[r] = e.value } a(Nn, "handleTupleResult"); const ic = d("$ZodRecord", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => { const t = r.value; if (!lt(t)) return r.issues.push({ expected: "record", code: "invalid_type", input: t, inst: e }), r; const o = []; if (n.keyType._zod.values) { const s = n.keyType._zod.values; r.value = {}; for (const u of s) if (typeof u == "string" || typeof u == "number" || typeof u == "symbol") { const p = n.valueType._zod.run({ value: t[u], issues: [] }, i); p instanceof Promise ? o.push(p.then(m => { m.issues.length && r.issues.push(...je(u, m.issues)), r.value[u] = m.value })) : (p.issues.length && r.issues.push(...je(u, p.issues)), r.value[u] = p.value) } let c; for (const u in t) s.has(u) || (c = c ?? [], c.push(u)); c && c.length > 0 && r.issues.push({ code: "unrecognized_keys", input: t, inst: e, keys: c }) } else { r.value = {}; for (const s of Reflect.ownKeys(t)) { if (s === "__proto__") continue; const c = n.keyType._zod.run({ value: s, issues: [] }, i); if (c instanceof Promise) throw new Error("Async schemas not supported in object keys currently"); if (c.issues.length) { r.issues.push({ code: "invalid_key", origin: "record", issues: c.issues.map(p => ze(p, i, fe())), input: s, path: [s], inst: e }), r.value[c.value] = c.value; continue } const u = n.valueType._zod.run({ value: t[s], issues: [] }, i); u instanceof Promise ? o.push(u.then(p => { p.issues.length && r.issues.push(...je(s, p.issues)), r.value[c.value] = p.value })) : (u.issues.length && r.issues.push(...je(s, u.issues)), r.value[c.value] = u.value) } } return o.length ? Promise.all(o).then(() => r) : r } }), oc = d("$ZodMap", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => { const t = r.value; if (!(t instanceof Map)) return r.issues.push({ expected: "map", code: "invalid_type", input: t, inst: e }), r; const o = []; r.value = new Map; for (const [s, c] of t) { const u = n.keyType._zod.run({ value: s, issues: [] }, i), p = n.valueType._zod.run({ value: c, issues: [] }, i); u instanceof Promise || p instanceof Promise ? o.push(Promise.all([u, p]).then(([m, f]) => { ac(m, f, r, s, t, e, i) })) : ac(u, p, r, s, t, e, i) } return o.length ? Promise.all(o).then(() => r) : r } }); function ac(e, n, r, i, t, o, s) { e.issues.length && (Sn.has(typeof i) ? r.issues.push(...je(i, e.issues)) : r.issues.push({ code: "invalid_key", origin: "map", input: t, inst: o, issues: e.issues.map(c => ze(c, s, fe())) })), n.issues.length && (Sn.has(typeof i) ? r.issues.push(...je(i, n.issues)) : r.issues.push({ origin: "map", code: "invalid_element", input: t, inst: o, key: i, issues: n.issues.map(c => ze(c, s, fe())) })), r.value.set(e.value, n.value) } a(ac, "handleMapResult"); const sc = d("$ZodSet", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => { const t = r.value; if (!(t instanceof Set)) return r.issues.push({ input: t, inst: e, expected: "set", code: "invalid_type" }), r; const o = []; r.value = new Set; for (const s of t) { const c = n.valueType._zod.run({ value: s, issues: [] }, i); c instanceof Promise ? o.push(c.then(u => cc(u, r))) : cc(c, r) } return o.length ? Promise.all(o).then(() => r) : r } }); function cc(e, n) { e.issues.length && n.issues.push(...e.issues), n.value.add(e.value) } a(cc, "handleSetResult"); const uc = d("$ZodEnum", (e, n) => { D.init(e, n); const r = or(n.entries), i = new Set(r); e._zod.values = i, e._zod.pattern = new RegExp(`^(${r.filter(t => Sn.has(typeof t)).map(t => typeof t == "string" ? et(t) : t.toString()).join("|")})$`), e._zod.parse = (t, o) => { const s = t.value; return i.has(s) || t.issues.push({ code: "invalid_value", values: r, input: s, inst: e }), t } }), lc = d("$ZodLiteral", (e, n) => { if (D.init(e, n), n.values.length === 0) throw new Error("Cannot create literal schema with no valid values"); e._zod.values = new Set(n.values), e._zod.pattern = new RegExp(`^(${n.values.map(r => typeof r == "string" ? et(r) : r ? et(r.toString()) : String(r)).join("|")})$`), e._zod.parse = (r, i) => { const t = r.value; return e._zod.values.has(t) || r.issues.push({ code: "invalid_value", values: n.values, input: t, inst: e }), r } }), dc = d("$ZodFile", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => { const t = r.value; return t instanceof File || r.issues.push({ expected: "file", code: "invalid_type", input: t, inst: e }), r } }), fc = d("$ZodTransform", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => { if (i.direction === "backward") throw new jt(e.constructor.name); const t = n.transform(r.value, r); if (i.async) return (t instanceof Promise ? t : Promise.resolve(t)).then(s => (r.value = s, r)); if (t instanceof Promise) throw new We; return r.value = t, r } }); function mc(e, n) { return e.issues.length && n === void 0 ? { issues: [], value: void 0 } : e } a(mc, "handleOptionalResult"); const pc = d("$ZodOptional", (e, n) => { D.init(e, n), e._zod.optin = "optional", e._zod.optout = "optional", F(e._zod, "values", () => n.innerType._zod.values ? new Set([...n.innerType._zod.values, void 0]) : void 0), F(e._zod, "pattern", () => { const r = n.innerType._zod.pattern; return r ? new RegExp(`^(${xn(r.source)})?$`) : void 0 }), e._zod.parse = (r, i) => { if (n.innerType._zod.optin === "optional") { const t = n.innerType._zod.run(r, i); return t instanceof Promise ? t.then(o => mc(o, r.value)) : mc(t, r.value) } return r.value === void 0 ? r : n.innerType._zod.run(r, i) } }), hc = d("$ZodNullable", (e, n) => { D.init(e, n), F(e._zod, "optin", () => n.innerType._zod.optin), F(e._zod, "optout", () => n.innerType._zod.optout), F(e._zod, "pattern", () => { const r = n.innerType._zod.pattern; return r ? new RegExp(`^(${xn(r.source)}|null)$`) : void 0 }), F(e._zod, "values", () => n.innerType._zod.values ? new Set([...n.innerType._zod.values, null]) : void 0), e._zod.parse = (r, i) => r.value === null ? r : n.innerType._zod.run(r, i) }), gc = d("$ZodDefault", (e, n) => { D.init(e, n), e._zod.optin = "optional", F(e._zod, "values", () => n.innerType._zod.values), e._zod.parse = (r, i) => { if (i.direction === "backward") return n.innerType._zod.run(r, i); if (r.value === void 0) return r.value = n.defaultValue, r; const t = n.innerType._zod.run(r, i); return t instanceof Promise ? t.then(o => vc(o, n)) : vc(t, n) } }); function vc(e, n) { return e.value === void 0 && (e.value = n.defaultValue), e } a(vc, "handleDefaultResult"); const _c = d("$ZodPrefault", (e, n) => { D.init(e, n), e._zod.optin = "optional", F(e._zod, "values", () => n.innerType._zod.values), e._zod.parse = (r, i) => (i.direction === "backward" || r.value === void 0 && (r.value = n.defaultValue), n.innerType._zod.run(r, i)) }), bc = d("$ZodNonOptional", (e, n) => { D.init(e, n), F(e._zod, "values", () => { const r = n.innerType._zod.values; return r ? new Set([...r].filter(i => i !== void 0)) : void 0 }), e._zod.parse = (r, i) => { const t = n.innerType._zod.run(r, i); return t instanceof Promise ? t.then(o => yc(o, e)) : yc(t, e) } }); function yc(e, n) { return !e.issues.length && e.value === void 0 && e.issues.push({ code: "invalid_type", expected: "nonoptional", input: e.value, inst: n }), e } a(yc, "handleNonOptionalResult"); const $c = d("$ZodSuccess", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => { if (i.direction === "backward") throw new jt("ZodSuccess"); const t = n.innerType._zod.run(r, i); return t instanceof Promise ? t.then(o => (r.value = o.issues.length === 0, r)) : (r.value = t.issues.length === 0, r) } }), wc = d("$ZodCatch", (e, n) => { D.init(e, n), F(e._zod, "optin", () => n.innerType._zod.optin), F(e._zod, "optout", () => n.innerType._zod.optout), F(e._zod, "values", () => n.innerType._zod.values), e._zod.parse = (r, i) => { if (i.direction === "backward") return n.innerType._zod.run(r, i); const t = n.innerType._zod.run(r, i); return t instanceof Promise ? t.then(o => (r.value = o.value, o.issues.length && (r.value = n.catchValue({ ...r, error: { issues: o.issues.map(s => ze(s, i, fe())) }, input: r.value }), r.issues = []), r)) : (r.value = t.value, t.issues.length && (r.value = n.catchValue({ ...r, error: { issues: t.issues.map(o => ze(o, i, fe())) }, input: r.value }), r.issues = []), r) } }), kc = d("$ZodNaN", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => ((typeof r.value != "number" || !Number.isNaN(r.value)) && r.issues.push({ input: r.value, inst: e, expected: "nan", code: "invalid_type" }), r) }), xc = d("$ZodPipe", (e, n) => { D.init(e, n), F(e._zod, "values", () => n.in._zod.values), F(e._zod, "optin", () => n.in._zod.optin), F(e._zod, "optout", () => n.out._zod.optout), F(e._zod, "propValues", () => n.in._zod.propValues), e._zod.parse = (r, i) => { if (i.direction === "backward") { const o = n.out._zod.run(r, i); return o instanceof Promise ? o.then(s => Tn(s, n.in, i)) : Tn(o, n.in, i) } const t = n.in._zod.run(r, i); return t instanceof Promise ? t.then(o => Tn(o, n.out, i)) : Tn(t, n.out, i) } }); function Tn(e, n, r) { return e.issues.length ? (e.aborted = !0, e) : n._zod.run({ value: e.value, issues: e.issues }, r) } a(Tn, "handlePipeResult"); const Ar = d("$ZodCodec", (e, n) => { D.init(e, n), F(e._zod, "values", () => n.in._zod.values), F(e._zod, "optin", () => n.in._zod.optin), F(e._zod, "optout", () => n.out._zod.optout), F(e._zod, "propValues", () => n.in._zod.propValues), e._zod.parse = (r, i) => { if ((i.direction || "forward") === "forward") { const o = n.in._zod.run(r, i); return o instanceof Promise ? o.then(s => Un(s, n, i)) : Un(o, n, i) } else { const o = n.out._zod.run(r, i); return o instanceof Promise ? o.then(s => Un(s, n, i)) : Un(o, n, i) } } }); function Un(e, n, r) { if (e.issues.length) return e.aborted = !0, e; if ((r.direction || "forward") === "forward") { const t = n.transform(e.value, e); return t instanceof Promise ? t.then(o => An(e, o, n.out, r)) : An(e, t, n.out, r) } else { const t = n.reverseTransform(e.value, e); return t instanceof Promise ? t.then(o => An(e, o, n.in, r)) : An(e, t, n.in, r) } } a(Un, "handleCodecAResult"); function An(e, n, r, i) { return e.issues.length ? (e.aborted = !0, e) : r._zod.run({ value: n, issues: e.issues }, i) } a(An, "handleCodecTxResult"); const Ic = d("$ZodReadonly", (e, n) => { D.init(e, n), F(e._zod, "propValues", () => n.innerType._zod.propValues), F(e._zod, "values", () => n.innerType._zod.values), F(e._zod, "optin", () => n.innerType._zod.optin), F(e._zod, "optout", () => n.innerType._zod.optout), e._zod.parse = (r, i) => { if (i.direction === "backward") return n.innerType._zod.run(r, i); const t = n.innerType._zod.run(r, i); return t instanceof Promise ? t.then(Sc) : Sc(t) } }); function Sc(e) { return e.value = Object.freeze(e.value), e } a(Sc, "handleReadonlyResult"); const jc = d("$ZodTemplateLiteral", (e, n) => { D.init(e, n); const r = []; for (const i of n.parts) if (typeof i == "object" && i !== null) { if (!i._zod.pattern) throw new Error(`Invalid template literal part, no pattern found: ${[...i._zod.traits].shift()}`); const t = i._zod.pattern instanceof RegExp ? i._zod.pattern.source : i._zod.pattern; if (!t) throw new Error(`Invalid template literal part: ${i._zod.traits}`); const o = t.startsWith("^") ? 1 : 0, s = t.endsWith("$") ? t.length - 1 : t.length; r.push(t.slice(o, s)) } else if (i === null || Vo.has(typeof i)) r.push(et(`${i}`)); else throw new Error(`Invalid template literal part: ${i}`); e._zod.pattern = new RegExp(`^${r.join("")}$`), e._zod.parse = (i, t) => typeof i.value != "string" ? (i.issues.push({ input: i.value, inst: e, expected: "template_literal", code: "invalid_type" }), i) : (e._zod.pattern.lastIndex = 0, e._zod.pattern.test(i.value) || i.issues.push({ input: i.value, inst: e, code: "invalid_format", format: n.format ?? "template_literal", pattern: e._zod.pattern.source }), i) }), zc = d("$ZodFunction", (e, n) => (D.init(e, n), e._def = n, e._zod.def = n, e.implement = r => { if (typeof r != "function") throw new Error("implement() must be called with a function"); return function (...i) { const t = e._def.input ? fr(e._def.input, i) : i, o = Reflect.apply(r, this, t); return e._def.output ? fr(e._def.output, o) : o } }, e.implementAsync = r => { if (typeof r != "function") throw new Error("implementAsync() must be called with a function"); return async function (...i) { const t = e._def.input ? await mr(e._def.input, i) : i, o = await Reflect.apply(r, this, t); return e._def.output ? await mr(e._def.output, o) : o } }, e._zod.parse = (r, i) => typeof r.value != "function" ? (r.issues.push({ code: "invalid_type", expected: "function", input: r.value, inst: e }), r) : (e._def.output && e._def.output._zod.def.type === "promise" ? r.value = e.implementAsync(r.value) : r.value = e.implement(r.value), r), e.input = (...r) => { const i = e.constructor; return Array.isArray(r[0]) ? new i({ type: "function", input: new Ur({ type: "tuple", items: r[0], rest: r[1] }), output: e._def.output }) : new i({ type: "function", input: r[0], output: e._def.output }) }, e.output = r => { const i = e.constructor; return new i({ type: "function", input: e._def.input, output: r }) }, e)), Ec = d("$ZodPromise", (e, n) => { D.init(e, n), e._zod.parse = (r, i) => Promise.resolve(r.value).then(t => n.innerType._zod.run({ value: t, issues: [] }, i)) }), Oc = d("$ZodLazy", (e, n) => { D.init(e, n), F(e._zod, "innerType", () => n.getter()), F(e._zod, "pattern", () => e._zod.innerType._zod.pattern), F(e._zod, "propValues", () => e._zod.innerType._zod.propValues), F(e._zod, "optin", () => e._zod.innerType._zod.optin ?? void 0), F(e._zod, "optout", () => e._zod.innerType._zod.optout ?? void 0), e._zod.parse = (r, i) => e._zod.innerType._zod.run(r, i) }), Nc = d("$ZodCustom", (e, n) => { ne.init(e, n), D.init(e, n), e._zod.parse = (r, i) => r, e._zod.check = r => { const i = r.value, t = n.fn(i); if (t instanceof Promise) return t.then(o => Tc(o, r, i, e)); Tc(t, r, i, e) } }); function Tc(e, n, r, i) { if (!e) { const t = { code: "custom", input: r, inst: i, path: [...i._zod.def.path ?? []], continue: !i._zod.def.abort }; i._zod.def.params && (t.params = i._zod.def.params), n.issues.push(Et(t)) } } a(Tc, "handleRefineResult"); const pf = a(() => { const e = { string: { unit: "Ø­Ø±Ù", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" }, file: { unit: "Ø¨Ø§ÙŠØª", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" }, array: { unit: "Ø¹Ù†ØµØ±", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" }, set: { unit: "Ø¹Ù†ØµØ±", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "Ù…Ø¯Ø®Ù„", email: "Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ", url: "Ø±Ø§Ø¨Ø·", emoji: "Ø¥ÙŠÙ…ÙˆØ¬ÙŠ", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ØªØ§Ø±ÙŠØ® ÙˆÙˆÙ‚Øª Ø¨Ù…Ø¹ÙŠØ§Ø± ISO", date: "ØªØ§Ø±ÙŠØ® Ø¨Ù…Ø¹ÙŠØ§Ø± ISO", time: "ÙˆÙ‚Øª Ø¨Ù…Ø¹ÙŠØ§Ø± ISO", duration: "Ù…Ø¯Ø© Ø¨Ù…Ø¹ÙŠØ§Ø± ISO", ipv4: "Ø¹Ù†ÙˆØ§Ù† IPv4", ipv6: "Ø¹Ù†ÙˆØ§Ù† IPv6", cidrv4: "Ù…Ø¯Ù‰ Ø¹Ù†Ø§ÙˆÙŠÙ† Ø¨ØµÙŠØºØ© IPv4", cidrv6: "Ù…Ø¯Ù‰ Ø¹Ù†Ø§ÙˆÙŠÙ† Ø¨ØµÙŠØºØ© IPv6", base64: "Ù†ÙŽØµ Ø¨ØªØ±Ù…ÙŠØ² base64-encoded", base64url: "Ù†ÙŽØµ Ø¨ØªØ±Ù…ÙŠØ² base64url-encoded", json_string: "Ù†ÙŽØµ Ø¹Ù„Ù‰ Ù‡ÙŠØ¦Ø© JSON", e164: "Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø¨Ù…Ø¹ÙŠØ§Ø± E.164", jwt: "JWT", template_literal: "Ù…Ø¯Ø®Ù„" }; return t => { switch (t.code) { case "invalid_type": return `Ù…Ø¯Ø®Ù„Ø§Øª ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„Ø©: ÙŠÙØªØ±Ø¶ Ø¥Ø¯Ø®Ø§Ù„ ${t.expected}ØŒ ÙˆÙ„ÙƒÙ† ØªÙ… Ø¥Ø¯Ø®Ø§Ù„ ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Ù…Ø¯Ø®Ù„Ø§Øª ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„Ø©: ÙŠÙØªØ±Ø¶ Ø¥Ø¯Ø®Ø§Ù„ ${P(t.values[0])}` : `Ø§Ø®ØªÙŠØ§Ø± ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØªÙˆÙ‚Ø¹ Ø§Ù†ØªÙ‚Ø§Ø¡ Ø£Ø­Ø¯ Ù‡Ø°Ù‡ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª: ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? ` Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ø£Ù† ØªÙƒÙˆÙ† ${t.origin ?? "Ø§Ù„Ù‚ÙŠÙ…Ø©"} ${o} ${t.maximum.toString()} ${s.unit ?? "Ø¹Ù†ØµØ±"}` : `Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ø£Ù† ØªÙƒÙˆÙ† ${t.origin ?? "Ø§Ù„Ù‚ÙŠÙ…Ø©"} ${o} ${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Ø£ØµØºØ± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ù„Ù€ ${t.origin} Ø£Ù† ÙŠÙƒÙˆÙ† ${o} ${t.minimum.toString()} ${s.unit}` : `Ø£ØµØºØ± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ù„Ù€ ${t.origin} Ø£Ù† ÙŠÙƒÙˆÙ† ${o} ${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€ "${t.prefix}"` : o.format === "ends_with" ? `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙ†ØªÙ‡ÙŠ Ø¨Ù€ "${o.suffix}"` : o.format === "includes" ? `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªØ¶Ù…Ù‘ÙŽÙ† "${o.includes}"` : o.format === "regex" ? `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ·Ø§Ø¨Ù‚ Ø§Ù„Ù†Ù…Ø· ${o.pattern}` : `${i[o.format] ?? t.format} ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„` } case "not_multiple_of": return `Ø±Ù‚Ù… ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…Ù† Ù…Ø¶Ø§Ø¹ÙØ§Øª ${t.divisor}`; case "unrecognized_keys": return `Ù…Ø¹Ø±Ù${t.keys.length > 1 ? "Ø§Øª" : ""} ØºØ±ÙŠØ¨${t.keys.length > 1 ? "Ø©" : ""}: ${$(t.keys, "ØŒ ")}`; case "invalid_key": return `Ù…Ø¹Ø±Ù ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„ ÙÙŠ ${t.origin}`; case "invalid_union": return "Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„"; case "invalid_element": return `Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„ ÙÙŠ ${t.origin}`; default: return "Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„" } } }, "error$J"); function hf() { return { localeError: pf() } } a(hf, "ar"); const gf = a(() => { const e = { string: { unit: "simvol", verb: "olmalÄ±dÄ±r" }, file: { unit: "bayt", verb: "olmalÄ±dÄ±r" }, array: { unit: "element", verb: "olmalÄ±dÄ±r" }, set: { unit: "element", verb: "olmalÄ±dÄ±r" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `YanlÄ±ÅŸ dÉ™yÉ™r: gÃ¶zlÉ™nilÉ™n ${t.expected}, daxil olan ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `YanlÄ±ÅŸ dÉ™yÉ™r: gÃ¶zlÉ™nilÉ™n ${P(t.values[0])}` : `YanlÄ±ÅŸ seÃ§im: aÅŸaÄŸÄ±dakÄ±lardan biri olmalÄ±dÄ±r: ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Ã‡ox bÃ¶yÃ¼k: gÃ¶zlÉ™nilÉ™n ${t.origin ?? "dÉ™yÉ™r"} ${o}${t.maximum.toString()} ${s.unit ?? "element"}` : `Ã‡ox bÃ¶yÃ¼k: gÃ¶zlÉ™nilÉ™n ${t.origin ?? "dÉ™yÉ™r"} ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Ã‡ox kiÃ§ik: gÃ¶zlÉ™nilÉ™n ${t.origin} ${o}${t.minimum.toString()} ${s.unit}` : `Ã‡ox kiÃ§ik: gÃ¶zlÉ™nilÉ™n ${t.origin} ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `YanlÄ±ÅŸ mÉ™tn: "${o.prefix}" ilÉ™ baÅŸlamalÄ±dÄ±r` : o.format === "ends_with" ? `YanlÄ±ÅŸ mÉ™tn: "${o.suffix}" ilÉ™ bitmÉ™lidir` : o.format === "includes" ? `YanlÄ±ÅŸ mÉ™tn: "${o.includes}" daxil olmalÄ±dÄ±r` : o.format === "regex" ? `YanlÄ±ÅŸ mÉ™tn: ${o.pattern} ÅŸablonuna uyÄŸun olmalÄ±dÄ±r` : `YanlÄ±ÅŸ ${i[o.format] ?? t.format}` } case "not_multiple_of": return `YanlÄ±ÅŸ É™dÉ™d: ${t.divisor} ilÉ™ bÃ¶lÃ¼nÉ™ bilÉ™n olmalÄ±dÄ±r`; case "unrecognized_keys": return `TanÄ±nmayan aÃ§ar${t.keys.length > 1 ? "lar" : ""}: ${$(t.keys, ", ")}`; case "invalid_key": return `${t.origin} daxilindÉ™ yanlÄ±ÅŸ aÃ§ar`; case "invalid_union": return "YanlÄ±ÅŸ dÉ™yÉ™r"; case "invalid_element": return `${t.origin} daxilindÉ™ yanlÄ±ÅŸ dÉ™yÉ™r`; default: return "YanlÄ±ÅŸ dÉ™yÉ™r" } } }, "error$I"); function vf() { return { localeError: gf() } } a(vf, "az"); function Uc(e, n, r, i) { const t = Math.abs(e), o = t % 10, s = t % 100; return s >= 11 && s <= 19 ? i : o === 1 ? n : o >= 2 && o <= 4 ? r : i } a(Uc, "getBelarusianPlural"); const _f = a(() => { const e = { string: { unit: { one: "ÑÑ–Ð¼Ð²Ð°Ð»", few: "ÑÑ–Ð¼Ð²Ð°Ð»Ñ‹", many: "ÑÑ–Ð¼Ð²Ð°Ð»Ð°Ñž" }, verb: "Ð¼ÐµÑ†ÑŒ" }, array: { unit: { one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚", few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹", many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ñž" }, verb: "Ð¼ÐµÑ†ÑŒ" }, set: { unit: { one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚", few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹", many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ñž" }, verb: "Ð¼ÐµÑ†ÑŒ" }, file: { unit: { one: "Ð±Ð°Ð¹Ñ‚", few: "Ð±Ð°Ð¹Ñ‚Ñ‹", many: "Ð±Ð°Ð¹Ñ‚Ð°Ñž" }, verb: "Ð¼ÐµÑ†ÑŒ" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "Ð»Ñ–Ðº"; case "object": { if (Array.isArray(t)) return "Ð¼Ð°ÑÑ–Ñž"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "ÑƒÐ²Ð¾Ð´", email: "email Ð°Ð´Ñ€Ð°Ñ", url: "URL", emoji: "ÑÐ¼Ð¾Ð´Ð·Ñ–", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO Ð´Ð°Ñ‚Ð° Ñ– Ñ‡Ð°Ñ", date: "ISO Ð´Ð°Ñ‚Ð°", time: "ISO Ñ‡Ð°Ñ", duration: "ISO Ð¿Ñ€Ð°Ñ†ÑÐ³Ð»Ð°ÑÑ†ÑŒ", ipv4: "IPv4 Ð°Ð´Ñ€Ð°Ñ", ipv6: "IPv6 Ð°Ð´Ñ€Ð°Ñ", cidrv4: "IPv4 Ð´Ñ‹ÑÐ¿Ð°Ð·Ð¾Ð½", cidrv6: "IPv6 Ð´Ñ‹ÑÐ¿Ð°Ð·Ð¾Ð½", base64: "Ñ€Ð°Ð´Ð¾Ðº Ñƒ Ñ„Ð°Ñ€Ð¼Ð°Ñ†Ðµ base64", base64url: "Ñ€Ð°Ð´Ð¾Ðº Ñƒ Ñ„Ð°Ñ€Ð¼Ð°Ñ†Ðµ base64url", json_string: "JSON Ñ€Ð°Ð´Ð¾Ðº", e164: "Ð½ÑƒÐ¼Ð°Ñ€ E.164", jwt: "JWT", template_literal: "ÑƒÐ²Ð¾Ð´" }; return t => { switch (t.code) { case "invalid_type": return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´: Ñ‡Ð°ÐºÐ°ÑžÑÑ ${t.expected}, Ð°Ñ‚Ñ€Ñ‹Ð¼Ð°Ð½Ð° ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ ${P(t.values[0])}` : `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ð²Ð°Ñ€Ñ‹ÑÐ½Ñ‚: Ñ‡Ð°ÐºÐ°ÑžÑÑ Ð°Ð´Ð·Ñ–Ð½ Ð· ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); if (s) { const c = Number(t.maximum), u = Uc(c, s.unit.one, s.unit.few, s.unit.many); return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð²ÑÐ»Ñ–ÐºÑ–: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${t.origin ?? "Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ"} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° ${s.verb} ${o}${t.maximum.toString()} ${u}` } return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð²ÑÐ»Ñ–ÐºÑ–: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${t.origin ?? "Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ"} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° Ð±Ñ‹Ñ†ÑŒ ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); if (s) { const c = Number(t.minimum), u = Uc(c, s.unit.one, s.unit.few, s.unit.many); return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð¼Ð°Ð»Ñ‹: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${t.origin} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° ${s.verb} ${o}${t.minimum.toString()} ${u}` } return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð¼Ð°Ð»Ñ‹: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${t.origin} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° Ð±Ñ‹Ñ†ÑŒ ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð¿Ð°Ñ‡Ñ‹Ð½Ð°Ñ†Ñ†Ð° Ð· "${o.prefix}"` : o.format === "ends_with" ? `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð·Ð°ÐºÐ°Ð½Ñ‡Ð²Ð°Ñ†Ñ†Ð° Ð½Ð° "${o.suffix}"` : o.format === "includes" ? `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð·Ð¼ÑÑˆÑ‡Ð°Ñ†ÑŒ "${o.includes}"` : o.format === "regex" ? `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð°Ð´Ð¿Ð°Ð²ÑÐ´Ð°Ñ†ÑŒ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${o.pattern}` : `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ${i[o.format] ?? t.format}` } case "not_multiple_of": return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ð»Ñ–Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð±Ñ‹Ñ†ÑŒ ÐºÑ€Ð°Ñ‚Ð½Ñ‹Ð¼ ${t.divisor}`; case "unrecognized_keys": return `ÐÐµÑ€Ð°ÑÐ¿Ð°Ð·Ð½Ð°Ð½Ñ‹ ${t.keys.length > 1 ? "ÐºÐ»ÑŽÑ‡Ñ‹" : "ÐºÐ»ÑŽÑ‡"}: ${$(t.keys, ", ")}`; case "invalid_key": return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÐºÐ»ÑŽÑ‡ Ñƒ ${t.origin}`; case "invalid_union": return "ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´"; case "invalid_element": return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ð°Ðµ Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ Ñž ${t.origin}`; default: return "ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´" } } }, "error$H"); function bf() { return { localeError: _f() } } a(bf, "be"); const yf = a(e => { const n = typeof e; switch (n) { case "number": return Number.isNaN(e) ? "NaN" : "Ñ‡Ð¸ÑÐ»Ð¾"; case "object": { if (Array.isArray(e)) return "Ð¼Ð°ÑÐ¸Ð²"; if (e === null) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name } }return n }, "parsedType$6"), $f = a(() => { const e = { string: { unit: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°", verb: "Ð´Ð° ÑÑŠÐ´ÑŠÑ€Ð¶Ð°" }, file: { unit: "Ð±Ð°Ð¹Ñ‚Ð°", verb: "Ð´Ð° ÑÑŠÐ´ÑŠÑ€Ð¶Ð°" }, array: { unit: "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°", verb: "Ð´Ð° ÑÑŠÐ´ÑŠÑ€Ð¶Ð°" }, set: { unit: "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°", verb: "Ð´Ð° ÑÑŠÐ´ÑŠÑ€Ð¶Ð°" } }; function n(i) { return e[i] ?? null } a(n, "getSizing"); const r = { regex: "Ð²Ñ…Ð¾Ð´", email: "Ð¸Ð¼ÐµÐ¹Ð» Ð°Ð´Ñ€ÐµÑ", url: "URL", emoji: "ÐµÐ¼Ð¾Ð´Ð¶Ð¸", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO Ð²Ñ€ÐµÐ¼Ðµ", date: "ISO Ð´Ð°Ñ‚Ð°", time: "ISO Ð²Ñ€ÐµÐ¼Ðµ", duration: "ISO Ð¿Ñ€Ð¾Ð´ÑŠÐ»Ð¶Ð¸Ñ‚ÐµÐ»Ð½Ð¾ÑÑ‚", ipv4: "IPv4 Ð°Ð´Ñ€ÐµÑ", ipv6: "IPv6 Ð°Ð´Ñ€ÐµÑ", cidrv4: "IPv4 Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½", cidrv6: "IPv6 Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½", base64: "base64-ÐºÐ¾Ð´Ð¸Ñ€Ð°Ð½ Ð½Ð¸Ð·", base64url: "base64url-ÐºÐ¾Ð´Ð¸Ñ€Ð°Ð½ Ð½Ð¸Ð·", json_string: "JSON Ð½Ð¸Ð·", e164: "E.164 Ð½Ð¾Ð¼ÐµÑ€", jwt: "JWT", template_literal: "Ð²Ñ…Ð¾Ð´" }; return i => { switch (i.code) { case "invalid_type": return `ÐÐµÐ²Ð°Ð»Ð¸Ð´ÐµÐ½ Ð²Ñ…Ð¾Ð´: Ð¾Ñ‡Ð°ÐºÐ²Ð°Ð½ ${i.expected}, Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½ ${yf(i.input)}`; case "invalid_value": return i.values.length === 1 ? `ÐÐµÐ²Ð°Ð»Ð¸Ð´ÐµÐ½ Ð²Ñ…Ð¾Ð´: Ð¾Ñ‡Ð°ÐºÐ²Ð°Ð½ ${P(i.values[0])}` : `ÐÐµÐ²Ð°Ð»Ð¸Ð´Ð½Ð° Ð¾Ð¿Ñ†Ð¸Ñ: Ð¾Ñ‡Ð°ÐºÐ²Ð°Ð½Ð¾ ÐµÐ´Ð½Ð¾ Ð¾Ñ‚ ${$(i.values, "|")}`; case "too_big": { const t = i.inclusive ? "<=" : "<", o = n(i.origin); return o ? `Ð¢Ð²ÑŠÑ€Ð´Ðµ Ð³Ð¾Ð»ÑÐ¼Ð¾: Ð¾Ñ‡Ð°ÐºÐ²Ð° ÑÐµ ${i.origin ?? "ÑÑ‚Ð¾Ð¹Ð½Ð¾ÑÑ‚"} Ð´Ð° ÑÑŠÐ´ÑŠÑ€Ð¶Ð° ${t}${i.maximum.toString()} ${o.unit ?? "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°"}` : `Ð¢Ð²ÑŠÑ€Ð´Ðµ Ð³Ð¾Ð»ÑÐ¼Ð¾: Ð¾Ñ‡Ð°ÐºÐ²Ð° ÑÐµ ${i.origin ?? "ÑÑ‚Ð¾Ð¹Ð½Ð¾ÑÑ‚"} Ð´Ð° Ð±ÑŠÐ´Ðµ ${t}${i.maximum.toString()}` } case "too_small": { const t = i.inclusive ? ">=" : ">", o = n(i.origin); return o ? `Ð¢Ð²ÑŠÑ€Ð´Ðµ Ð¼Ð°Ð»ÐºÐ¾: Ð¾Ñ‡Ð°ÐºÐ²Ð° ÑÐµ ${i.origin} Ð´Ð° ÑÑŠÐ´ÑŠÑ€Ð¶Ð° ${t}${i.minimum.toString()} ${o.unit}` : `Ð¢Ð²ÑŠÑ€Ð´Ðµ Ð¼Ð°Ð»ÐºÐ¾: Ð¾Ñ‡Ð°ÐºÐ²Ð° ÑÐµ ${i.origin} Ð´Ð° Ð±ÑŠÐ´Ðµ ${t}${i.minimum.toString()}` } case "invalid_format": { const t = i; if (t.format === "starts_with") return `ÐÐµÐ²Ð°Ð»Ð¸Ð´ÐµÐ½ Ð½Ð¸Ð·: Ñ‚Ñ€ÑÐ±Ð²Ð° Ð´Ð° Ð·Ð°Ð¿Ð¾Ñ‡Ð²Ð° Ñ "${t.prefix}"`; if (t.format === "ends_with") return `ÐÐµÐ²Ð°Ð»Ð¸Ð´ÐµÐ½ Ð½Ð¸Ð·: Ñ‚Ñ€ÑÐ±Ð²Ð° Ð´Ð° Ð·Ð°Ð²ÑŠÑ€ÑˆÐ²Ð° Ñ "${t.suffix}"`; if (t.format === "includes") return `ÐÐµÐ²Ð°Ð»Ð¸Ð´ÐµÐ½ Ð½Ð¸Ð·: Ñ‚Ñ€ÑÐ±Ð²Ð° Ð´Ð° Ð²ÐºÐ»ÑŽÑ‡Ð²Ð° "${t.includes}"`; if (t.format === "regex") return `ÐÐµÐ²Ð°Ð»Ð¸Ð´ÐµÐ½ Ð½Ð¸Ð·: Ñ‚Ñ€ÑÐ±Ð²Ð° Ð´Ð° ÑÑŠÐ²Ð¿Ð°Ð´Ð° Ñ ${t.pattern}`; let o = "ÐÐµÐ²Ð°Ð»Ð¸Ð´ÐµÐ½"; return t.format === "emoji" && (o = "ÐÐµÐ²Ð°Ð»Ð¸Ð´Ð½Ð¾"), t.format === "datetime" && (o = "ÐÐµÐ²Ð°Ð»Ð¸Ð´Ð½Ð¾"), t.format === "date" && (o = "ÐÐµÐ²Ð°Ð»Ð¸Ð´Ð½Ð°"), t.format === "time" && (o = "ÐÐµÐ²Ð°Ð»Ð¸Ð´Ð½Ð¾"), t.format === "duration" && (o = "ÐÐµÐ²Ð°Ð»Ð¸Ð´Ð½Ð°"), `${o} ${r[t.format] ?? i.format}` } case "not_multiple_of": return `ÐÐµÐ²Ð°Ð»Ð¸Ð´Ð½Ð¾ Ñ‡Ð¸ÑÐ»Ð¾: Ñ‚Ñ€ÑÐ±Ð²Ð° Ð´Ð° Ð±ÑŠÐ´Ðµ ÐºÑ€Ð°Ñ‚Ð½Ð¾ Ð½Ð° ${i.divisor}`; case "unrecognized_keys": return `ÐÐµÑ€Ð°Ð·Ð¿Ð¾Ð·Ð½Ð°Ñ‚${i.keys.length > 1 ? "Ð¸" : ""} ÐºÐ»ÑŽÑ‡${i.keys.length > 1 ? "Ð¾Ð²Ðµ" : ""}: ${$(i.keys, ", ")}`; case "invalid_key": return `ÐÐµÐ²Ð°Ð»Ð¸Ð´ÐµÐ½ ÐºÐ»ÑŽÑ‡ Ð² ${i.origin}`; case "invalid_union": return "ÐÐµÐ²Ð°Ð»Ð¸Ð´ÐµÐ½ Ð²Ñ…Ð¾Ð´"; case "invalid_element": return `ÐÐµÐ²Ð°Ð»Ð¸Ð´Ð½Ð° ÑÑ‚Ð¾Ð¹Ð½Ð¾ÑÑ‚ Ð² ${i.origin}`; default: return "ÐÐµÐ²Ð°Ð»Ð¸Ð´ÐµÐ½ Ð²Ñ…Ð¾Ð´" } } }, "error$G"); function wf() { return { localeError: $f() } } a(wf, "bg"); const kf = a(() => { const e = { string: { unit: "carÃ cters", verb: "contenir" }, file: { unit: "bytes", verb: "contenir" }, array: { unit: "elements", verb: "contenir" }, set: { unit: "elements", verb: "contenir" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "entrada", email: "adreÃ§a electrÃ²nica", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i hora ISO", date: "data ISO", time: "hora ISO", duration: "durada ISO", ipv4: "adreÃ§a IPv4", ipv6: "adreÃ§a IPv6", cidrv4: "rang IPv4", cidrv6: "rang IPv6", base64: "cadena codificada en base64", base64url: "cadena codificada en base64url", json_string: "cadena JSON", e164: "nÃºmero E.164", jwt: "JWT", template_literal: "entrada" }; return t => { switch (t.code) { case "invalid_type": return `Tipus invÃ lid: s'esperava ${t.expected}, s'ha rebut ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Valor invÃ lid: s'esperava ${P(t.values[0])}` : `OpciÃ³ invÃ lida: s'esperava una de ${$(t.values, " o ")}`; case "too_big": { const o = t.inclusive ? "com a mÃ xim" : "menys de", s = n(t.origin); return s ? `Massa gran: s'esperava que ${t.origin ?? "el valor"} continguÃ©s ${o} ${t.maximum.toString()} ${s.unit ?? "elements"}` : `Massa gran: s'esperava que ${t.origin ?? "el valor"} fos ${o} ${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? "com a mÃ­nim" : "mÃ©s de", s = n(t.origin); return s ? `Massa petit: s'esperava que ${t.origin} continguÃ©s ${o} ${t.minimum.toString()} ${s.unit}` : `Massa petit: s'esperava que ${t.origin} fos ${o} ${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Format invÃ lid: ha de comenÃ§ar amb "${o.prefix}"` : o.format === "ends_with" ? `Format invÃ lid: ha d'acabar amb "${o.suffix}"` : o.format === "includes" ? `Format invÃ lid: ha d'incloure "${o.includes}"` : o.format === "regex" ? `Format invÃ lid: ha de coincidir amb el patrÃ³ ${o.pattern}` : `Format invÃ lid per a ${i[o.format] ?? t.format}` } case "not_multiple_of": return `NÃºmero invÃ lid: ha de ser mÃºltiple de ${t.divisor}`; case "unrecognized_keys": return `Clau${t.keys.length > 1 ? "s" : ""} no reconeguda${t.keys.length > 1 ? "s" : ""}: ${$(t.keys, ", ")}`; case "invalid_key": return `Clau invÃ lida a ${t.origin}`; case "invalid_union": return "Entrada invÃ lida"; case "invalid_element": return `Element invÃ lid a ${t.origin}`; default: return "Entrada invÃ lida" } } }, "error$F"); function xf() { return { localeError: kf() } } a(xf, "ca"); const If = a(() => { const e = { string: { unit: "znakÅ¯", verb: "mÃ­t" }, file: { unit: "bajtÅ¯", verb: "mÃ­t" }, array: { unit: "prvkÅ¯", verb: "mÃ­t" }, set: { unit: "prvkÅ¯", verb: "mÃ­t" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "ÄÃ­slo"; case "string": return "Å™etÄ›zec"; case "boolean": return "boolean"; case "bigint": return "bigint"; case "function": return "funkce"; case "symbol": return "symbol"; case "undefined": return "undefined"; case "object": { if (Array.isArray(t)) return "pole"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "regulÃ¡rnÃ­ vÃ½raz", email: "e-mailovÃ¡ adresa", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "datum a Äas ve formÃ¡tu ISO", date: "datum ve formÃ¡tu ISO", time: "Äas ve formÃ¡tu ISO", duration: "doba trvÃ¡nÃ­ ISO", ipv4: "IPv4 adresa", ipv6: "IPv6 adresa", cidrv4: "rozsah IPv4", cidrv6: "rozsah IPv6", base64: "Å™etÄ›zec zakÃ³dovanÃ½ ve formÃ¡tu base64", base64url: "Å™etÄ›zec zakÃ³dovanÃ½ ve formÃ¡tu base64url", json_string: "Å™etÄ›zec ve formÃ¡tu JSON", e164: "ÄÃ­slo E.164", jwt: "JWT", template_literal: "vstup" }; return t => { switch (t.code) { case "invalid_type": return `NeplatnÃ½ vstup: oÄekÃ¡vÃ¡no ${t.expected}, obdrÅ¾eno ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `NeplatnÃ½ vstup: oÄekÃ¡vÃ¡no ${P(t.values[0])}` : `NeplatnÃ¡ moÅ¾nost: oÄekÃ¡vÃ¡na jedna z hodnot ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Hodnota je pÅ™Ã­liÅ¡ velkÃ¡: ${t.origin ?? "hodnota"} musÃ­ mÃ­t ${o}${t.maximum.toString()} ${s.unit ?? "prvkÅ¯"}` : `Hodnota je pÅ™Ã­liÅ¡ velkÃ¡: ${t.origin ?? "hodnota"} musÃ­ bÃ½t ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Hodnota je pÅ™Ã­liÅ¡ malÃ¡: ${t.origin ?? "hodnota"} musÃ­ mÃ­t ${o}${t.minimum.toString()} ${s.unit ?? "prvkÅ¯"}` : `Hodnota je pÅ™Ã­liÅ¡ malÃ¡: ${t.origin ?? "hodnota"} musÃ­ bÃ½t ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `NeplatnÃ½ Å™etÄ›zec: musÃ­ zaÄÃ­nat na "${o.prefix}"` : o.format === "ends_with" ? `NeplatnÃ½ Å™etÄ›zec: musÃ­ konÄit na "${o.suffix}"` : o.format === "includes" ? `NeplatnÃ½ Å™etÄ›zec: musÃ­ obsahovat "${o.includes}"` : o.format === "regex" ? `NeplatnÃ½ Å™etÄ›zec: musÃ­ odpovÃ­dat vzoru ${o.pattern}` : `NeplatnÃ½ formÃ¡t ${i[o.format] ?? t.format}` } case "not_multiple_of": return `NeplatnÃ© ÄÃ­slo: musÃ­ bÃ½t nÃ¡sobkem ${t.divisor}`; case "unrecognized_keys": return `NeznÃ¡mÃ© klÃ­Äe: ${$(t.keys, ", ")}`; case "invalid_key": return `NeplatnÃ½ klÃ­Ä v ${t.origin}`; case "invalid_union": return "NeplatnÃ½ vstup"; case "invalid_element": return `NeplatnÃ¡ hodnota v ${t.origin}`; default: return "NeplatnÃ½ vstup" } } }, "error$E"); function Sf() { return { localeError: If() } } a(Sf, "cs"); const jf = a(() => { const e = { string: { unit: "tegn", verb: "havde" }, file: { unit: "bytes", verb: "havde" }, array: { unit: "elementer", verb: "indeholdt" }, set: { unit: "elementer", verb: "indeholdt" } }, n = { string: "streng", number: "tal", boolean: "boolean", array: "liste", object: "objekt", set: "sÃ¦t", file: "fil" }; function r(s) { return e[s] ?? null } a(r, "getSizing"); function i(s) { return n[s] ?? s } a(i, "getTypeName"); const t = a(s => { const c = typeof s; switch (c) { case "number": return Number.isNaN(s) ? "NaN" : "tal"; case "object": return Array.isArray(s) ? "liste" : s === null ? "null" : Object.getPrototypeOf(s) !== Object.prototype && s.constructor ? s.constructor.name : "objekt" }return c }, "parsedType"), o = { regex: "input", email: "e-mailadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslÃ¦t", date: "ISO-dato", time: "ISO-klokkeslÃ¦t", duration: "ISO-varighed", ipv4: "IPv4-omrÃ¥de", ipv6: "IPv6-omrÃ¥de", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodet streng", base64url: "base64url-kodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }; return s => { switch (s.code) { case "invalid_type": return `Ugyldigt input: forventede ${i(s.expected)}, fik ${i(t(s.input))}`; case "invalid_value": return s.values.length === 1 ? `Ugyldig vÃ¦rdi: forventede ${P(s.values[0])}` : `Ugyldigt valg: forventede en af fÃ¸lgende ${$(s.values, "|")}`; case "too_big": { const c = s.inclusive ? "<=" : "<", u = r(s.origin), p = i(s.origin); return u ? `For stor: forventede ${p ?? "value"} ${u.verb} ${c} ${s.maximum.toString()} ${u.unit ?? "elementer"}` : `For stor: forventede ${p ?? "value"} havde ${c} ${s.maximum.toString()}` } case "too_small": { const c = s.inclusive ? ">=" : ">", u = r(s.origin), p = i(s.origin); return u ? `For lille: forventede ${p} ${u.verb} ${c} ${s.minimum.toString()} ${u.unit}` : `For lille: forventede ${p} havde ${c} ${s.minimum.toString()}` } case "invalid_format": { const c = s; return c.format === "starts_with" ? `Ugyldig streng: skal starte med "${c.prefix}"` : c.format === "ends_with" ? `Ugyldig streng: skal ende med "${c.suffix}"` : c.format === "includes" ? `Ugyldig streng: skal indeholde "${c.includes}"` : c.format === "regex" ? `Ugyldig streng: skal matche mÃ¸nsteret ${c.pattern}` : `Ugyldig ${o[c.format] ?? s.format}` } case "not_multiple_of": return `Ugyldigt tal: skal vÃ¦re deleligt med ${s.divisor}`; case "unrecognized_keys": return `${s.keys.length > 1 ? "Ukendte nÃ¸gler" : "Ukendt nÃ¸gle"}: ${$(s.keys, ", ")}`; case "invalid_key": return `Ugyldig nÃ¸gle i ${s.origin}`; case "invalid_union": return "Ugyldigt input: matcher ingen af de tilladte typer"; case "invalid_element": return `Ugyldig vÃ¦rdi i ${s.origin}`; default: return "Ugyldigt input" } } }, "error$D"); function zf() { return { localeError: jf() } } a(zf, "da"); const Ef = a(() => { const e = { string: { unit: "Zeichen", verb: "zu haben" }, file: { unit: "Bytes", verb: "zu haben" }, array: { unit: "Elemente", verb: "zu haben" }, set: { unit: "Elemente", verb: "zu haben" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "Zahl"; case "object": { if (Array.isArray(t)) return "Array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "Eingabe", email: "E-Mail-Adresse", url: "URL", emoji: "Emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-Datum und -Uhrzeit", date: "ISO-Datum", time: "ISO-Uhrzeit", duration: "ISO-Dauer", ipv4: "IPv4-Adresse", ipv6: "IPv6-Adresse", cidrv4: "IPv4-Bereich", cidrv6: "IPv6-Bereich", base64: "Base64-codierter String", base64url: "Base64-URL-codierter String", json_string: "JSON-String", e164: "E.164-Nummer", jwt: "JWT", template_literal: "Eingabe" }; return t => { switch (t.code) { case "invalid_type": return `UngÃ¼ltige Eingabe: erwartet ${t.expected}, erhalten ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `UngÃ¼ltige Eingabe: erwartet ${P(t.values[0])}` : `UngÃ¼ltige Option: erwartet eine von ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Zu groÃŸ: erwartet, dass ${t.origin ?? "Wert"} ${o}${t.maximum.toString()} ${s.unit ?? "Elemente"} hat` : `Zu groÃŸ: erwartet, dass ${t.origin ?? "Wert"} ${o}${t.maximum.toString()} ist` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Zu klein: erwartet, dass ${t.origin} ${o}${t.minimum.toString()} ${s.unit} hat` : `Zu klein: erwartet, dass ${t.origin} ${o}${t.minimum.toString()} ist` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `UngÃ¼ltiger String: muss mit "${o.prefix}" beginnen` : o.format === "ends_with" ? `UngÃ¼ltiger String: muss mit "${o.suffix}" enden` : o.format === "includes" ? `UngÃ¼ltiger String: muss "${o.includes}" enthalten` : o.format === "regex" ? `UngÃ¼ltiger String: muss dem Muster ${o.pattern} entsprechen` : `UngÃ¼ltig: ${i[o.format] ?? t.format}` } case "not_multiple_of": return `UngÃ¼ltige Zahl: muss ein Vielfaches von ${t.divisor} sein`; case "unrecognized_keys": return `${t.keys.length > 1 ? "Unbekannte SchlÃ¼ssel" : "Unbekannter SchlÃ¼ssel"}: ${$(t.keys, ", ")}`; case "invalid_key": return `UngÃ¼ltiger SchlÃ¼ssel in ${t.origin}`; case "invalid_union": return "UngÃ¼ltige Eingabe"; case "invalid_element": return `UngÃ¼ltiger Wert in ${t.origin}`; default: return "UngÃ¼ltige Eingabe" } } }, "error$C"); function Of() { return { localeError: Ef() } } a(Of, "de"); const Nf = a(e => { const n = typeof e; switch (n) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": { if (Array.isArray(e)) return "array"; if (e === null) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name } }return n }, "parsedType$5"), Tf = a(() => { const e = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" } }; function n(i) { return e[i] ?? null } a(n, "getSizing"); const r = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }; return i => { switch (i.code) { case "invalid_type": return `Invalid input: expected ${i.expected}, received ${Nf(i.input)}`; case "invalid_value": return i.values.length === 1 ? `Invalid input: expected ${P(i.values[0])}` : `Invalid option: expected one of ${$(i.values, "|")}`; case "too_big": { const t = i.inclusive ? "<=" : "<", o = n(i.origin); return o ? `Too big: expected ${i.origin ?? "value"} to have ${t}${i.maximum.toString()} ${o.unit ?? "elements"}` : `Too big: expected ${i.origin ?? "value"} to be ${t}${i.maximum.toString()}` } case "too_small": { const t = i.inclusive ? ">=" : ">", o = n(i.origin); return o ? `Too small: expected ${i.origin} to have ${t}${i.minimum.toString()} ${o.unit}` : `Too small: expected ${i.origin} to be ${t}${i.minimum.toString()}` } case "invalid_format": { const t = i; return t.format === "starts_with" ? `Invalid string: must start with "${t.prefix}"` : t.format === "ends_with" ? `Invalid string: must end with "${t.suffix}"` : t.format === "includes" ? `Invalid string: must include "${t.includes}"` : t.format === "regex" ? `Invalid string: must match pattern ${t.pattern}` : `Invalid ${r[t.format] ?? i.format}` } case "not_multiple_of": return `Invalid number: must be a multiple of ${i.divisor}`; case "unrecognized_keys": return `Unrecognized key${i.keys.length > 1 ? "s" : ""}: ${$(i.keys, ", ")}`; case "invalid_key": return `Invalid key in ${i.origin}`; case "invalid_union": return "Invalid input"; case "invalid_element": return `Invalid value in ${i.origin}`; default: return "Invalid input" } } }, "error$B"); function Ac() { return { localeError: Tf() } } a(Ac, "en"); const Uf = a(e => { const n = typeof e; switch (n) { case "number": return Number.isNaN(e) ? "NaN" : "nombro"; case "object": { if (Array.isArray(e)) return "tabelo"; if (e === null) return "senvalora"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name } }return n }, "parsedType$4"), Af = a(() => { const e = { string: { unit: "karaktrojn", verb: "havi" }, file: { unit: "bajtojn", verb: "havi" }, array: { unit: "elementojn", verb: "havi" }, set: { unit: "elementojn", verb: "havi" } }; function n(i) { return e[i] ?? null } a(n, "getSizing"); const r = { regex: "enigo", email: "retadreso", url: "URL", emoji: "emoÄio", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datotempo", date: "ISO-dato", time: "ISO-tempo", duration: "ISO-daÅ­ro", ipv4: "IPv4-adreso", ipv6: "IPv6-adreso", cidrv4: "IPv4-rango", cidrv6: "IPv6-rango", base64: "64-ume kodita karaktraro", base64url: "URL-64-ume kodita karaktraro", json_string: "JSON-karaktraro", e164: "E.164-nombro", jwt: "JWT", template_literal: "enigo" }; return i => { switch (i.code) { case "invalid_type": return `Nevalida enigo: atendiÄis ${i.expected}, riceviÄis ${Uf(i.input)}`; case "invalid_value": return i.values.length === 1 ? `Nevalida enigo: atendiÄis ${P(i.values[0])}` : `Nevalida opcio: atendiÄis unu el ${$(i.values, "|")}`; case "too_big": { const t = i.inclusive ? "<=" : "<", o = n(i.origin); return o ? `Tro granda: atendiÄis ke ${i.origin ?? "valoro"} havu ${t}${i.maximum.toString()} ${o.unit ?? "elementojn"}` : `Tro granda: atendiÄis ke ${i.origin ?? "valoro"} havu ${t}${i.maximum.toString()}` } case "too_small": { const t = i.inclusive ? ">=" : ">", o = n(i.origin); return o ? `Tro malgranda: atendiÄis ke ${i.origin} havu ${t}${i.minimum.toString()} ${o.unit}` : `Tro malgranda: atendiÄis ke ${i.origin} estu ${t}${i.minimum.toString()}` } case "invalid_format": { const t = i; return t.format === "starts_with" ? `Nevalida karaktraro: devas komenciÄi per "${t.prefix}"` : t.format === "ends_with" ? `Nevalida karaktraro: devas finiÄi per "${t.suffix}"` : t.format === "includes" ? `Nevalida karaktraro: devas inkluzivi "${t.includes}"` : t.format === "regex" ? `Nevalida karaktraro: devas kongrui kun la modelo ${t.pattern}` : `Nevalida ${r[t.format] ?? i.format}` } case "not_multiple_of": return `Nevalida nombro: devas esti oblo de ${i.divisor}`; case "unrecognized_keys": return `Nekonata${i.keys.length > 1 ? "j" : ""} Ålosilo${i.keys.length > 1 ? "j" : ""}: ${$(i.keys, ", ")}`; case "invalid_key": return `Nevalida Ålosilo en ${i.origin}`; case "invalid_union": return "Nevalida enigo"; case "invalid_element": return `Nevalida valoro en ${i.origin}`; default: return "Nevalida enigo" } } }, "error$A"); function Pf() { return { localeError: Af() } } a(Pf, "eo"); const Df = a(() => { const e = { string: { unit: "caracteres", verb: "tener" }, file: { unit: "bytes", verb: "tener" }, array: { unit: "elementos", verb: "tener" }, set: { unit: "elementos", verb: "tener" } }, n = { string: "texto", number: "nÃºmero", boolean: "booleano", array: "arreglo", object: "objeto", set: "conjunto", file: "archivo", date: "fecha", bigint: "nÃºmero grande", symbol: "sÃ­mbolo", undefined: "indefinido", null: "nulo", function: "funciÃ³n", map: "mapa", record: "registro", tuple: "tupla", enum: "enumeraciÃ³n", union: "uniÃ³n", literal: "literal", promise: "promesa", void: "vacÃ­o", never: "nunca", unknown: "desconocido", any: "cualquiera" }; function r(s) { return e[s] ?? null } a(r, "getSizing"); function i(s) { return n[s] ?? s } a(i, "getTypeName"); const t = a(s => { const c = typeof s; switch (c) { case "number": return Number.isNaN(s) ? "NaN" : "number"; case "object": return Array.isArray(s) ? "array" : s === null ? "null" : Object.getPrototypeOf(s) !== Object.prototype ? s.constructor.name : "object" }return c }, "parsedType"), o = { regex: "entrada", email: "direcciÃ³n de correo electrÃ³nico", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "fecha y hora ISO", date: "fecha ISO", time: "hora ISO", duration: "duraciÃ³n ISO", ipv4: "direcciÃ³n IPv4", ipv6: "direcciÃ³n IPv6", cidrv4: "rango IPv4", cidrv6: "rango IPv6", base64: "cadena codificada en base64", base64url: "URL codificada en base64", json_string: "cadena JSON", e164: "nÃºmero E.164", jwt: "JWT", template_literal: "entrada" }; return s => { switch (s.code) { case "invalid_type": return `Entrada invÃ¡lida: se esperaba ${i(s.expected)}, recibido ${i(t(s.input))}`; case "invalid_value": return s.values.length === 1 ? `Entrada invÃ¡lida: se esperaba ${P(s.values[0])}` : `OpciÃ³n invÃ¡lida: se esperaba una de ${$(s.values, "|")}`; case "too_big": { const c = s.inclusive ? "<=" : "<", u = r(s.origin), p = i(s.origin); return u ? `Demasiado grande: se esperaba que ${p ?? "valor"} tuviera ${c}${s.maximum.toString()} ${u.unit ?? "elementos"}` : `Demasiado grande: se esperaba que ${p ?? "valor"} fuera ${c}${s.maximum.toString()}` } case "too_small": { const c = s.inclusive ? ">=" : ">", u = r(s.origin), p = i(s.origin); return u ? `Demasiado pequeÃ±o: se esperaba que ${p} tuviera ${c}${s.minimum.toString()} ${u.unit}` : `Demasiado pequeÃ±o: se esperaba que ${p} fuera ${c}${s.minimum.toString()}` } case "invalid_format": { const c = s; return c.format === "starts_with" ? `Cadena invÃ¡lida: debe comenzar con "${c.prefix}"` : c.format === "ends_with" ? `Cadena invÃ¡lida: debe terminar en "${c.suffix}"` : c.format === "includes" ? `Cadena invÃ¡lida: debe incluir "${c.includes}"` : c.format === "regex" ? `Cadena invÃ¡lida: debe coincidir con el patrÃ³n ${c.pattern}` : `InvÃ¡lido ${o[c.format] ?? s.format}` } case "not_multiple_of": return `NÃºmero invÃ¡lido: debe ser mÃºltiplo de ${s.divisor}`; case "unrecognized_keys": return `Llave${s.keys.length > 1 ? "s" : ""} desconocida${s.keys.length > 1 ? "s" : ""}: ${$(s.keys, ", ")}`; case "invalid_key": return `Llave invÃ¡lida en ${i(s.origin)}`; case "invalid_union": return "Entrada invÃ¡lida"; case "invalid_element": return `Valor invÃ¡lido en ${i(s.origin)}`; default: return "Entrada invÃ¡lida" } } }, "error$z"); function Lf() { return { localeError: Df() } } a(Lf, "es"); const Rf = a(() => { const e = { string: { unit: "Ú©Ø§Ø±Ø§Ú©ØªØ±", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" }, file: { unit: "Ø¨Ø§ÛŒØª", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" }, array: { unit: "Ø¢ÛŒØªÙ…", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" }, set: { unit: "Ø¢ÛŒØªÙ…", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "Ø¹Ø¯Ø¯"; case "object": { if (Array.isArray(t)) return "Ø¢Ø±Ø§ÛŒÙ‡"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "ÙˆØ±ÙˆØ¯ÛŒ", email: "Ø¢Ø¯Ø±Ø³ Ø§ÛŒÙ…ÛŒÙ„", url: "URL", emoji: "Ø§ÛŒÙ…ÙˆØ¬ÛŒ", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ØªØ§Ø±ÛŒØ® Ùˆ Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ", date: "ØªØ§Ø±ÛŒØ® Ø§ÛŒØ²Ùˆ", time: "Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ", duration: "Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ", ipv4: "IPv4 Ø¢Ø¯Ø±Ø³", ipv6: "IPv6 Ø¢Ø¯Ø±Ø³", cidrv4: "IPv4 Ø¯Ø§Ù…Ù†Ù‡", cidrv6: "IPv6 Ø¯Ø§Ù…Ù†Ù‡", base64: "base64-encoded Ø±Ø´ØªÙ‡", base64url: "base64url-encoded Ø±Ø´ØªÙ‡", json_string: "JSON Ø±Ø´ØªÙ‡", e164: "E.164 Ø¹Ø¯Ø¯", jwt: "JWT", template_literal: "ÙˆØ±ÙˆØ¯ÛŒ" }; return t => { switch (t.code) { case "invalid_type": return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ${t.expected} Ù…ÛŒâ€ŒØ¨ÙˆØ¯ØŒ ${r(t.input)} Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯`; case "invalid_value": return t.values.length === 1 ? `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ${P(t.values[0])} Ù…ÛŒâ€ŒØ¨ÙˆØ¯` : `Ú¯Ø²ÛŒÙ†Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ÛŒÚ©ÛŒ Ø§Ø² ${$(t.values, "|")} Ù…ÛŒâ€ŒØ¨ÙˆØ¯`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Ø®ÛŒÙ„ÛŒ Ø¨Ø²Ø±Ú¯: ${t.origin ?? "Ù…Ù‚Ø¯Ø§Ø±"} Ø¨Ø§ÛŒØ¯ ${o}${t.maximum.toString()} ${s.unit ?? "Ø¹Ù†ØµØ±"} Ø¨Ø§Ø´Ø¯` : `Ø®ÛŒÙ„ÛŒ Ø¨Ø²Ø±Ú¯: ${t.origin ?? "Ù…Ù‚Ø¯Ø§Ø±"} Ø¨Ø§ÛŒØ¯ ${o}${t.maximum.toString()} Ø¨Ø§Ø´Ø¯` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Ø®ÛŒÙ„ÛŒ Ú©ÙˆÚ†Ú©: ${t.origin} Ø¨Ø§ÛŒØ¯ ${o}${t.minimum.toString()} ${s.unit} Ø¨Ø§Ø´Ø¯` : `Ø®ÛŒÙ„ÛŒ Ú©ÙˆÚ†Ú©: ${t.origin} Ø¨Ø§ÛŒØ¯ ${o}${t.minimum.toString()} Ø¨Ø§Ø´Ø¯` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ "${o.prefix}" Ø´Ø±ÙˆØ¹ Ø´ÙˆØ¯` : o.format === "ends_with" ? `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ "${o.suffix}" ØªÙ…Ø§Ù… Ø´ÙˆØ¯` : o.format === "includes" ? `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø´Ø§Ù…Ù„ "${o.includes}" Ø¨Ø§Ø´Ø¯` : o.format === "regex" ? `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ Ø§Ù„Ú¯ÙˆÛŒ ${o.pattern} Ù…Ø·Ø§Ø¨Ù‚Øª Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯` : `${i[o.format] ?? t.format} Ù†Ø§Ù…Ø¹ØªØ¨Ø±` } case "not_multiple_of": return `Ø¹Ø¯Ø¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ù…Ø¶Ø±Ø¨ ${t.divisor} Ø¨Ø§Ø´Ø¯`; case "unrecognized_keys": return `Ú©Ù„ÛŒØ¯${t.keys.length > 1 ? "Ù‡Ø§ÛŒ" : ""} Ù†Ø§Ø´Ù†Ø§Ø³: ${$(t.keys, ", ")}`; case "invalid_key": return `Ú©Ù„ÛŒØ¯ Ù†Ø§Ø´Ù†Ø§Ø³ Ø¯Ø± ${t.origin}`; case "invalid_union": return "ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±"; case "invalid_element": return `Ù…Ù‚Ø¯Ø§Ø± Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø¯Ø± ${t.origin}`; default: return "ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±" } } }, "error$y"); function Cf() { return { localeError: Rf() } } a(Cf, "fa"); const Zf = a(() => { const e = { string: { unit: "merkkiÃ¤", subject: "merkkijonon" }, file: { unit: "tavua", subject: "tiedoston" }, array: { unit: "alkiota", subject: "listan" }, set: { unit: "alkiota", subject: "joukon" }, number: { unit: "", subject: "luvun" }, bigint: { unit: "", subject: "suuren kokonaisluvun" }, int: { unit: "", subject: "kokonaisluvun" }, date: { unit: "", subject: "pÃ¤ivÃ¤mÃ¤Ã¤rÃ¤n" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "sÃ¤Ã¤nnÃ¶llinen lauseke", email: "sÃ¤hkÃ¶postiosoite", url: "URL-osoite", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-aikaleima", date: "ISO-pÃ¤ivÃ¤mÃ¤Ã¤rÃ¤", time: "ISO-aika", duration: "ISO-kesto", ipv4: "IPv4-osoite", ipv6: "IPv6-osoite", cidrv4: "IPv4-alue", cidrv6: "IPv6-alue", base64: "base64-koodattu merkkijono", base64url: "base64url-koodattu merkkijono", json_string: "JSON-merkkijono", e164: "E.164-luku", jwt: "JWT", template_literal: "templaattimerkkijono" }; return t => { switch (t.code) { case "invalid_type": return `Virheellinen tyyppi: odotettiin ${t.expected}, oli ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Virheellinen syÃ¶te: tÃ¤ytyy olla ${P(t.values[0])}` : `Virheellinen valinta: tÃ¤ytyy olla yksi seuraavista: ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Liian suuri: ${s.subject} tÃ¤ytyy olla ${o}${t.maximum.toString()} ${s.unit}`.trim() : `Liian suuri: arvon tÃ¤ytyy olla ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Liian pieni: ${s.subject} tÃ¤ytyy olla ${o}${t.minimum.toString()} ${s.unit}`.trim() : `Liian pieni: arvon tÃ¤ytyy olla ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Virheellinen syÃ¶te: tÃ¤ytyy alkaa "${o.prefix}"` : o.format === "ends_with" ? `Virheellinen syÃ¶te: tÃ¤ytyy loppua "${o.suffix}"` : o.format === "includes" ? `Virheellinen syÃ¶te: tÃ¤ytyy sisÃ¤ltÃ¤Ã¤ "${o.includes}"` : o.format === "regex" ? `Virheellinen syÃ¶te: tÃ¤ytyy vastata sÃ¤Ã¤nnÃ¶llistÃ¤ lauseketta ${o.pattern}` : `Virheellinen ${i[o.format] ?? t.format}` } case "not_multiple_of": return `Virheellinen luku: tÃ¤ytyy olla luvun ${t.divisor} monikerta`; case "unrecognized_keys": return `${t.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${$(t.keys, ", ")}`; case "invalid_key": return "Virheellinen avain tietueessa"; case "invalid_union": return "Virheellinen unioni"; case "invalid_element": return "Virheellinen arvo joukossa"; default: return "Virheellinen syÃ¶te" } } }, "error$x"); function Mf() { return { localeError: Zf() } } a(Mf, "fi"); const Ff = a(() => { const e = { string: { unit: "caractÃ¨res", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "Ã©lÃ©ments", verb: "avoir" }, set: { unit: "Ã©lÃ©ments", verb: "avoir" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "nombre"; case "object": { if (Array.isArray(t)) return "tableau"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "entrÃ©e", email: "adresse e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date et heure ISO", date: "date ISO", time: "heure ISO", duration: "durÃ©e ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chaÃ®ne encodÃ©e en base64", base64url: "chaÃ®ne encodÃ©e en base64url", json_string: "chaÃ®ne JSON", e164: "numÃ©ro E.164", jwt: "JWT", template_literal: "entrÃ©e" }; return t => { switch (t.code) { case "invalid_type": return `EntrÃ©e invalide : ${t.expected} attendu, ${r(t.input)} reÃ§u`; case "invalid_value": return t.values.length === 1 ? `EntrÃ©e invalide : ${P(t.values[0])} attendu` : `Option invalide : une valeur parmi ${$(t.values, "|")} attendue`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Trop grand : ${t.origin ?? "valeur"} doit ${s.verb} ${o}${t.maximum.toString()} ${s.unit ?? "Ã©lÃ©ment(s)"}` : `Trop grand : ${t.origin ?? "valeur"} doit Ãªtre ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Trop petit : ${t.origin} doit ${s.verb} ${o}${t.minimum.toString()} ${s.unit}` : `Trop petit : ${t.origin} doit Ãªtre ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `ChaÃ®ne invalide : doit commencer par "${o.prefix}"` : o.format === "ends_with" ? `ChaÃ®ne invalide : doit se terminer par "${o.suffix}"` : o.format === "includes" ? `ChaÃ®ne invalide : doit inclure "${o.includes}"` : o.format === "regex" ? `ChaÃ®ne invalide : doit correspondre au modÃ¨le ${o.pattern}` : `${i[o.format] ?? t.format} invalide` } case "not_multiple_of": return `Nombre invalide : doit Ãªtre un multiple de ${t.divisor}`; case "unrecognized_keys": return `ClÃ©${t.keys.length > 1 ? "s" : ""} non reconnue${t.keys.length > 1 ? "s" : ""} : ${$(t.keys, ", ")}`; case "invalid_key": return `ClÃ© invalide dans ${t.origin}`; case "invalid_union": return "EntrÃ©e invalide"; case "invalid_element": return `Valeur invalide dans ${t.origin}`; default: return "EntrÃ©e invalide" } } }, "error$w"); function Bf() { return { localeError: Ff() } } a(Bf, "fr"); const Wf = a(() => { const e = { string: { unit: "caractÃ¨res", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "Ã©lÃ©ments", verb: "avoir" }, set: { unit: "Ã©lÃ©ments", verb: "avoir" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "entrÃ©e", email: "adresse courriel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date-heure ISO", date: "date ISO", time: "heure ISO", duration: "durÃ©e ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chaÃ®ne encodÃ©e en base64", base64url: "chaÃ®ne encodÃ©e en base64url", json_string: "chaÃ®ne JSON", e164: "numÃ©ro E.164", jwt: "JWT", template_literal: "entrÃ©e" }; return t => { switch (t.code) { case "invalid_type": return `EntrÃ©e invalide : attendu ${t.expected}, reÃ§u ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `EntrÃ©e invalide : attendu ${P(t.values[0])}` : `Option invalide : attendu l'une des valeurs suivantes ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "â‰¤" : "<", s = n(t.origin); return s ? `Trop grand : attendu que ${t.origin ?? "la valeur"} ait ${o}${t.maximum.toString()} ${s.unit}` : `Trop grand : attendu que ${t.origin ?? "la valeur"} soit ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? "â‰¥" : ">", s = n(t.origin); return s ? `Trop petit : attendu que ${t.origin} ait ${o}${t.minimum.toString()} ${s.unit}` : `Trop petit : attendu que ${t.origin} soit ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `ChaÃ®ne invalide : doit commencer par "${o.prefix}"` : o.format === "ends_with" ? `ChaÃ®ne invalide : doit se terminer par "${o.suffix}"` : o.format === "includes" ? `ChaÃ®ne invalide : doit inclure "${o.includes}"` : o.format === "regex" ? `ChaÃ®ne invalide : doit correspondre au motif ${o.pattern}` : `${i[o.format] ?? t.format} invalide` } case "not_multiple_of": return `Nombre invalide : doit Ãªtre un multiple de ${t.divisor}`; case "unrecognized_keys": return `ClÃ©${t.keys.length > 1 ? "s" : ""} non reconnue${t.keys.length > 1 ? "s" : ""} : ${$(t.keys, ", ")}`; case "invalid_key": return `ClÃ© invalide dans ${t.origin}`; case "invalid_union": return "EntrÃ©e invalide"; case "invalid_element": return `Valeur invalide dans ${t.origin}`; default: return "EntrÃ©e invalide" } } }, "error$v"); function Gf() { return { localeError: Wf() } } a(Gf, "frCA"); const Vf = a(() => { const e = { string: { unit: "××•×ª×™×•×ª", verb: "×œ×›×œ×•×œ" }, file: { unit: "×‘×™×™×˜×™×", verb: "×œ×›×œ×•×œ" }, array: { unit: "×¤×¨×™×˜×™×", verb: "×œ×›×œ×•×œ" }, set: { unit: "×¤×¨×™×˜×™×", verb: "×œ×›×œ×•×œ" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "×§×œ×˜", email: "×›×ª×•×‘×ª ××™×ž×™×™×œ", url: "×›×ª×•×‘×ª ×¨×©×ª", emoji: "××™×ž×•×’'×™", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "×ª××¨×™×š ×•×–×ž×Ÿ ISO", date: "×ª××¨×™×š ISO", time: "×–×ž×Ÿ ISO", duration: "×ž×©×š ×–×ž×Ÿ ISO", ipv4: "×›×ª×•×‘×ª IPv4", ipv6: "×›×ª×•×‘×ª IPv6", cidrv4: "×˜×•×•×— IPv4", cidrv6: "×˜×•×•×— IPv6", base64: "×ž×—×¨×•×–×ª ×‘×‘×¡×™×¡ 64", base64url: "×ž×—×¨×•×–×ª ×‘×‘×¡×™×¡ 64 ×œ×›×ª×•×‘×•×ª ×¨×©×ª", json_string: "×ž×—×¨×•×–×ª JSON", e164: "×ž×¡×¤×¨ E.164", jwt: "JWT", template_literal: "×§×œ×˜" }; return t => { switch (t.code) { case "invalid_type": return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ${t.expected}, ×”×ª×§×‘×œ ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ${P(t.values[0])}` : `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ××—×ª ×ž×”××¤×©×¨×•×™×•×ª  ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `×’×“×•×œ ×ž×“×™: ${t.origin ?? "value"} ×¦×¨×™×š ×œ×”×™×•×ª ${o}${t.maximum.toString()} ${s.unit ?? "elements"}` : `×’×“×•×œ ×ž×“×™: ${t.origin ?? "value"} ×¦×¨×™×š ×œ×”×™×•×ª ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `×§×˜×Ÿ ×ž×“×™: ${t.origin} ×¦×¨×™×š ×œ×”×™×•×ª ${o}${t.minimum.toString()} ${s.unit}` : `×§×˜×Ÿ ×ž×“×™: ${t.origin} ×¦×¨×™×š ×œ×”×™×•×ª ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×ª×—×™×œ ×‘"${o.prefix}"` : o.format === "ends_with" ? `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×¡×ª×™×™× ×‘ "${o.suffix}"` : o.format === "includes" ? `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×›×œ×•×œ "${o.includes}"` : o.format === "regex" ? `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×ª××™× ×œ×ª×‘× ×™×ª ${o.pattern}` : `${i[o.format] ?? t.format} ×œ× ×ª×§×™×Ÿ` } case "not_multiple_of": return `×ž×¡×¤×¨ ×œ× ×ª×§×™×Ÿ: ×—×™×™×‘ ×œ×”×™×•×ª ×ž×›×¤×œ×” ×©×œ ${t.divisor}`; case "unrecognized_keys": return `×ž×¤×ª×—${t.keys.length > 1 ? "×•×ª" : ""} ×œ× ×ž×–×•×”${t.keys.length > 1 ? "×™×" : "×”"}: ${$(t.keys, ", ")}`; case "invalid_key": return `×ž×¤×ª×— ×œ× ×ª×§×™×Ÿ ×‘${t.origin}`; case "invalid_union": return "×§×œ×˜ ×œ× ×ª×§×™×Ÿ"; case "invalid_element": return `×¢×¨×š ×œ× ×ª×§×™×Ÿ ×‘${t.origin}`; default: return "×§×œ×˜ ×œ× ×ª×§×™×Ÿ" } } }, "error$u"); function Jf() { return { localeError: Vf() } } a(Jf, "he"); const Hf = a(() => { const e = { string: { unit: "karakter", verb: "legyen" }, file: { unit: "byte", verb: "legyen" }, array: { unit: "elem", verb: "legyen" }, set: { unit: "elem", verb: "legyen" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "szÃ¡m"; case "object": { if (Array.isArray(t)) return "tÃ¶mb"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "bemenet", email: "email cÃ­m", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO idÅ‘bÃ©lyeg", date: "ISO dÃ¡tum", time: "ISO idÅ‘", duration: "ISO idÅ‘intervallum", ipv4: "IPv4 cÃ­m", ipv6: "IPv6 cÃ­m", cidrv4: "IPv4 tartomÃ¡ny", cidrv6: "IPv6 tartomÃ¡ny", base64: "base64-kÃ³dolt string", base64url: "base64url-kÃ³dolt string", json_string: "JSON string", e164: "E.164 szÃ¡m", jwt: "JWT", template_literal: "bemenet" }; return t => { switch (t.code) { case "invalid_type": return `Ã‰rvÃ©nytelen bemenet: a vÃ¡rt Ã©rtÃ©k ${t.expected}, a kapott Ã©rtÃ©k ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Ã‰rvÃ©nytelen bemenet: a vÃ¡rt Ã©rtÃ©k ${P(t.values[0])}` : `Ã‰rvÃ©nytelen opciÃ³: valamelyik Ã©rtÃ©k vÃ¡rt ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `TÃºl nagy: ${t.origin ?? "Ã©rtÃ©k"} mÃ©rete tÃºl nagy ${o}${t.maximum.toString()} ${s.unit ?? "elem"}` : `TÃºl nagy: a bemeneti Ã©rtÃ©k ${t.origin ?? "Ã©rtÃ©k"} tÃºl nagy: ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `TÃºl kicsi: a bemeneti Ã©rtÃ©k ${t.origin} mÃ©rete tÃºl kicsi ${o}${t.minimum.toString()} ${s.unit}` : `TÃºl kicsi: a bemeneti Ã©rtÃ©k ${t.origin} tÃºl kicsi ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Ã‰rvÃ©nytelen string: "${o.prefix}" Ã©rtÃ©kkel kell kezdÅ‘dnie` : o.format === "ends_with" ? `Ã‰rvÃ©nytelen string: "${o.suffix}" Ã©rtÃ©kkel kell vÃ©gzÅ‘dnie` : o.format === "includes" ? `Ã‰rvÃ©nytelen string: "${o.includes}" Ã©rtÃ©ket kell tartalmaznia` : o.format === "regex" ? `Ã‰rvÃ©nytelen string: ${o.pattern} mintÃ¡nak kell megfelelnie` : `Ã‰rvÃ©nytelen ${i[o.format] ?? t.format}` } case "not_multiple_of": return `Ã‰rvÃ©nytelen szÃ¡m: ${t.divisor} tÃ¶bbszÃ¶rÃ¶sÃ©nek kell lennie`; case "unrecognized_keys": return `Ismeretlen kulcs${t.keys.length > 1 ? "s" : ""}: ${$(t.keys, ", ")}`; case "invalid_key": return `Ã‰rvÃ©nytelen kulcs ${t.origin}`; case "invalid_union": return "Ã‰rvÃ©nytelen bemenet"; case "invalid_element": return `Ã‰rvÃ©nytelen Ã©rtÃ©k: ${t.origin}`; default: return "Ã‰rvÃ©nytelen bemenet" } } }, "error$t"); function Kf() { return { localeError: Hf() } } a(Kf, "hu"); const qf = a(() => { const e = { string: { unit: "karakter", verb: "memiliki" }, file: { unit: "byte", verb: "memiliki" }, array: { unit: "item", verb: "memiliki" }, set: { unit: "item", verb: "memiliki" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "input", email: "alamat email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tanggal dan waktu format ISO", date: "tanggal format ISO", time: "jam format ISO", duration: "durasi format ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "rentang alamat IPv4", cidrv6: "rentang alamat IPv6", base64: "string dengan enkode base64", base64url: "string dengan enkode base64url", json_string: "string JSON", e164: "angka E.164", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `Input tidak valid: diharapkan ${t.expected}, diterima ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Input tidak valid: diharapkan ${P(t.values[0])}` : `Pilihan tidak valid: diharapkan salah satu dari ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Terlalu besar: diharapkan ${t.origin ?? "value"} memiliki ${o}${t.maximum.toString()} ${s.unit ?? "elemen"}` : `Terlalu besar: diharapkan ${t.origin ?? "value"} menjadi ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Terlalu kecil: diharapkan ${t.origin} memiliki ${o}${t.minimum.toString()} ${s.unit}` : `Terlalu kecil: diharapkan ${t.origin} menjadi ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `String tidak valid: harus dimulai dengan "${o.prefix}"` : o.format === "ends_with" ? `String tidak valid: harus berakhir dengan "${o.suffix}"` : o.format === "includes" ? `String tidak valid: harus menyertakan "${o.includes}"` : o.format === "regex" ? `String tidak valid: harus sesuai pola ${o.pattern}` : `${i[o.format] ?? t.format} tidak valid` } case "not_multiple_of": return `Angka tidak valid: harus kelipatan dari ${t.divisor}`; case "unrecognized_keys": return `Kunci tidak dikenali ${t.keys.length > 1 ? "s" : ""}: ${$(t.keys, ", ")}`; case "invalid_key": return `Kunci tidak valid di ${t.origin}`; case "invalid_union": return "Input tidak valid"; case "invalid_element": return `Nilai tidak valid di ${t.origin}`; default: return "Input tidak valid" } } }, "error$s"); function Yf() { return { localeError: qf() } } a(Yf, "id"); const Xf = a(e => { const n = typeof e; switch (n) { case "number": return Number.isNaN(e) ? "NaN" : "nÃºmer"; case "object": { if (Array.isArray(e)) return "fylki"; if (e === null) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name } }return n }, "parsedType$3"), Qf = a(() => { const e = { string: { unit: "stafi", verb: "aÃ° hafa" }, file: { unit: "bÃ¦ti", verb: "aÃ° hafa" }, array: { unit: "hluti", verb: "aÃ° hafa" }, set: { unit: "hluti", verb: "aÃ° hafa" } }; function n(i) { return e[i] ?? null } a(n, "getSizing"); const r = { regex: "gildi", email: "netfang", url: "vefslÃ³Ã°", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dagsetning og tÃ­mi", date: "ISO dagsetning", time: "ISO tÃ­mi", duration: "ISO tÃ­malengd", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded strengur", base64url: "base64url-encoded strengur", json_string: "JSON strengur", e164: "E.164 tÃ¶lugildi", jwt: "JWT", template_literal: "gildi" }; return i => { switch (i.code) { case "invalid_type": return `Rangt gildi: ÃžÃº slÃ³st inn ${Xf(i.input)} Ã¾ar sem Ã¡ aÃ° vera ${i.expected}`; case "invalid_value": return i.values.length === 1 ? `Rangt gildi: gert rÃ¡Ã° fyrir ${P(i.values[0])}` : `Ã“gilt val: mÃ¡ vera eitt af eftirfarandi ${$(i.values, "|")}`; case "too_big": { const t = i.inclusive ? "<=" : "<", o = n(i.origin); return o ? `Of stÃ³rt: gert er rÃ¡Ã° fyrir aÃ° ${i.origin ?? "gildi"} hafi ${t}${i.maximum.toString()} ${o.unit ?? "hluti"}` : `Of stÃ³rt: gert er rÃ¡Ã° fyrir aÃ° ${i.origin ?? "gildi"} sÃ© ${t}${i.maximum.toString()}` } case "too_small": { const t = i.inclusive ? ">=" : ">", o = n(i.origin); return o ? `Of lÃ­tiÃ°: gert er rÃ¡Ã° fyrir aÃ° ${i.origin} hafi ${t}${i.minimum.toString()} ${o.unit}` : `Of lÃ­tiÃ°: gert er rÃ¡Ã° fyrir aÃ° ${i.origin} sÃ© ${t}${i.minimum.toString()}` } case "invalid_format": { const t = i; return t.format === "starts_with" ? `Ã“gildur strengur: verÃ°ur aÃ° byrja Ã¡ "${t.prefix}"` : t.format === "ends_with" ? `Ã“gildur strengur: verÃ°ur aÃ° enda Ã¡ "${t.suffix}"` : t.format === "includes" ? `Ã“gildur strengur: verÃ°ur aÃ° innihalda "${t.includes}"` : t.format === "regex" ? `Ã“gildur strengur: verÃ°ur aÃ° fylgja mynstri ${t.pattern}` : `Rangt ${r[t.format] ?? i.format}` } case "not_multiple_of": return `RÃ¶ng tala: verÃ°ur aÃ° vera margfeldi af ${i.divisor}`; case "unrecognized_keys": return `Ã“Ã¾ekkt ${i.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${$(i.keys, ", ")}`; case "invalid_key": return `Rangur lykill Ã­ ${i.origin}`; case "invalid_union": return "Rangt gildi"; case "invalid_element": return `Rangt gildi Ã­ ${i.origin}`; default: return "Rangt gildi" } } }, "error$r"); function em() { return { localeError: Qf() } } a(em, "is"); const tm = a(() => { const e = { string: { unit: "caratteri", verb: "avere" }, file: { unit: "byte", verb: "avere" }, array: { unit: "elementi", verb: "avere" }, set: { unit: "elementi", verb: "avere" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "numero"; case "object": { if (Array.isArray(t)) return "vettore"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "input", email: "indirizzo email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e ora ISO", date: "data ISO", time: "ora ISO", duration: "durata ISO", ipv4: "indirizzo IPv4", ipv6: "indirizzo IPv6", cidrv4: "intervallo IPv4", cidrv6: "intervallo IPv6", base64: "stringa codificata in base64", base64url: "URL codificata in base64", json_string: "stringa JSON", e164: "numero E.164", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `Input non valido: atteso ${t.expected}, ricevuto ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Input non valido: atteso ${P(t.values[0])}` : `Opzione non valida: atteso uno tra ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Troppo grande: ${t.origin ?? "valore"} deve avere ${o}${t.maximum.toString()} ${s.unit ?? "elementi"}` : `Troppo grande: ${t.origin ?? "valore"} deve essere ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Troppo piccolo: ${t.origin} deve avere ${o}${t.minimum.toString()} ${s.unit}` : `Troppo piccolo: ${t.origin} deve essere ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Stringa non valida: deve iniziare con "${o.prefix}"` : o.format === "ends_with" ? `Stringa non valida: deve terminare con "${o.suffix}"` : o.format === "includes" ? `Stringa non valida: deve includere "${o.includes}"` : o.format === "regex" ? `Stringa non valida: deve corrispondere al pattern ${o.pattern}` : `Invalid ${i[o.format] ?? t.format}` } case "not_multiple_of": return `Numero non valido: deve essere un multiplo di ${t.divisor}`; case "unrecognized_keys": return `Chiav${t.keys.length > 1 ? "i" : "e"} non riconosciut${t.keys.length > 1 ? "e" : "a"}: ${$(t.keys, ", ")}`; case "invalid_key": return `Chiave non valida in ${t.origin}`; case "invalid_union": return "Input non valido"; case "invalid_element": return `Valore non valido in ${t.origin}`; default: return "Input non valido" } } }, "error$q"); function nm() { return { localeError: tm() } } a(nm, "it"); const rm = a(() => { const e = { string: { unit: "æ–‡å­—", verb: "ã§ã‚ã‚‹" }, file: { unit: "ãƒã‚¤ãƒˆ", verb: "ã§ã‚ã‚‹" }, array: { unit: "è¦ç´ ", verb: "ã§ã‚ã‚‹" }, set: { unit: "è¦ç´ ", verb: "ã§ã‚ã‚‹" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "æ•°å€¤"; case "object": { if (Array.isArray(t)) return "é…åˆ—"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "å…¥åŠ›å€¤", email: "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹", url: "URL", emoji: "çµµæ–‡å­—", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISOæ—¥æ™‚", date: "ISOæ—¥ä»˜", time: "ISOæ™‚åˆ»", duration: "ISOæœŸé–“", ipv4: "IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹", ipv6: "IPv6ã‚¢ãƒ‰ãƒ¬ã‚¹", cidrv4: "IPv4ç¯„å›²", cidrv6: "IPv6ç¯„å›²", base64: "base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—", base64url: "base64urlã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—", json_string: "JSONæ–‡å­—åˆ—", e164: "E.164ç•ªå·", jwt: "JWT", template_literal: "å…¥åŠ›å€¤" }; return t => { switch (t.code) { case "invalid_type": return `ç„¡åŠ¹ãªå…¥åŠ›: ${t.expected}ãŒæœŸå¾…ã•ã‚Œã¾ã—ãŸãŒã€${r(t.input)}ãŒå…¥åŠ›ã•ã‚Œã¾ã—ãŸ`; case "invalid_value": return t.values.length === 1 ? `ç„¡åŠ¹ãªå…¥åŠ›: ${P(t.values[0])}ãŒæœŸå¾…ã•ã‚Œã¾ã—ãŸ` : `ç„¡åŠ¹ãªé¸æŠž: ${$(t.values, "ã€")}ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`; case "too_big": { const o = t.inclusive ? "ä»¥ä¸‹ã§ã‚ã‚‹" : "ã‚ˆã‚Šå°ã•ã„", s = n(t.origin); return s ? `å¤§ãã™ãŽã‚‹å€¤: ${t.origin ?? "å€¤"}ã¯${t.maximum.toString()}${s.unit ?? "è¦ç´ "}${o}å¿…è¦ãŒã‚ã‚Šã¾ã™` : `å¤§ãã™ãŽã‚‹å€¤: ${t.origin ?? "å€¤"}ã¯${t.maximum.toString()}${o}å¿…è¦ãŒã‚ã‚Šã¾ã™` } case "too_small": { const o = t.inclusive ? "ä»¥ä¸Šã§ã‚ã‚‹" : "ã‚ˆã‚Šå¤§ãã„", s = n(t.origin); return s ? `å°ã•ã™ãŽã‚‹å€¤: ${t.origin}ã¯${t.minimum.toString()}${s.unit}${o}å¿…è¦ãŒã‚ã‚Šã¾ã™` : `å°ã•ã™ãŽã‚‹å€¤: ${t.origin}ã¯${t.minimum.toString()}${o}å¿…è¦ãŒã‚ã‚Šã¾ã™` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${o.prefix}"ã§å§‹ã¾ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™` : o.format === "ends_with" ? `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${o.suffix}"ã§çµ‚ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™` : o.format === "includes" ? `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${o.includes}"ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™` : o.format === "regex" ? `ç„¡åŠ¹ãªæ–‡å­—åˆ—: ãƒ‘ã‚¿ãƒ¼ãƒ³${o.pattern}ã«ä¸€è‡´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™` : `ç„¡åŠ¹ãª${i[o.format] ?? t.format}` } case "not_multiple_of": return `ç„¡åŠ¹ãªæ•°å€¤: ${t.divisor}ã®å€æ•°ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`; case "unrecognized_keys": return `èªè­˜ã•ã‚Œã¦ã„ãªã„ã‚­ãƒ¼${t.keys.length > 1 ? "ç¾¤" : ""}: ${$(t.keys, "ã€")}`; case "invalid_key": return `${t.origin}å†…ã®ç„¡åŠ¹ãªã‚­ãƒ¼`; case "invalid_union": return "ç„¡åŠ¹ãªå…¥åŠ›"; case "invalid_element": return `${t.origin}å†…ã®ç„¡åŠ¹ãªå€¤`; default: return "ç„¡åŠ¹ãªå…¥åŠ›" } } }, "error$p"); function im() { return { localeError: rm() } } a(im, "ja"); const om = a(e => { const n = typeof e; switch (n) { case "number": return Number.isNaN(e) ? "NaN" : "áƒ áƒ˜áƒªáƒ®áƒ•áƒ˜"; case "object": { if (Array.isArray(e)) return "áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜"; if (e === null) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name } }return { string: "áƒ¡áƒ¢áƒ áƒ˜áƒœáƒ’áƒ˜", boolean: "áƒ‘áƒ£áƒšáƒ”áƒáƒœáƒ˜", undefined: "undefined", bigint: "bigint", symbol: "symbol", function: "áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ" }[n] ?? n }, "parsedType$2"), am = a(() => { const e = { string: { unit: "áƒ¡áƒ˜áƒ›áƒ‘áƒáƒšáƒ", verb: "áƒ£áƒœáƒ“áƒ áƒ¨áƒ”áƒ˜áƒªáƒáƒ•áƒ“áƒ”áƒ¡" }, file: { unit: "áƒ‘áƒáƒ˜áƒ¢áƒ˜", verb: "áƒ£áƒœáƒ“áƒ áƒ¨áƒ”áƒ˜áƒªáƒáƒ•áƒ“áƒ”áƒ¡" }, array: { unit: "áƒ”áƒšáƒ”áƒ›áƒ”áƒœáƒ¢áƒ˜", verb: "áƒ£áƒœáƒ“áƒ áƒ¨áƒ”áƒ˜áƒªáƒáƒ•áƒ“áƒ”áƒ¡" }, set: { unit: "áƒ”áƒšáƒ”áƒ›áƒ”áƒœáƒ¢áƒ˜", verb: "áƒ£áƒœáƒ“áƒ áƒ¨áƒ”áƒ˜áƒªáƒáƒ•áƒ“áƒ”áƒ¡" } }; function n(i) { return e[i] ?? null } a(n, "getSizing"); const r = { regex: "áƒ¨áƒ”áƒ§áƒ•áƒáƒœáƒ", email: "áƒ”áƒš-áƒ¤áƒáƒ¡áƒ¢áƒ˜áƒ¡ áƒ›áƒ˜áƒ¡áƒáƒ›áƒáƒ áƒ—áƒ˜", url: "URL", emoji: "áƒ”áƒ›áƒáƒ¯áƒ˜", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "áƒ—áƒáƒ áƒ˜áƒ¦áƒ˜-áƒ“áƒ áƒ", date: "áƒ—áƒáƒ áƒ˜áƒ¦áƒ˜", time: "áƒ“áƒ áƒ", duration: "áƒ®áƒáƒœáƒ’áƒ áƒ«áƒšáƒ˜áƒ•áƒáƒ‘áƒ", ipv4: "IPv4 áƒ›áƒ˜áƒ¡áƒáƒ›áƒáƒ áƒ—áƒ˜", ipv6: "IPv6 áƒ›áƒ˜áƒ¡áƒáƒ›áƒáƒ áƒ—áƒ˜", cidrv4: "IPv4 áƒ“áƒ˜áƒáƒžáƒáƒ–áƒáƒœáƒ˜", cidrv6: "IPv6 áƒ“áƒ˜áƒáƒžáƒáƒ–áƒáƒœáƒ˜", base64: "base64-áƒ™áƒáƒ“áƒ˜áƒ áƒ”áƒ‘áƒ£áƒšáƒ˜ áƒ¡áƒ¢áƒ áƒ˜áƒœáƒ’áƒ˜", base64url: "base64url-áƒ™áƒáƒ“áƒ˜áƒ áƒ”áƒ‘áƒ£áƒšáƒ˜ áƒ¡áƒ¢áƒ áƒ˜áƒœáƒ’áƒ˜", json_string: "JSON áƒ¡áƒ¢áƒ áƒ˜áƒœáƒ’áƒ˜", e164: "E.164 áƒœáƒáƒ›áƒ”áƒ áƒ˜", jwt: "JWT", template_literal: "áƒ¨áƒ”áƒ§áƒ•áƒáƒœáƒ" }; return i => { switch (i.code) { case "invalid_type": return `áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ¨áƒ”áƒ§áƒ•áƒáƒœáƒ: áƒ›áƒáƒ¡áƒáƒšáƒáƒ“áƒœáƒ”áƒšáƒ˜ ${i.expected}, áƒ›áƒ˜áƒ¦áƒ”áƒ‘áƒ£áƒšáƒ˜ ${om(i.input)}`; case "invalid_value": return i.values.length === 1 ? `áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ¨áƒ”áƒ§áƒ•áƒáƒœáƒ: áƒ›áƒáƒ¡áƒáƒšáƒáƒ“áƒœáƒ”áƒšáƒ˜ ${P(i.values[0])}` : `áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ•áƒáƒ áƒ˜áƒáƒœáƒ¢áƒ˜: áƒ›áƒáƒ¡áƒáƒšáƒáƒ“áƒœáƒ”áƒšáƒ˜áƒ áƒ”áƒ áƒ—-áƒ”áƒ áƒ—áƒ˜ ${$(i.values, "|")}-áƒ“áƒáƒœ`; case "too_big": { const t = i.inclusive ? "<=" : "<", o = n(i.origin); return o ? `áƒ–áƒ”áƒ“áƒ›áƒ”áƒ¢áƒáƒ“ áƒ“áƒ˜áƒ“áƒ˜: áƒ›áƒáƒ¡áƒáƒšáƒáƒ“áƒœáƒ”áƒšáƒ˜ ${i.origin ?? "áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ"} ${o.verb} ${t}${i.maximum.toString()} ${o.unit}` : `áƒ–áƒ”áƒ“áƒ›áƒ”áƒ¢áƒáƒ“ áƒ“áƒ˜áƒ“áƒ˜: áƒ›áƒáƒ¡áƒáƒšáƒáƒ“áƒœáƒ”áƒšáƒ˜ ${i.origin ?? "áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ"} áƒ˜áƒ§áƒáƒ¡ ${t}${i.maximum.toString()}` } case "too_small": { const t = i.inclusive ? ">=" : ">", o = n(i.origin); return o ? `áƒ–áƒ”áƒ“áƒ›áƒ”áƒ¢áƒáƒ“ áƒžáƒáƒ¢áƒáƒ áƒ: áƒ›áƒáƒ¡áƒáƒšáƒáƒ“áƒœáƒ”áƒšáƒ˜ ${i.origin} ${o.verb} ${t}${i.minimum.toString()} ${o.unit}` : `áƒ–áƒ”áƒ“áƒ›áƒ”áƒ¢áƒáƒ“ áƒžáƒáƒ¢áƒáƒ áƒ: áƒ›áƒáƒ¡áƒáƒšáƒáƒ“áƒœáƒ”áƒšáƒ˜ ${i.origin} áƒ˜áƒ§áƒáƒ¡ ${t}${i.minimum.toString()}` } case "invalid_format": { const t = i; return t.format === "starts_with" ? `áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ¡áƒ¢áƒ áƒ˜áƒœáƒ’áƒ˜: áƒ£áƒœáƒ“áƒ áƒ˜áƒ¬áƒ§áƒ”áƒ‘áƒáƒ“áƒ”áƒ¡ "${t.prefix}"-áƒ˜áƒ—` : t.format === "ends_with" ? `áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ¡áƒ¢áƒ áƒ˜áƒœáƒ’áƒ˜: áƒ£áƒœáƒ“áƒ áƒ›áƒ—áƒáƒ•áƒ áƒ“áƒ”áƒ‘áƒáƒ“áƒ”áƒ¡ "${t.suffix}"-áƒ˜áƒ—` : t.format === "includes" ? `áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ¡áƒ¢áƒ áƒ˜áƒœáƒ’áƒ˜: áƒ£áƒœáƒ“áƒ áƒ¨áƒ”áƒ˜áƒªáƒáƒ•áƒ“áƒ”áƒ¡ "${t.includes}"-áƒ¡` : t.format === "regex" ? `áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ¡áƒ¢áƒ áƒ˜áƒœáƒ’áƒ˜: áƒ£áƒœáƒ“áƒ áƒ¨áƒ”áƒ”áƒ¡áƒáƒ‘áƒáƒ›áƒ”áƒ‘áƒáƒ“áƒ”áƒ¡ áƒ¨áƒáƒ‘áƒšáƒáƒœáƒ¡ ${t.pattern}` : `áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ ${r[t.format] ?? i.format}` } case "not_multiple_of": return `áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ áƒ˜áƒªáƒ®áƒ•áƒ˜: áƒ£áƒœáƒ“áƒ áƒ˜áƒ§áƒáƒ¡ ${i.divisor}-áƒ˜áƒ¡ áƒ¯áƒ”áƒ áƒáƒ“áƒ˜`; case "unrecognized_keys": return `áƒ£áƒªáƒœáƒáƒ‘áƒ˜ áƒ’áƒáƒ¡áƒáƒ¦áƒ”áƒ‘${i.keys.length > 1 ? "áƒ”áƒ‘áƒ˜" : "áƒ˜"}: ${$(i.keys, ", ")}`; case "invalid_key": return `áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ’áƒáƒ¡áƒáƒ¦áƒ”áƒ‘áƒ˜ ${i.origin}-áƒ¨áƒ˜`; case "invalid_union": return "áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ¨áƒ”áƒ§áƒ•áƒáƒœáƒ"; case "invalid_element": return `áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ ${i.origin}-áƒ¨áƒ˜`; default: return "áƒáƒ áƒáƒ¡áƒ¬áƒáƒ áƒ˜ áƒ¨áƒ”áƒ§áƒ•áƒáƒœáƒ" } } }, "error$o"); function sm() { return { localeError: am() } } a(sm, "ka"); const cm = a(() => { const e = { string: { unit: "ážáž½áž¢áž€áŸ’ážŸážš", verb: "áž‚áž½ážšáž˜áž¶áž“" }, file: { unit: "áž”áŸƒ", verb: "áž‚áž½ážšáž˜áž¶áž“" }, array: { unit: "áž’áž¶ážáž»", verb: "áž‚áž½ážšáž˜áž¶áž“" }, set: { unit: "áž’áž¶ážáž»", verb: "áž‚áž½ážšáž˜áž¶áž“" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "áž˜áž·áž“áž˜áŸ‚áž“áž‡áž¶áž›áŸáž (NaN)" : "áž›áŸáž"; case "object": { if (Array.isArray(t)) return "áž¢áž¶ážšáŸ (Array)"; if (t === null) return "áž‚áŸ’áž˜áž¶áž“ážáž˜áŸ’áž›áŸƒ (null)"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›", email: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“áž¢áŸŠáž¸áž˜áŸ‚áž›", url: "URL", emoji: "ážŸáž‰áŸ’áž‰áž¶áž¢áž¶ážšáž˜áŸ’áž˜ážŽáŸ", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘ áž“áž·áž„áž˜áŸ‰áŸ„áž„ ISO", date: "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘ ISO", time: "áž˜áŸ‰áŸ„áž„ ISO", duration: "ážšáž™áŸˆáž–áŸáž› ISO", ipv4: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv4", ipv6: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv6", cidrv4: "ážŠáŸ‚áž“áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv4", cidrv6: "ážŠáŸ‚áž“áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv6", base64: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž¢áŸŠáž·áž€áž¼ážŠ base64", base64url: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž¢áŸŠáž·áž€áž¼ážŠ base64url", json_string: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážš JSON", e164: "áž›áŸáž E.164", jwt: "JWT", template_literal: "áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›" }; return t => { switch (t.code) { case "invalid_type": return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${t.expected} áž”áŸ‰áž»áž“áŸ’ážáŸ‚áž‘áž‘áž½áž›áž”áž¶áž“ ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${P(t.values[0])}` : `áž‡áž˜áŸ’ážšáž¾ážŸáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž‡áž¶áž˜áž½áž™áž€áŸ’áž“áž»áž„áž…áŸ†ážŽáŸ„áž˜ ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `áž’áŸ†áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${t.origin ?? "ážáž˜áŸ’áž›áŸƒ"} ${o} ${t.maximum.toString()} ${s.unit ?? "áž’áž¶ážáž»"}` : `áž’áŸ†áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${t.origin ?? "ážáž˜áŸ’áž›áŸƒ"} ${o} ${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `ážáž¼áž…áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${t.origin} ${o} ${t.minimum.toString()} ${s.unit}` : `ážáž¼áž…áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${t.origin} ${o} ${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜ážŠáŸ„áž™ "${o.prefix}"` : o.format === "ends_with" ? `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž”áž‰áŸ’áž…áž”áŸ‹ážŠáŸ„áž™ "${o.suffix}"` : o.format === "includes" ? `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž˜áž¶áž“ "${o.includes}"` : o.format === "regex" ? `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœážáŸ‚áž•áŸ’áž‚áž¼áž•áŸ’áž‚áž„áž“áž¹áž„áž‘áž˜áŸ’ážšáž„áŸ‹ážŠáŸ‚áž›áž”áž¶áž“áž€áŸ†ážŽážáŸ‹ ${o.pattern}` : `áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ${i[o.format] ?? t.format}` } case "not_multiple_of": return `áž›áŸážáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœážáŸ‚áž‡áž¶áž–áž áž»áž‚áž»ážŽáž“áŸƒ ${t.divisor}`; case "unrecognized_keys": return `ážšáž€ážƒáž¾áž‰ážŸáŸ„áž˜áž·áž“ážŸáŸ’áž‚áž¶áž›áŸ‹áŸ– ${$(t.keys, ", ")}`; case "invalid_key": return `ážŸáŸ„áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáž“áŸ…áž€áŸ’áž“áž»áž„ ${t.origin}`; case "invalid_union": return "áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœ"; case "invalid_element": return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáž“áŸ…áž€áŸ’áž“áž»áž„ ${t.origin}`; default: return "áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœ" } } }, "error$n"); function Pc() { return { localeError: cm() } } a(Pc, "km"); function um() { return Pc() } a(um, "kh"); const lm = a(() => { const e = { string: { unit: "ë¬¸ìž", verb: "to have" }, file: { unit: "ë°”ì´íŠ¸", verb: "to have" }, array: { unit: "ê°œ", verb: "to have" }, set: { unit: "ê°œ", verb: "to have" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "ìž…ë ¥", email: "ì´ë©”ì¼ ì£¼ì†Œ", url: "URL", emoji: "ì´ëª¨ì§€", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ë‚ ì§œì‹œê°„", date: "ISO ë‚ ì§œ", time: "ISO ì‹œê°„", duration: "ISO ê¸°ê°„", ipv4: "IPv4 ì£¼ì†Œ", ipv6: "IPv6 ì£¼ì†Œ", cidrv4: "IPv4 ë²”ìœ„", cidrv6: "IPv6 ë²”ìœ„", base64: "base64 ì¸ì½”ë”© ë¬¸ìžì—´", base64url: "base64url ì¸ì½”ë”© ë¬¸ìžì—´", json_string: "JSON ë¬¸ìžì—´", e164: "E.164 ë²ˆí˜¸", jwt: "JWT", template_literal: "ìž…ë ¥" }; return t => { switch (t.code) { case "invalid_type": return `ìž˜ëª»ëœ ìž…ë ¥: ì˜ˆìƒ íƒ€ìž…ì€ ${t.expected}, ë°›ì€ íƒ€ìž…ì€ ${r(t.input)}ìž…ë‹ˆë‹¤`; case "invalid_value": return t.values.length === 1 ? `ìž˜ëª»ëœ ìž…ë ¥: ê°’ì€ ${P(t.values[0])} ì´ì–´ì•¼ í•©ë‹ˆë‹¤` : `ìž˜ëª»ëœ ì˜µì…˜: ${$(t.values, "ë˜ëŠ” ")} ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤`; case "too_big": { const o = t.inclusive ? "ì´í•˜" : "ë¯¸ë§Œ", s = o === "ë¯¸ë§Œ" ? "ì´ì–´ì•¼ í•©ë‹ˆë‹¤" : "ì—¬ì•¼ í•©ë‹ˆë‹¤", c = n(t.origin), u = c?.unit ?? "ìš”ì†Œ"; return c ? `${t.origin ?? "ê°’"}ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: ${t.maximum.toString()}${u} ${o}${s}` : `${t.origin ?? "ê°’"}ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: ${t.maximum.toString()} ${o}${s}` } case "too_small": { const o = t.inclusive ? "ì´ìƒ" : "ì´ˆê³¼", s = o === "ì´ìƒ" ? "ì´ì–´ì•¼ í•©ë‹ˆë‹¤" : "ì—¬ì•¼ í•©ë‹ˆë‹¤", c = n(t.origin), u = c?.unit ?? "ìš”ì†Œ"; return c ? `${t.origin ?? "ê°’"}ì´ ë„ˆë¬´ ìž‘ìŠµë‹ˆë‹¤: ${t.minimum.toString()}${u} ${o}${s}` : `${t.origin ?? "ê°’"}ì´ ë„ˆë¬´ ìž‘ìŠµë‹ˆë‹¤: ${t.minimum.toString()} ${o}${s}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `ìž˜ëª»ëœ ë¬¸ìžì—´: "${o.prefix}"(ìœ¼)ë¡œ ì‹œìž‘í•´ì•¼ í•©ë‹ˆë‹¤` : o.format === "ends_with" ? `ìž˜ëª»ëœ ë¬¸ìžì—´: "${o.suffix}"(ìœ¼)ë¡œ ëë‚˜ì•¼ í•©ë‹ˆë‹¤` : o.format === "includes" ? `ìž˜ëª»ëœ ë¬¸ìžì—´: "${o.includes}"ì„(ë¥¼) í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤` : o.format === "regex" ? `ìž˜ëª»ëœ ë¬¸ìžì—´: ì •ê·œì‹ ${o.pattern} íŒ¨í„´ê³¼ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤` : `ìž˜ëª»ëœ ${i[o.format] ?? t.format}` } case "not_multiple_of": return `ìž˜ëª»ëœ ìˆ«ìž: ${t.divisor}ì˜ ë°°ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤`; case "unrecognized_keys": return `ì¸ì‹í•  ìˆ˜ ì—†ëŠ” í‚¤: ${$(t.keys, ", ")}`; case "invalid_key": return `ìž˜ëª»ëœ í‚¤: ${t.origin}`; case "invalid_union": return "ìž˜ëª»ëœ ìž…ë ¥"; case "invalid_element": return `ìž˜ëª»ëœ ê°’: ${t.origin}`; default: return "ìž˜ëª»ëœ ìž…ë ¥" } } }, "error$m"); function dm() { return { localeError: lm() } } a(dm, "ko"); const fm = a(e => Qt(typeof e, e), "parsedType$1"), Qt = a((e, n = void 0) => { switch (e) { case "number": return Number.isNaN(n) ? "NaN" : "skaiÄius"; case "bigint": return "sveikasis skaiÄius"; case "string": return "eilutÄ—"; case "boolean": return "loginÄ— reikÅ¡mÄ—"; case "undefined": case "void": return "neapibrÄ—Å¾ta reikÅ¡mÄ—"; case "function": return "funkcija"; case "symbol": return "simbolis"; case "object": return n === void 0 ? "neÅ¾inomas objektas" : n === null ? "nulinÄ— reikÅ¡mÄ—" : Array.isArray(n) ? "masyvas" : Object.getPrototypeOf(n) !== Object.prototype && n.constructor ? n.constructor.name : "objektas"; case "null": return "nulinÄ— reikÅ¡mÄ—" }return e }, "parsedTypeFromType"), en = a(e => e.charAt(0).toUpperCase() + e.slice(1), "capitalizeFirstCharacter"); function Dc(e) { const n = Math.abs(e), r = n % 10, i = n % 100; return i >= 11 && i <= 19 || r === 0 ? "many" : r === 1 ? "one" : "few" } a(Dc, "getUnitTypeFromNumber"); const mm = a(() => { const e = { string: { unit: { one: "simbolis", few: "simboliai", many: "simboliÅ³" }, verb: { smaller: { inclusive: "turi bÅ«ti ne ilgesnÄ— kaip", notInclusive: "turi bÅ«ti trumpesnÄ— kaip" }, bigger: { inclusive: "turi bÅ«ti ne trumpesnÄ— kaip", notInclusive: "turi bÅ«ti ilgesnÄ— kaip" } } }, file: { unit: { one: "baitas", few: "baitai", many: "baitÅ³" }, verb: { smaller: { inclusive: "turi bÅ«ti ne didesnis kaip", notInclusive: "turi bÅ«ti maÅ¾esnis kaip" }, bigger: { inclusive: "turi bÅ«ti ne maÅ¾esnis kaip", notInclusive: "turi bÅ«ti didesnis kaip" } } }, array: { unit: { one: "elementÄ…", few: "elementus", many: "elementÅ³" }, verb: { smaller: { inclusive: "turi turÄ—ti ne daugiau kaip", notInclusive: "turi turÄ—ti maÅ¾iau kaip" }, bigger: { inclusive: "turi turÄ—ti ne maÅ¾iau kaip", notInclusive: "turi turÄ—ti daugiau kaip" } } }, set: { unit: { one: "elementÄ…", few: "elementus", many: "elementÅ³" }, verb: { smaller: { inclusive: "turi turÄ—ti ne daugiau kaip", notInclusive: "turi turÄ—ti maÅ¾iau kaip" }, bigger: { inclusive: "turi turÄ—ti ne maÅ¾iau kaip", notInclusive: "turi turÄ—ti daugiau kaip" } } } }; function n(i, t, o, s) { const c = e[i] ?? null; return c === null ? c : { unit: c.unit[t], verb: c.verb[s][o ? "inclusive" : "notInclusive"] } } a(n, "getSizing"); const r = { regex: "Ä¯vestis", email: "el. paÅ¡to adresas", url: "URL", emoji: "jaustukas", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO data ir laikas", date: "ISO data", time: "ISO laikas", duration: "ISO trukmÄ—", ipv4: "IPv4 adresas", ipv6: "IPv6 adresas", cidrv4: "IPv4 tinklo prefiksas (CIDR)", cidrv6: "IPv6 tinklo prefiksas (CIDR)", base64: "base64 uÅ¾koduota eilutÄ—", base64url: "base64url uÅ¾koduota eilutÄ—", json_string: "JSON eilutÄ—", e164: "E.164 numeris", jwt: "JWT", template_literal: "Ä¯vestis" }; return i => { switch (i.code) { case "invalid_type": return `Gautas tipas ${fm(i.input)}, o tikÄ—tasi - ${Qt(i.expected)}`; case "invalid_value": return i.values.length === 1 ? `Privalo bÅ«ti ${P(i.values[0])}` : `Privalo bÅ«ti vienas iÅ¡ ${$(i.values, "|")} pasirinkimÅ³`; case "too_big": { const t = Qt(i.origin), o = n(i.origin, Dc(Number(i.maximum)), i.inclusive ?? !1, "smaller"); if (o?.verb) return `${en(t ?? i.origin ?? "reikÅ¡mÄ—")} ${o.verb} ${i.maximum.toString()} ${o.unit ?? "elementÅ³"}`; const s = i.inclusive ? "ne didesnis kaip" : "maÅ¾esnis kaip"; return `${en(t ?? i.origin ?? "reikÅ¡mÄ—")} turi bÅ«ti ${s} ${i.maximum.toString()} ${o?.unit}` } case "too_small": { const t = Qt(i.origin), o = n(i.origin, Dc(Number(i.minimum)), i.inclusive ?? !1, "bigger"); if (o?.verb) return `${en(t ?? i.origin ?? "reikÅ¡mÄ—")} ${o.verb} ${i.minimum.toString()} ${o.unit ?? "elementÅ³"}`; const s = i.inclusive ? "ne maÅ¾esnis kaip" : "didesnis kaip"; return `${en(t ?? i.origin ?? "reikÅ¡mÄ—")} turi bÅ«ti ${s} ${i.minimum.toString()} ${o?.unit}` } case "invalid_format": { const t = i; return t.format === "starts_with" ? `EilutÄ— privalo prasidÄ—ti "${t.prefix}"` : t.format === "ends_with" ? `EilutÄ— privalo pasibaigti "${t.suffix}"` : t.format === "includes" ? `EilutÄ— privalo Ä¯traukti "${t.includes}"` : t.format === "regex" ? `EilutÄ— privalo atitikti ${t.pattern}` : `Neteisingas ${r[t.format] ?? i.format}` } case "not_multiple_of": return `SkaiÄius privalo bÅ«ti ${i.divisor} kartotinis.`; case "unrecognized_keys": return `NeatpaÅ¾int${i.keys.length > 1 ? "i" : "as"} rakt${i.keys.length > 1 ? "ai" : "as"}: ${$(i.keys, ", ")}`; case "invalid_key": return "Rastas klaidingas raktas"; case "invalid_union": return "Klaidinga Ä¯vestis"; case "invalid_element": { const t = Qt(i.origin); return `${en(t ?? i.origin ?? "reikÅ¡mÄ—")} turi klaidingÄ… Ä¯vestÄ¯` } default: return "Klaidinga Ä¯vestis" } } }, "error$l"); function pm() { return { localeError: mm() } } a(pm, "lt"); const hm = a(() => { const e = { string: { unit: "Ð·Ð½Ð°Ñ†Ð¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" }, file: { unit: "Ð±Ð°Ñ˜Ñ‚Ð¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" }, array: { unit: "ÑÑ‚Ð°Ð²ÐºÐ¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" }, set: { unit: "ÑÑ‚Ð°Ð²ÐºÐ¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "Ð±Ñ€Ð¾Ñ˜"; case "object": { if (Array.isArray(t)) return "Ð½Ð¸Ð·Ð°"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "Ð²Ð½ÐµÑ", email: "Ð°Ð´Ñ€ÐµÑÐ° Ð½Ð° Ðµ-Ð¿Ð¾ÑˆÑ‚Ð°", url: "URL", emoji: "ÐµÐ¼Ð¾ÑŸÐ¸", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO Ð´Ð°Ñ‚ÑƒÐ¼ Ð¸ Ð²Ñ€ÐµÐ¼Ðµ", date: "ISO Ð´Ð°Ñ‚ÑƒÐ¼", time: "ISO Ð²Ñ€ÐµÐ¼Ðµ", duration: "ISO Ð²Ñ€ÐµÐ¼ÐµÑ‚Ñ€Ð°ÐµÑšÐµ", ipv4: "IPv4 Ð°Ð´Ñ€ÐµÑÐ°", ipv6: "IPv6 Ð°Ð´Ñ€ÐµÑÐ°", cidrv4: "IPv4 Ð¾Ð¿ÑÐµÐ³", cidrv6: "IPv6 Ð¾Ð¿ÑÐµÐ³", base64: "base64-ÐµÐ½ÐºÐ¾Ð´Ð¸Ñ€Ð°Ð½Ð° Ð½Ð¸Ð·Ð°", base64url: "base64url-ÐµÐ½ÐºÐ¾Ð´Ð¸Ñ€Ð°Ð½Ð° Ð½Ð¸Ð·Ð°", json_string: "JSON Ð½Ð¸Ð·Ð°", e164: "E.164 Ð±Ñ€Ð¾Ñ˜", jwt: "JWT", template_literal: "Ð²Ð½ÐµÑ" }; return t => { switch (t.code) { case "invalid_type": return `Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${t.expected}, Ð¿Ñ€Ð¸Ð¼ÐµÐ½Ð¾ ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Invalid input: expected ${P(t.values[0])}` : `Ð“Ñ€ÐµÑˆÐ°Ð½Ð° Ð¾Ð¿Ñ†Ð¸Ñ˜Ð°: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ÐµÐ´Ð½Ð° ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð³Ð¾Ð»ÐµÐ¼: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${t.origin ?? "Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚Ð°"} Ð´Ð° Ð¸Ð¼Ð° ${o}${t.maximum.toString()} ${s.unit ?? "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¸"}` : `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð³Ð¾Ð»ÐµÐ¼: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${t.origin ?? "Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚Ð°"} Ð´Ð° Ð±Ð¸Ð´Ðµ ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð¼Ð°Ð»: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${t.origin} Ð´Ð° Ð¸Ð¼Ð° ${o}${t.minimum.toString()} ${s.unit}` : `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð¼Ð°Ð»: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${t.origin} Ð´Ð° Ð±Ð¸Ð´Ðµ ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð·Ð°Ð¿Ð¾Ñ‡Ð½ÑƒÐ²Ð° ÑÐ¾ "${o.prefix}"` : o.format === "ends_with" ? `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð·Ð°Ð²Ñ€ÑˆÑƒÐ²Ð° ÑÐ¾ "${o.suffix}"` : o.format === "includes" ? `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð²ÐºÐ»ÑƒÑ‡ÑƒÐ²Ð° "${o.includes}"` : o.format === "regex" ? `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð¾Ð´Ð³Ð¾Ð°Ñ€Ð° Ð½Ð° Ð¿Ð°Ñ‚ÐµÑ€Ð½Ð¾Ñ‚ ${o.pattern}` : `Invalid ${i[o.format] ?? t.format}` } case "not_multiple_of": return `Ð“Ñ€ÐµÑˆÐµÐ½ Ð±Ñ€Ð¾Ñ˜: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð±Ð¸Ð´Ðµ Ð´ÐµÐ»Ð¸Ð² ÑÐ¾ ${t.divisor}`; case "unrecognized_keys": return `${t.keys.length > 1 ? "ÐÐµÐ¿Ñ€ÐµÐ¿Ð¾Ð·Ð½Ð°ÐµÐ½Ð¸ ÐºÐ»ÑƒÑ‡ÐµÐ²Ð¸" : "ÐÐµÐ¿Ñ€ÐµÐ¿Ð¾Ð·Ð½Ð°ÐµÐ½ ÐºÐ»ÑƒÑ‡"}: ${$(t.keys, ", ")}`; case "invalid_key": return `Ð“Ñ€ÐµÑˆÐµÐ½ ÐºÐ»ÑƒÑ‡ Ð²Ð¾ ${t.origin}`; case "invalid_union": return "Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ"; case "invalid_element": return `Ð“Ñ€ÐµÑˆÐ½Ð° Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚ Ð²Ð¾ ${t.origin}`; default: return "Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ" } } }, "error$k"); function gm() { return { localeError: hm() } } a(gm, "mk"); const vm = a(() => { const e = { string: { unit: "aksara", verb: "mempunyai" }, file: { unit: "bait", verb: "mempunyai" }, array: { unit: "elemen", verb: "mempunyai" }, set: { unit: "elemen", verb: "mempunyai" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "nombor"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "input", email: "alamat e-mel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tarikh masa ISO", date: "tarikh ISO", time: "masa ISO", duration: "tempoh ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "julat IPv4", cidrv6: "julat IPv6", base64: "string dikodkan base64", base64url: "string dikodkan base64url", json_string: "string JSON", e164: "nombor E.164", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `Input tidak sah: dijangka ${t.expected}, diterima ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Input tidak sah: dijangka ${P(t.values[0])}` : `Pilihan tidak sah: dijangka salah satu daripada ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Terlalu besar: dijangka ${t.origin ?? "nilai"} ${s.verb} ${o}${t.maximum.toString()} ${s.unit ?? "elemen"}` : `Terlalu besar: dijangka ${t.origin ?? "nilai"} adalah ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Terlalu kecil: dijangka ${t.origin} ${s.verb} ${o}${t.minimum.toString()} ${s.unit}` : `Terlalu kecil: dijangka ${t.origin} adalah ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `String tidak sah: mesti bermula dengan "${o.prefix}"` : o.format === "ends_with" ? `String tidak sah: mesti berakhir dengan "${o.suffix}"` : o.format === "includes" ? `String tidak sah: mesti mengandungi "${o.includes}"` : o.format === "regex" ? `String tidak sah: mesti sepadan dengan corak ${o.pattern}` : `${i[o.format] ?? t.format} tidak sah` } case "not_multiple_of": return `Nombor tidak sah: perlu gandaan ${t.divisor}`; case "unrecognized_keys": return `Kunci tidak dikenali: ${$(t.keys, ", ")}`; case "invalid_key": return `Kunci tidak sah dalam ${t.origin}`; case "invalid_union": return "Input tidak sah"; case "invalid_element": return `Nilai tidak sah dalam ${t.origin}`; default: return "Input tidak sah" } } }, "error$j"); function _m() { return { localeError: vm() } } a(_m, "ms"); const bm = a(() => { const e = { string: { unit: "tekens" }, file: { unit: "bytes" }, array: { unit: "elementen" }, set: { unit: "elementen" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "getal"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "invoer", email: "emailadres", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum en tijd", date: "ISO datum", time: "ISO tijd", duration: "ISO duur", ipv4: "IPv4-adres", ipv6: "IPv6-adres", cidrv4: "IPv4-bereik", cidrv6: "IPv6-bereik", base64: "base64-gecodeerde tekst", base64url: "base64 URL-gecodeerde tekst", json_string: "JSON string", e164: "E.164-nummer", jwt: "JWT", template_literal: "invoer" }; return t => { switch (t.code) { case "invalid_type": return `Ongeldige invoer: verwacht ${t.expected}, ontving ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Ongeldige invoer: verwacht ${P(t.values[0])}` : `Ongeldige optie: verwacht Ã©Ã©n van ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Te lang: verwacht dat ${t.origin ?? "waarde"} ${o}${t.maximum.toString()} ${s.unit ?? "elementen"} bevat` : `Te lang: verwacht dat ${t.origin ?? "waarde"} ${o}${t.maximum.toString()} is` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Te kort: verwacht dat ${t.origin} ${o}${t.minimum.toString()} ${s.unit} bevat` : `Te kort: verwacht dat ${t.origin} ${o}${t.minimum.toString()} is` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Ongeldige tekst: moet met "${o.prefix}" beginnen` : o.format === "ends_with" ? `Ongeldige tekst: moet op "${o.suffix}" eindigen` : o.format === "includes" ? `Ongeldige tekst: moet "${o.includes}" bevatten` : o.format === "regex" ? `Ongeldige tekst: moet overeenkomen met patroon ${o.pattern}` : `Ongeldig: ${i[o.format] ?? t.format}` } case "not_multiple_of": return `Ongeldig getal: moet een veelvoud van ${t.divisor} zijn`; case "unrecognized_keys": return `Onbekende key${t.keys.length > 1 ? "s" : ""}: ${$(t.keys, ", ")}`; case "invalid_key": return `Ongeldige key in ${t.origin}`; case "invalid_union": return "Ongeldige invoer"; case "invalid_element": return `Ongeldige waarde in ${t.origin}`; default: return "Ongeldige invoer" } } }, "error$i"); function ym() { return { localeError: bm() } } a(ym, "nl"); const $m = a(() => { const e = { string: { unit: "tegn", verb: "Ã¥ ha" }, file: { unit: "bytes", verb: "Ã¥ ha" }, array: { unit: "elementer", verb: "Ã¥ inneholde" }, set: { unit: "elementer", verb: "Ã¥ inneholde" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "tall"; case "object": { if (Array.isArray(t)) return "liste"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "input", email: "e-postadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslett", date: "ISO-dato", time: "ISO-klokkeslett", duration: "ISO-varighet", ipv4: "IPv4-omrÃ¥de", ipv6: "IPv6-omrÃ¥de", cidrv4: "IPv4-spekter", cidrv6: "IPv6-spekter", base64: "base64-enkodet streng", base64url: "base64url-enkodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `Ugyldig input: forventet ${t.expected}, fikk ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Ugyldig verdi: forventet ${P(t.values[0])}` : `Ugyldig valg: forventet en av ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `For stor(t): forventet ${t.origin ?? "value"} til Ã¥ ha ${o}${t.maximum.toString()} ${s.unit ?? "elementer"}` : `For stor(t): forventet ${t.origin ?? "value"} til Ã¥ ha ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `For lite(n): forventet ${t.origin} til Ã¥ ha ${o}${t.minimum.toString()} ${s.unit}` : `For lite(n): forventet ${t.origin} til Ã¥ ha ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Ugyldig streng: mÃ¥ starte med "${o.prefix}"` : o.format === "ends_with" ? `Ugyldig streng: mÃ¥ ende med "${o.suffix}"` : o.format === "includes" ? `Ugyldig streng: mÃ¥ inneholde "${o.includes}"` : o.format === "regex" ? `Ugyldig streng: mÃ¥ matche mÃ¸nsteret ${o.pattern}` : `Ugyldig ${i[o.format] ?? t.format}` } case "not_multiple_of": return `Ugyldig tall: mÃ¥ vÃ¦re et multiplum av ${t.divisor}`; case "unrecognized_keys": return `${t.keys.length > 1 ? "Ukjente nÃ¸kler" : "Ukjent nÃ¸kkel"}: ${$(t.keys, ", ")}`; case "invalid_key": return `Ugyldig nÃ¸kkel i ${t.origin}`; case "invalid_union": return "Ugyldig input"; case "invalid_element": return `Ugyldig verdi i ${t.origin}`; default: return "Ugyldig input" } } }, "error$h"); function wm() { return { localeError: $m() } } a(wm, "no"); const km = a(() => { const e = { string: { unit: "harf", verb: "olmalÄ±dÄ±r" }, file: { unit: "bayt", verb: "olmalÄ±dÄ±r" }, array: { unit: "unsur", verb: "olmalÄ±dÄ±r" }, set: { unit: "unsur", verb: "olmalÄ±dÄ±r" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "numara"; case "object": { if (Array.isArray(t)) return "saf"; if (t === null) return "gayb"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "giren", email: "epostagÃ¢h", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO hengÃ¢mÄ±", date: "ISO tarihi", time: "ISO zamanÄ±", duration: "ISO mÃ¼ddeti", ipv4: "IPv4 niÅŸÃ¢nÄ±", ipv6: "IPv6 niÅŸÃ¢nÄ±", cidrv4: "IPv4 menzili", cidrv6: "IPv6 menzili", base64: "base64-ÅŸifreli metin", base64url: "base64url-ÅŸifreli metin", json_string: "JSON metin", e164: "E.164 sayÄ±sÄ±", jwt: "JWT", template_literal: "giren" }; return t => { switch (t.code) { case "invalid_type": return `FÃ¢sit giren: umulan ${t.expected}, alÄ±nan ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `FÃ¢sit giren: umulan ${P(t.values[0])}` : `FÃ¢sit tercih: mÃ»teberler ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Fazla bÃ¼yÃ¼k: ${t.origin ?? "value"}, ${o}${t.maximum.toString()} ${s.unit ?? "elements"} sahip olmalÄ±ydÄ±.` : `Fazla bÃ¼yÃ¼k: ${t.origin ?? "value"}, ${o}${t.maximum.toString()} olmalÄ±ydÄ±.` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Fazla kÃ¼Ã§Ã¼k: ${t.origin}, ${o}${t.minimum.toString()} ${s.unit} sahip olmalÄ±ydÄ±.` : `Fazla kÃ¼Ã§Ã¼k: ${t.origin}, ${o}${t.minimum.toString()} olmalÄ±ydÄ±.` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `FÃ¢sit metin: "${o.prefix}" ile baÅŸlamalÄ±.` : o.format === "ends_with" ? `FÃ¢sit metin: "${o.suffix}" ile bitmeli.` : o.format === "includes" ? `FÃ¢sit metin: "${o.includes}" ihtivÃ¢ etmeli.` : o.format === "regex" ? `FÃ¢sit metin: ${o.pattern} nakÅŸÄ±na uymalÄ±.` : `FÃ¢sit ${i[o.format] ?? t.format}` } case "not_multiple_of": return `FÃ¢sit sayÄ±: ${t.divisor} katÄ± olmalÄ±ydÄ±.`; case "unrecognized_keys": return `TanÄ±nmayan anahtar ${t.keys.length > 1 ? "s" : ""}: ${$(t.keys, ", ")}`; case "invalid_key": return `${t.origin} iÃ§in tanÄ±nmayan anahtar var.`; case "invalid_union": return "Giren tanÄ±namadÄ±."; case "invalid_element": return `${t.origin} iÃ§in tanÄ±nmayan kÄ±ymet var.`; default: return "KÄ±ymet tanÄ±namadÄ±." } } }, "error$g"); function xm() { return { localeError: km() } } a(xm, "ota"); const Im = a(() => { const e = { string: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" }, file: { unit: "Ø¨Ø§ÛŒÙ¼Ø³", verb: "ÙˆÙ„Ø±ÙŠ" }, array: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" }, set: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "Ø¹Ø¯Ø¯"; case "object": { if (Array.isArray(t)) return "Ø§Ø±Û"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "ÙˆØ±ÙˆØ¯ÙŠ", email: "Ø¨Ø±ÛŒÚšÙ†Ø§Ù„ÛŒÚ©", url: "ÛŒÙˆ Ø¢Ø± Ø§Ù„", emoji: "Ø§ÛŒÙ…ÙˆØ¬ÙŠ", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "Ù†ÛŒÙ¼Ù‡ Ø§Ùˆ ÙˆØ®Øª", date: "Ù†ÛÙ¼Ù‡", time: "ÙˆØ®Øª", duration: "Ù…ÙˆØ¯Ù‡", ipv4: "Ø¯ IPv4 Ù¾ØªÙ‡", ipv6: "Ø¯ IPv6 Ù¾ØªÙ‡", cidrv4: "Ø¯ IPv4 Ø³Ø§Ø­Ù‡", cidrv6: "Ø¯ IPv6 Ø³Ø§Ø­Ù‡", base64: "base64-encoded Ù…ØªÙ†", base64url: "base64url-encoded Ù…ØªÙ†", json_string: "JSON Ù…ØªÙ†", e164: "Ø¯ E.164 Ø´Ù…ÛØ±Ù‡", jwt: "JWT", template_literal: "ÙˆØ±ÙˆØ¯ÙŠ" }; return t => { switch (t.code) { case "invalid_type": return `Ù†Ø§Ø³Ù… ÙˆØ±ÙˆØ¯ÙŠ: Ø¨Ø§ÛŒØ¯ ${t.expected} ÙˆØ§ÛŒ, Ù…Ú«Ø± ${r(t.input)} ØªØ±Ù„Ø§Ø³Ù‡ Ø´Ùˆ`; case "invalid_value": return t.values.length === 1 ? `Ù†Ø§Ø³Ù… ÙˆØ±ÙˆØ¯ÙŠ: Ø¨Ø§ÛŒØ¯ ${P(t.values[0])} ÙˆØ§ÛŒ` : `Ù†Ø§Ø³Ù… Ø§Ù†ØªØ®Ø§Ø¨: Ø¨Ø§ÛŒØ¯ ÛŒÙˆ Ù„Ù‡ ${$(t.values, "|")} Ú…Ø®Ù‡ ÙˆØ§ÛŒ`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Ú‰ÛŒØ± Ù„ÙˆÛŒ: ${t.origin ?? "Ø§Ø±Ø²ÚšØª"} Ø¨Ø§ÛŒØ¯ ${o}${t.maximum.toString()} ${s.unit ?? "Ø¹Ù†ØµØ±ÙˆÙ†Ù‡"} ÙˆÙ„Ø±ÙŠ` : `Ú‰ÛŒØ± Ù„ÙˆÛŒ: ${t.origin ?? "Ø§Ø±Ø²ÚšØª"} Ø¨Ø§ÛŒØ¯ ${o}${t.maximum.toString()} ÙˆÙŠ` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Ú‰ÛŒØ± Ú©ÙˆÚ†Ù†ÛŒ: ${t.origin} Ø¨Ø§ÛŒØ¯ ${o}${t.minimum.toString()} ${s.unit} ÙˆÙ„Ø±ÙŠ` : `Ú‰ÛŒØ± Ú©ÙˆÚ†Ù†ÛŒ: ${t.origin} Ø¨Ø§ÛŒØ¯ ${o}${t.minimum.toString()} ÙˆÙŠ` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ "${o.prefix}" Ø³Ø±Ù‡ Ù¾ÛŒÙ„ Ø´ÙŠ` : o.format === "ends_with" ? `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ "${o.suffix}" Ø³Ø±Ù‡ Ù¾Ø§ÛŒ ØªÙ‡ ÙˆØ±Ø³ÙŠÚ–ÙŠ` : o.format === "includes" ? `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ "${o.includes}" ÙˆÙ„Ø±ÙŠ` : o.format === "regex" ? `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ ${o.pattern} Ø³Ø±Ù‡ Ù…Ø·Ø§Ø¨Ù‚Øª ÙˆÙ„Ø±ÙŠ` : `${i[o.format] ?? t.format} Ù†Ø§Ø³Ù… Ø¯ÛŒ` } case "not_multiple_of": return `Ù†Ø§Ø³Ù… Ø¹Ø¯Ø¯: Ø¨Ø§ÛŒØ¯ Ø¯ ${t.divisor} Ù…Ø¶Ø±Ø¨ ÙˆÙŠ`; case "unrecognized_keys": return `Ù†Ø§Ø³Ù… ${t.keys.length > 1 ? "Ú©Ù„ÛŒÚ‰ÙˆÙ†Ù‡" : "Ú©Ù„ÛŒÚ‰"}: ${$(t.keys, ", ")}`; case "invalid_key": return `Ù†Ø§Ø³Ù… Ú©Ù„ÛŒÚ‰ Ù¾Ù‡ ${t.origin} Ú©Û`; case "invalid_union": return "Ù†Ø§Ø³Ù…Ù‡ ÙˆØ±ÙˆØ¯ÙŠ"; case "invalid_element": return `Ù†Ø§Ø³Ù… Ø¹Ù†ØµØ± Ù¾Ù‡ ${t.origin} Ú©Û`; default: return "Ù†Ø§Ø³Ù…Ù‡ ÙˆØ±ÙˆØ¯ÙŠ" } } }, "error$f"); function Sm() { return { localeError: Im() } } a(Sm, "ps"); const jm = a(() => { const e = { string: { unit: "znakÃ³w", verb: "mieÄ‡" }, file: { unit: "bajtÃ³w", verb: "mieÄ‡" }, array: { unit: "elementÃ³w", verb: "mieÄ‡" }, set: { unit: "elementÃ³w", verb: "mieÄ‡" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "liczba"; case "object": { if (Array.isArray(t)) return "tablica"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "wyraÅ¼enie", email: "adres email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i godzina w formacie ISO", date: "data w formacie ISO", time: "godzina w formacie ISO", duration: "czas trwania ISO", ipv4: "adres IPv4", ipv6: "adres IPv6", cidrv4: "zakres IPv4", cidrv6: "zakres IPv6", base64: "ciÄ…g znakÃ³w zakodowany w formacie base64", base64url: "ciÄ…g znakÃ³w zakodowany w formacie base64url", json_string: "ciÄ…g znakÃ³w w formacie JSON", e164: "liczba E.164", jwt: "JWT", template_literal: "wejÅ›cie" }; return t => { switch (t.code) { case "invalid_type": return `NieprawidÅ‚owe dane wejÅ›ciowe: oczekiwano ${t.expected}, otrzymano ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `NieprawidÅ‚owe dane wejÅ›ciowe: oczekiwano ${P(t.values[0])}` : `NieprawidÅ‚owa opcja: oczekiwano jednej z wartoÅ›ci ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Za duÅ¼a wartoÅ›Ä‡: oczekiwano, Å¼e ${t.origin ?? "wartoÅ›Ä‡"} bÄ™dzie mieÄ‡ ${o}${t.maximum.toString()} ${s.unit ?? "elementÃ³w"}` : `Zbyt duÅ¼(y/a/e): oczekiwano, Å¼e ${t.origin ?? "wartoÅ›Ä‡"} bÄ™dzie wynosiÄ‡ ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Za maÅ‚a wartoÅ›Ä‡: oczekiwano, Å¼e ${t.origin ?? "wartoÅ›Ä‡"} bÄ™dzie mieÄ‡ ${o}${t.minimum.toString()} ${s.unit ?? "elementÃ³w"}` : `Zbyt maÅ‚(y/a/e): oczekiwano, Å¼e ${t.origin ?? "wartoÅ›Ä‡"} bÄ™dzie wynosiÄ‡ ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi zaczynaÄ‡ siÄ™ od "${o.prefix}"` : o.format === "ends_with" ? `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi koÅ„czyÄ‡ siÄ™ na "${o.suffix}"` : o.format === "includes" ? `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi zawieraÄ‡ "${o.includes}"` : o.format === "regex" ? `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi odpowiadaÄ‡ wzorcowi ${o.pattern}` : `NieprawidÅ‚ow(y/a/e) ${i[o.format] ?? t.format}` } case "not_multiple_of": return `NieprawidÅ‚owa liczba: musi byÄ‡ wielokrotnoÅ›ciÄ… ${t.divisor}`; case "unrecognized_keys": return `Nierozpoznane klucze${t.keys.length > 1 ? "s" : ""}: ${$(t.keys, ", ")}`; case "invalid_key": return `NieprawidÅ‚owy klucz w ${t.origin}`; case "invalid_union": return "NieprawidÅ‚owe dane wejÅ›ciowe"; case "invalid_element": return `NieprawidÅ‚owa wartoÅ›Ä‡ w ${t.origin}`; default: return "NieprawidÅ‚owe dane wejÅ›ciowe" } } }, "error$e"); function zm() { return { localeError: jm() } } a(zm, "pl"); const Em = a(() => { const e = { string: { unit: "caracteres", verb: "ter" }, file: { unit: "bytes", verb: "ter" }, array: { unit: "itens", verb: "ter" }, set: { unit: "itens", verb: "ter" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "nÃºmero"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "nulo"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "padrÃ£o", email: "endereÃ§o de e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e hora ISO", date: "data ISO", time: "hora ISO", duration: "duraÃ§Ã£o ISO", ipv4: "endereÃ§o IPv4", ipv6: "endereÃ§o IPv6", cidrv4: "faixa de IPv4", cidrv6: "faixa de IPv6", base64: "texto codificado em base64", base64url: "URL codificada em base64", json_string: "texto JSON", e164: "nÃºmero E.164", jwt: "JWT", template_literal: "entrada" }; return t => { switch (t.code) { case "invalid_type": return `Tipo invÃ¡lido: esperado ${t.expected}, recebido ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Entrada invÃ¡lida: esperado ${P(t.values[0])}` : `OpÃ§Ã£o invÃ¡lida: esperada uma das ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Muito grande: esperado que ${t.origin ?? "valor"} tivesse ${o}${t.maximum.toString()} ${s.unit ?? "elementos"}` : `Muito grande: esperado que ${t.origin ?? "valor"} fosse ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Muito pequeno: esperado que ${t.origin} tivesse ${o}${t.minimum.toString()} ${s.unit}` : `Muito pequeno: esperado que ${t.origin} fosse ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Texto invÃ¡lido: deve comeÃ§ar com "${o.prefix}"` : o.format === "ends_with" ? `Texto invÃ¡lido: deve terminar com "${o.suffix}"` : o.format === "includes" ? `Texto invÃ¡lido: deve incluir "${o.includes}"` : o.format === "regex" ? `Texto invÃ¡lido: deve corresponder ao padrÃ£o ${o.pattern}` : `${i[o.format] ?? t.format} invÃ¡lido` } case "not_multiple_of": return `NÃºmero invÃ¡lido: deve ser mÃºltiplo de ${t.divisor}`; case "unrecognized_keys": return `Chave${t.keys.length > 1 ? "s" : ""} desconhecida${t.keys.length > 1 ? "s" : ""}: ${$(t.keys, ", ")}`; case "invalid_key": return `Chave invÃ¡lida em ${t.origin}`; case "invalid_union": return "Entrada invÃ¡lida"; case "invalid_element": return `Valor invÃ¡lido em ${t.origin}`; default: return "Campo invÃ¡lido" } } }, "error$d"); function Om() { return { localeError: Em() } } a(Om, "pt"); function Lc(e, n, r, i) { const t = Math.abs(e), o = t % 10, s = t % 100; return s >= 11 && s <= 19 ? i : o === 1 ? n : o >= 2 && o <= 4 ? r : i } a(Lc, "getRussianPlural"); const Nm = a(() => { const e = { string: { unit: { one: "ÑÐ¸Ð¼Ð²Ð¾Ð»", few: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°", many: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²" }, verb: "Ð¸Ð¼ÐµÑ‚ÑŒ" }, file: { unit: { one: "Ð±Ð°Ð¹Ñ‚", few: "Ð±Ð°Ð¹Ñ‚Ð°", many: "Ð±Ð°Ð¹Ñ‚" }, verb: "Ð¸Ð¼ÐµÑ‚ÑŒ" }, array: { unit: { one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚", few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°", many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²" }, verb: "Ð¸Ð¼ÐµÑ‚ÑŒ" }, set: { unit: { one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚", few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°", many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²" }, verb: "Ð¸Ð¼ÐµÑ‚ÑŒ" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "Ñ‡Ð¸ÑÐ»Ð¾"; case "object": { if (Array.isArray(t)) return "Ð¼Ð°ÑÑÐ¸Ð²"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "Ð²Ð²Ð¾Ð´", email: "email Ð°Ð´Ñ€ÐµÑ", url: "URL", emoji: "ÑÐ¼Ð¾Ð´Ð·Ð¸", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO Ð´Ð°Ñ‚Ð° Ð¸ Ð²Ñ€ÐµÐ¼Ñ", date: "ISO Ð´Ð°Ñ‚Ð°", time: "ISO Ð²Ñ€ÐµÐ¼Ñ", duration: "ISO Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ", ipv4: "IPv4 Ð°Ð´Ñ€ÐµÑ", ipv6: "IPv6 Ð°Ð´Ñ€ÐµÑ", cidrv4: "IPv4 Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½", cidrv6: "IPv6 Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½", base64: "ÑÑ‚Ñ€Ð¾ÐºÐ° Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ base64", base64url: "ÑÑ‚Ñ€Ð¾ÐºÐ° Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ base64url", json_string: "JSON ÑÑ‚Ñ€Ð¾ÐºÐ°", e164: "Ð½Ð¾Ð¼ÐµÑ€ E.164", jwt: "JWT", template_literal: "Ð²Ð²Ð¾Ð´" }; return t => { switch (t.code) { case "invalid_type": return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð²Ð¾Ð´: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ ${t.expected}, Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¾ ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð²Ð¾Ð´: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ ${P(t.values[0])}` : `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð´Ð½Ð¾ Ð¸Ð· ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); if (s) { const c = Number(t.maximum), u = Lc(c, s.unit.one, s.unit.few, s.unit.many); return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${t.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"} Ð±ÑƒÐ´ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ ${o}${t.maximum.toString()} ${u}` } return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${t.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"} Ð±ÑƒÐ´ÐµÑ‚ ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); if (s) { const c = Number(t.minimum), u = Lc(c, s.unit.one, s.unit.few, s.unit.many); return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${t.origin} Ð±ÑƒÐ´ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ ${o}${t.minimum.toString()} ${u}` } return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${t.origin} Ð±ÑƒÐ´ÐµÑ‚ ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° Ð½Ð°Ñ‡Ð¸Ð½Ð°Ñ‚ÑŒÑÑ Ñ "${o.prefix}"` : o.format === "ends_with" ? `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° Ð·Ð°ÐºÐ°Ð½Ñ‡Ð¸Ð²Ð°Ñ‚ÑŒÑÑ Ð½Ð° "${o.suffix}"` : o.format === "includes" ? `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ "${o.includes}"` : o.format === "regex" ? `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¾Ð²Ð°Ñ‚ÑŒ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${o.pattern}` : `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ ${i[o.format] ?? t.format}` } case "not_multiple_of": return `ÐÐµÐ²ÐµÑ€Ð½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾: Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±Ñ‹Ñ‚ÑŒ ÐºÑ€Ð°Ñ‚Ð½Ñ‹Ð¼ ${t.divisor}`; case "unrecognized_keys": return `ÐÐµÑ€Ð°ÑÐ¿Ð¾Ð·Ð½Ð°Ð½Ð½${t.keys.length > 1 ? "Ñ‹Ðµ" : "Ñ‹Ð¹"} ÐºÐ»ÑŽÑ‡${t.keys.length > 1 ? "Ð¸" : ""}: ${$(t.keys, ", ")}`; case "invalid_key": return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ ÐºÐ»ÑŽÑ‡ Ð² ${t.origin}`; case "invalid_union": return "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ"; case "invalid_element": return `ÐÐµÐ²ÐµÑ€Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð² ${t.origin}`; default: return "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ" } } }, "error$c"); function Tm() { return { localeError: Nm() } } a(Tm, "ru"); const Um = a(() => { const e = { string: { unit: "znakov", verb: "imeti" }, file: { unit: "bajtov", verb: "imeti" }, array: { unit: "elementov", verb: "imeti" }, set: { unit: "elementov", verb: "imeti" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "Å¡tevilo"; case "object": { if (Array.isArray(t)) return "tabela"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "vnos", email: "e-poÅ¡tni naslov", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum in Äas", date: "ISO datum", time: "ISO Äas", duration: "ISO trajanje", ipv4: "IPv4 naslov", ipv6: "IPv6 naslov", cidrv4: "obseg IPv4", cidrv6: "obseg IPv6", base64: "base64 kodiran niz", base64url: "base64url kodiran niz", json_string: "JSON niz", e164: "E.164 Å¡tevilka", jwt: "JWT", template_literal: "vnos" }; return t => { switch (t.code) { case "invalid_type": return `Neveljaven vnos: priÄakovano ${t.expected}, prejeto ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Neveljaven vnos: priÄakovano ${P(t.values[0])}` : `Neveljavna moÅ¾nost: priÄakovano eno izmed ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Preveliko: priÄakovano, da bo ${t.origin ?? "vrednost"} imelo ${o}${t.maximum.toString()} ${s.unit ?? "elementov"}` : `Preveliko: priÄakovano, da bo ${t.origin ?? "vrednost"} ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Premajhno: priÄakovano, da bo ${t.origin} imelo ${o}${t.minimum.toString()} ${s.unit}` : `Premajhno: priÄakovano, da bo ${t.origin} ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Neveljaven niz: mora se zaÄeti z "${o.prefix}"` : o.format === "ends_with" ? `Neveljaven niz: mora se konÄati z "${o.suffix}"` : o.format === "includes" ? `Neveljaven niz: mora vsebovati "${o.includes}"` : o.format === "regex" ? `Neveljaven niz: mora ustrezati vzorcu ${o.pattern}` : `Neveljaven ${i[o.format] ?? t.format}` } case "not_multiple_of": return `Neveljavno Å¡tevilo: mora biti veÄkratnik ${t.divisor}`; case "unrecognized_keys": return `Neprepoznan${t.keys.length > 1 ? "i kljuÄi" : " kljuÄ"}: ${$(t.keys, ", ")}`; case "invalid_key": return `Neveljaven kljuÄ v ${t.origin}`; case "invalid_union": return "Neveljaven vnos"; case "invalid_element": return `Neveljavna vrednost v ${t.origin}`; default: return "Neveljaven vnos" } } }, "error$b"); function Am() { return { localeError: Um() } } a(Am, "sl"); const Pm = a(() => { const e = { string: { unit: "tecken", verb: "att ha" }, file: { unit: "bytes", verb: "att ha" }, array: { unit: "objekt", verb: "att innehÃ¥lla" }, set: { unit: "objekt", verb: "att innehÃ¥lla" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "antal"; case "object": { if (Array.isArray(t)) return "lista"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "reguljÃ¤rt uttryck", email: "e-postadress", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datum och tid", date: "ISO-datum", time: "ISO-tid", duration: "ISO-varaktighet", ipv4: "IPv4-intervall", ipv6: "IPv6-intervall", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodad strÃ¤ng", base64url: "base64url-kodad strÃ¤ng", json_string: "JSON-strÃ¤ng", e164: "E.164-nummer", jwt: "JWT", template_literal: "mall-literal" }; return t => { switch (t.code) { case "invalid_type": return `Ogiltig inmatning: fÃ¶rvÃ¤ntat ${t.expected}, fick ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Ogiltig inmatning: fÃ¶rvÃ¤ntat ${P(t.values[0])}` : `Ogiltigt val: fÃ¶rvÃ¤ntade en av ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `FÃ¶r stor(t): fÃ¶rvÃ¤ntade ${t.origin ?? "vÃ¤rdet"} att ha ${o}${t.maximum.toString()} ${s.unit ?? "element"}` : `FÃ¶r stor(t): fÃ¶rvÃ¤ntat ${t.origin ?? "vÃ¤rdet"} att ha ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `FÃ¶r lite(t): fÃ¶rvÃ¤ntade ${t.origin ?? "vÃ¤rdet"} att ha ${o}${t.minimum.toString()} ${s.unit}` : `FÃ¶r lite(t): fÃ¶rvÃ¤ntade ${t.origin ?? "vÃ¤rdet"} att ha ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Ogiltig strÃ¤ng: mÃ¥ste bÃ¶rja med "${o.prefix}"` : o.format === "ends_with" ? `Ogiltig strÃ¤ng: mÃ¥ste sluta med "${o.suffix}"` : o.format === "includes" ? `Ogiltig strÃ¤ng: mÃ¥ste innehÃ¥lla "${o.includes}"` : o.format === "regex" ? `Ogiltig strÃ¤ng: mÃ¥ste matcha mÃ¶nstret "${o.pattern}"` : `Ogiltig(t) ${i[o.format] ?? t.format}` } case "not_multiple_of": return `Ogiltigt tal: mÃ¥ste vara en multipel av ${t.divisor}`; case "unrecognized_keys": return `${t.keys.length > 1 ? "OkÃ¤nda nycklar" : "OkÃ¤nd nyckel"}: ${$(t.keys, ", ")}`; case "invalid_key": return `Ogiltig nyckel i ${t.origin ?? "vÃ¤rdet"}`; case "invalid_union": return "Ogiltig input"; case "invalid_element": return `Ogiltigt vÃ¤rde i ${t.origin ?? "vÃ¤rdet"}`; default: return "Ogiltig input" } } }, "error$a"); function Dm() { return { localeError: Pm() } } a(Dm, "sv"); const Lm = a(() => { const e = { string: { unit: "à®Žà®´à¯à®¤à¯à®¤à¯à®•à¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" }, file: { unit: "à®ªà¯ˆà®Ÿà¯à®Ÿà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" }, array: { unit: "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" }, set: { unit: "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "à®Žà®£à¯ à®…à®²à¯à®²à®¾à®¤à®¤à¯" : "à®Žà®£à¯"; case "object": { if (Array.isArray(t)) return "à®…à®£à®¿"; if (t === null) return "à®µà¯†à®±à¯à®®à¯ˆ"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "à®‰à®³à¯à®³à¯€à®Ÿà¯", email: "à®®à®¿à®©à¯à®©à®žà¯à®šà®²à¯ à®®à¯à®•à®µà®°à®¿", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO à®¤à¯‡à®¤à®¿ à®¨à¯‡à®°à®®à¯", date: "ISO à®¤à¯‡à®¤à®¿", time: "ISO à®¨à¯‡à®°à®®à¯", duration: "ISO à®•à®¾à®² à®…à®³à®µà¯", ipv4: "IPv4 à®®à¯à®•à®µà®°à®¿", ipv6: "IPv6 à®®à¯à®•à®µà®°à®¿", cidrv4: "IPv4 à®µà®°à®®à¯à®ªà¯", cidrv6: "IPv6 à®µà®°à®®à¯à®ªà¯", base64: "base64-encoded à®šà®°à®®à¯", base64url: "base64url-encoded à®šà®°à®®à¯", json_string: "JSON à®šà®°à®®à¯", e164: "E.164 à®Žà®£à¯", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${t.expected}, à®ªà¯†à®±à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${P(t.values[0])}` : `à®¤à®µà®±à®¾à®© à®µà®¿à®°à¯à®ªà¯à®ªà®®à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${$(t.values, "|")} à®‡à®²à¯ à®’à®©à¯à®±à¯`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `à®®à®¿à®• à®ªà¯†à®°à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${t.origin ?? "à®®à®¤à®¿à®ªà¯à®ªà¯"} ${o}${t.maximum.toString()} ${s.unit ?? "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯"} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯` : `à®®à®¿à®• à®ªà¯†à®°à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${t.origin ?? "à®®à®¤à®¿à®ªà¯à®ªà¯"} ${o}${t.maximum.toString()} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `à®®à®¿à®•à®šà¯ à®šà®¿à®±à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${t.origin} ${o}${t.minimum.toString()} ${s.unit} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯` : `à®®à®¿à®•à®šà¯ à®šà®¿à®±à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${t.origin} ${o}${t.minimum.toString()} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${o.prefix}" à®‡à®²à¯ à®¤à¯Šà®Ÿà®™à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯` : o.format === "ends_with" ? `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${o.suffix}" à®‡à®²à¯ à®®à¯à®Ÿà®¿à®µà®Ÿà¯ˆà®¯ à®µà¯‡à®£à¯à®Ÿà¯à®®à¯` : o.format === "includes" ? `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${o.includes}" à® à®‰à®³à¯à®³à®Ÿà®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯` : o.format === "regex" ? `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: ${o.pattern} à®®à¯à®±à¯ˆà®ªà®¾à®Ÿà¯à®Ÿà¯à®Ÿà®©à¯ à®ªà¯Šà®°à¯à®¨à¯à®¤ à®µà¯‡à®£à¯à®Ÿà¯à®®à¯` : `à®¤à®µà®±à®¾à®© ${i[o.format] ?? t.format}` } case "not_multiple_of": return `à®¤à®µà®±à®¾à®© à®Žà®£à¯: ${t.divisor} à®‡à®©à¯ à®ªà®²à®®à®¾à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`; case "unrecognized_keys": return `à®…à®Ÿà¯ˆà®¯à®¾à®³à®®à¯ à®¤à¯†à®°à®¿à®¯à®¾à®¤ à®µà®¿à®šà¯ˆ${t.keys.length > 1 ? "à®•à®³à¯" : ""}: ${$(t.keys, ", ")}`; case "invalid_key": return `${t.origin} à®‡à®²à¯ à®¤à®µà®±à®¾à®© à®µà®¿à®šà¯ˆ`; case "invalid_union": return "à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯"; case "invalid_element": return `${t.origin} à®‡à®²à¯ à®¤à®µà®±à®¾à®© à®®à®¤à®¿à®ªà¯à®ªà¯`; default: return "à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯" } } }, "error$9"); function Rm() { return { localeError: Lm() } } a(Rm, "ta"); const Cm = a(() => { const e = { string: { unit: "à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" }, file: { unit: "à¹„à¸šà¸•à¹Œ", verb: "à¸„à¸§à¸£à¸¡à¸µ" }, array: { unit: "à¸£à¸²à¸¢à¸à¸²à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" }, set: { unit: "à¸£à¸²à¸¢à¸à¸²à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¸•à¸±à¸§à¹€à¸¥à¸‚ (NaN)" : "à¸•à¸±à¸§à¹€à¸¥à¸‚"; case "object": { if (Array.isArray(t)) return "à¸­à¸²à¸£à¹Œà¹€à¸£à¸¢à¹Œ (Array)"; if (t === null) return "à¹„à¸¡à¹ˆà¸¡à¸µà¸„à¹ˆà¸² (null)"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸›à¹‰à¸­à¸™", email: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆà¸­à¸µà¹€à¸¡à¸¥", url: "URL", emoji: "à¸­à¸´à¹‚à¸¡à¸ˆà¸´", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "à¸§à¸±à¸™à¸—à¸µà¹ˆà¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO", date: "à¸§à¸±à¸™à¸—à¸µà¹ˆà¹à¸šà¸š ISO", time: "à¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO", duration: "à¸Šà¹ˆà¸§à¸‡à¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO", ipv4: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ IPv4", ipv6: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ IPv6", cidrv4: "à¸Šà¹ˆà¸§à¸‡ IP à¹à¸šà¸š IPv4", cidrv6: "à¸Šà¹ˆà¸§à¸‡ IP à¹à¸šà¸š IPv6", base64: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š Base64", base64url: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š Base64 à¸ªà¸³à¸«à¸£à¸±à¸š URL", json_string: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š JSON", e164: "à¹€à¸šà¸­à¸£à¹Œà¹‚à¸—à¸£à¸¨à¸±à¸žà¸—à¹Œà¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡à¸›à¸£à¸°à¹€à¸—à¸¨ (E.164)", jwt: "à¹‚à¸—à¹€à¸„à¸™ JWT", template_literal: "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸›à¹‰à¸­à¸™" }; return t => { switch (t.code) { case "invalid_type": return `à¸›à¸£à¸°à¹€à¸ à¸—à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™ ${t.expected} à¹à¸•à¹ˆà¹„à¸”à¹‰à¸£à¸±à¸š ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `à¸„à¹ˆà¸²à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™ ${P(t.values[0])}` : `à¸•à¸±à¸§à¹€à¸¥à¸·à¸­à¸à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™à¸«à¸™à¸¶à¹ˆà¸‡à¹ƒà¸™ ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "à¹„à¸¡à¹ˆà¹€à¸à¸´à¸™" : "à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²", s = n(t.origin); return s ? `à¹€à¸à¸´à¸™à¸à¸³à¸«à¸™à¸”: ${t.origin ?? "à¸„à¹ˆà¸²"} à¸„à¸§à¸£à¸¡à¸µ${o} ${t.maximum.toString()} ${s.unit ?? "à¸£à¸²à¸¢à¸à¸²à¸£"}` : `à¹€à¸à¸´à¸™à¸à¸³à¸«à¸™à¸”: ${t.origin ?? "à¸„à¹ˆà¸²"} à¸„à¸§à¸£à¸¡à¸µ${o} ${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? "à¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢" : "à¸¡à¸²à¸à¸à¸§à¹ˆà¸²", s = n(t.origin); return s ? `à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²à¸à¸³à¸«à¸™à¸”: ${t.origin} à¸„à¸§à¸£à¸¡à¸µ${o} ${t.minimum.toString()} ${s.unit}` : `à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²à¸à¸³à¸«à¸™à¸”: ${t.origin} à¸„à¸§à¸£à¸¡à¸µ${o} ${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸‚à¸¶à¹‰à¸™à¸•à¹‰à¸™à¸”à¹‰à¸§à¸¢ "${o.prefix}"` : o.format === "ends_with" ? `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸¥à¸‡à¸—à¹‰à¸²à¸¢à¸”à¹‰à¸§à¸¢ "${o.suffix}"` : o.format === "includes" ? `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸¡à¸µ "${o.includes}" à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡` : o.format === "regex" ? `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸•à¹‰à¸­à¸‡à¸•à¸£à¸‡à¸à¸±à¸šà¸£à¸¹à¸›à¹à¸šà¸šà¸—à¸µà¹ˆà¸à¸³à¸«à¸™à¸” ${o.pattern}` : `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: ${i[o.format] ?? t.format}` } case "not_multiple_of": return `à¸•à¸±à¸§à¹€à¸¥à¸‚à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸•à¹‰à¸­à¸‡à¹€à¸›à¹‡à¸™à¸ˆà¸³à¸™à¸§à¸™à¸—à¸µà¹ˆà¸«à¸²à¸£à¸”à¹‰à¸§à¸¢ ${t.divisor} à¹„à¸”à¹‰à¸¥à¸‡à¸•à¸±à¸§`; case "unrecognized_keys": return `à¸žà¸šà¸„à¸µà¸¢à¹Œà¸—à¸µà¹ˆà¹„à¸¡à¹ˆà¸£à¸¹à¹‰à¸ˆà¸±à¸: ${$(t.keys, ", ")}`; case "invalid_key": return `à¸„à¸µà¸¢à¹Œà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¹ƒà¸™ ${t.origin}`; case "invalid_union": return "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¹„à¸¡à¹ˆà¸•à¸£à¸‡à¸à¸±à¸šà¸£à¸¹à¸›à¹à¸šà¸šà¸¢à¸¹à¹€à¸™à¸µà¸¢à¸™à¸—à¸µà¹ˆà¸à¸³à¸«à¸™à¸”à¹„à¸§à¹‰"; case "invalid_element": return `à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¹ƒà¸™ ${t.origin}`; default: return "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡" } } }, "error$8"); function Zm() { return { localeError: Cm() } } a(Zm, "th"); const Mm = a(e => { const n = typeof e; switch (n) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": { if (Array.isArray(e)) return "array"; if (e === null) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name } }return n }, "parsedType"), Fm = a(() => { const e = { string: { unit: "karakter", verb: "olmalÄ±" }, file: { unit: "bayt", verb: "olmalÄ±" }, array: { unit: "Ã¶ÄŸe", verb: "olmalÄ±" }, set: { unit: "Ã¶ÄŸe", verb: "olmalÄ±" } }; function n(i) { return e[i] ?? null } a(n, "getSizing"); const r = { regex: "girdi", email: "e-posta adresi", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO tarih ve saat", date: "ISO tarih", time: "ISO saat", duration: "ISO sÃ¼re", ipv4: "IPv4 adresi", ipv6: "IPv6 adresi", cidrv4: "IPv4 aralÄ±ÄŸÄ±", cidrv6: "IPv6 aralÄ±ÄŸÄ±", base64: "base64 ile ÅŸifrelenmiÅŸ metin", base64url: "base64url ile ÅŸifrelenmiÅŸ metin", json_string: "JSON dizesi", e164: "E.164 sayÄ±sÄ±", jwt: "JWT", template_literal: "Åžablon dizesi" }; return i => { switch (i.code) { case "invalid_type": return `GeÃ§ersiz deÄŸer: beklenen ${i.expected}, alÄ±nan ${Mm(i.input)}`; case "invalid_value": return i.values.length === 1 ? `GeÃ§ersiz deÄŸer: beklenen ${P(i.values[0])}` : `GeÃ§ersiz seÃ§enek: aÅŸaÄŸÄ±dakilerden biri olmalÄ±: ${$(i.values, "|")}`; case "too_big": { const t = i.inclusive ? "<=" : "<", o = n(i.origin); return o ? `Ã‡ok bÃ¼yÃ¼k: beklenen ${i.origin ?? "deÄŸer"} ${t}${i.maximum.toString()} ${o.unit ?? "Ã¶ÄŸe"}` : `Ã‡ok bÃ¼yÃ¼k: beklenen ${i.origin ?? "deÄŸer"} ${t}${i.maximum.toString()}` } case "too_small": { const t = i.inclusive ? ">=" : ">", o = n(i.origin); return o ? `Ã‡ok kÃ¼Ã§Ã¼k: beklenen ${i.origin} ${t}${i.minimum.toString()} ${o.unit}` : `Ã‡ok kÃ¼Ã§Ã¼k: beklenen ${i.origin} ${t}${i.minimum.toString()}` } case "invalid_format": { const t = i; return t.format === "starts_with" ? `GeÃ§ersiz metin: "${t.prefix}" ile baÅŸlamalÄ±` : t.format === "ends_with" ? `GeÃ§ersiz metin: "${t.suffix}" ile bitmeli` : t.format === "includes" ? `GeÃ§ersiz metin: "${t.includes}" iÃ§ermeli` : t.format === "regex" ? `GeÃ§ersiz metin: ${t.pattern} desenine uymalÄ±` : `GeÃ§ersiz ${r[t.format] ?? i.format}` } case "not_multiple_of": return `GeÃ§ersiz sayÄ±: ${i.divisor} ile tam bÃ¶lÃ¼nebilmeli`; case "unrecognized_keys": return `TanÄ±nmayan anahtar${i.keys.length > 1 ? "lar" : ""}: ${$(i.keys, ", ")}`; case "invalid_key": return `${i.origin} iÃ§inde geÃ§ersiz anahtar`; case "invalid_union": return "GeÃ§ersiz deÄŸer"; case "invalid_element": return `${i.origin} iÃ§inde geÃ§ersiz deÄŸer`; default: return "GeÃ§ersiz deÄŸer" } } }, "error$7"); function Bm() { return { localeError: Fm() } } a(Bm, "tr"); const Wm = a(() => { const e = { string: { unit: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" }, file: { unit: "Ð±Ð°Ð¹Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" }, array: { unit: "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" }, set: { unit: "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "Ñ‡Ð¸ÑÐ»Ð¾"; case "object": { if (Array.isArray(t)) return "Ð¼Ð°ÑÐ¸Ð²"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–", email: "Ð°Ð´Ñ€ÐµÑÐ° ÐµÐ»ÐµÐºÑ‚Ñ€Ð¾Ð½Ð½Ð¾Ñ— Ð¿Ð¾ÑˆÑ‚Ð¸", url: "URL", emoji: "ÐµÐ¼Ð¾Ð´Ð·Ñ–", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "Ð´Ð°Ñ‚Ð° Ñ‚Ð° Ñ‡Ð°Ñ ISO", date: "Ð´Ð°Ñ‚Ð° ISO", time: "Ñ‡Ð°Ñ ISO", duration: "Ñ‚Ñ€Ð¸Ð²Ð°Ð»Ñ–ÑÑ‚ÑŒ ISO", ipv4: "Ð°Ð´Ñ€ÐµÑÐ° IPv4", ipv6: "Ð°Ð´Ñ€ÐµÑÐ° IPv6", cidrv4: "Ð´Ñ–Ð°Ð¿Ð°Ð·Ð¾Ð½ IPv4", cidrv6: "Ð´Ñ–Ð°Ð¿Ð°Ð·Ð¾Ð½ IPv6", base64: "Ñ€ÑÐ´Ð¾Ðº Ñƒ ÐºÐ¾Ð´ÑƒÐ²Ð°Ð½Ð½Ñ– base64", base64url: "Ñ€ÑÐ´Ð¾Ðº Ñƒ ÐºÐ¾Ð´ÑƒÐ²Ð°Ð½Ð½Ñ– base64url", json_string: "Ñ€ÑÐ´Ð¾Ðº JSON", e164: "Ð½Ð¾Ð¼ÐµÑ€ E.164", jwt: "JWT", template_literal: "Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–" }; return t => { switch (t.code) { case "invalid_type": return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ ${t.expected}, Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¾ ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ ${P(t.values[0])}` : `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð° Ð¾Ð¿Ñ†Ñ–Ñ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ Ð¾Ð´Ð½Ðµ Ð· ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð²ÐµÐ»Ð¸ÐºÐµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${t.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ"} ${s.verb} ${o}${t.maximum.toString()} ${s.unit ?? "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²"}` : `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð²ÐµÐ»Ð¸ÐºÐµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${t.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ"} Ð±ÑƒÐ´Ðµ ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð¼Ð°Ð»Ðµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${t.origin} ${s.verb} ${o}${t.minimum.toString()} ${s.unit}` : `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð¼Ð°Ð»Ðµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${t.origin} Ð±ÑƒÐ´Ðµ ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð¿Ð¾Ñ‡Ð¸Ð½Ð°Ñ‚Ð¸ÑÑ Ð· "${o.prefix}"` : o.format === "ends_with" ? `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð·Ð°ÐºÑ–Ð½Ñ‡ÑƒÐ²Ð°Ñ‚Ð¸ÑÑ Ð½Ð° "${o.suffix}"` : o.format === "includes" ? `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð¼Ñ–ÑÑ‚Ð¸Ñ‚Ð¸ "${o.includes}"` : o.format === "regex" ? `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð²Ñ–Ð´Ð¿Ð¾Ð²Ñ–Ð´Ð°Ñ‚Ð¸ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${o.pattern}` : `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ ${i[o.format] ?? t.format}` } case "not_multiple_of": return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ðµ Ñ‡Ð¸ÑÐ»Ð¾: Ð¿Ð¾Ð²Ð¸Ð½Ð½Ð¾ Ð±ÑƒÑ‚Ð¸ ÐºÑ€Ð°Ñ‚Ð½Ð¸Ð¼ ${t.divisor}`; case "unrecognized_keys": return `ÐÐµÑ€Ð¾Ð·Ð¿Ñ–Ð·Ð½Ð°Ð½Ð¸Ð¹ ÐºÐ»ÑŽÑ‡${t.keys.length > 1 ? "Ñ–" : ""}: ${$(t.keys, ", ")}`; case "invalid_key": return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ ÐºÐ»ÑŽÑ‡ Ñƒ ${t.origin}`; case "invalid_union": return "ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–"; case "invalid_element": return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ Ñƒ ${t.origin}`; default: return "ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–" } } }, "error$6"); function Rc() { return { localeError: Wm() } } a(Rc, "uk"); function Gm() { return Rc() } a(Gm, "ua"); const Vm = a(() => { const e = { string: { unit: "Ø­Ø±ÙˆÙ", verb: "ÛÙˆÙ†Ø§" }, file: { unit: "Ø¨Ø§Ø¦Ù¹Ø³", verb: "ÛÙˆÙ†Ø§" }, array: { unit: "Ø¢Ø¦Ù¹Ù…Ø²", verb: "ÛÙˆÙ†Ø§" }, set: { unit: "Ø¢Ø¦Ù¹Ù…Ø²", verb: "ÛÙˆÙ†Ø§" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "Ù†Ù…Ø¨Ø±"; case "object": { if (Array.isArray(t)) return "Ø¢Ø±Û’"; if (t === null) return "Ù†Ù„"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "Ø§Ù† Ù¾Ù¹", email: "Ø§ÛŒ Ù…ÛŒÙ„ Ø§ÛŒÚˆØ±ÛŒØ³", url: "ÛŒÙˆ Ø¢Ø± Ø§ÛŒÙ„", emoji: "Ø§ÛŒÙ…ÙˆØ¬ÛŒ", uuid: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ", uuidv4: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ ÙˆÛŒ 4", uuidv6: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ ÙˆÛŒ 6", nanoid: "Ù†ÛŒÙ†Ùˆ Ø¢Ø¦ÛŒ ÚˆÛŒ", guid: "Ø¬ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ", cuid: "Ø³ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ", cuid2: "Ø³ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ 2", ulid: "ÛŒÙˆ Ø§ÛŒÙ„ Ø¢Ø¦ÛŒ ÚˆÛŒ", xid: "Ø§ÛŒÚ©Ø³ Ø¢Ø¦ÛŒ ÚˆÛŒ", ksuid: "Ú©Û’ Ø§ÛŒØ³ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ", datetime: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ÚˆÛŒÙ¹ Ù¹Ø§Ø¦Ù…", date: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ØªØ§Ø±ÛŒØ®", time: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ÙˆÙ‚Øª", duration: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ Ù…Ø¯Øª", ipv4: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 4 Ø§ÛŒÚˆØ±ÛŒØ³", ipv6: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 6 Ø§ÛŒÚˆØ±ÛŒØ³", cidrv4: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 4 Ø±ÛŒÙ†Ø¬", cidrv6: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 6 Ø±ÛŒÙ†Ø¬", base64: "Ø¨ÛŒØ³ 64 Ø§Ù† Ú©ÙˆÚˆÚˆ Ø³Ù¹Ø±Ù†Ú¯", base64url: "Ø¨ÛŒØ³ 64 ÛŒÙˆ Ø¢Ø± Ø§ÛŒÙ„ Ø§Ù† Ú©ÙˆÚˆÚˆ Ø³Ù¹Ø±Ù†Ú¯", json_string: "Ø¬Û’ Ø§ÛŒØ³ Ø§Ùˆ Ø§ÛŒÙ† Ø³Ù¹Ø±Ù†Ú¯", e164: "Ø§ÛŒ 164 Ù†Ù…Ø¨Ø±", jwt: "Ø¬Û’ ÚˆØ¨Ù„ÛŒÙˆ Ù¹ÛŒ", template_literal: "Ø§Ù† Ù¾Ù¹" }; return t => { switch (t.code) { case "invalid_type": return `ØºÙ„Ø· Ø§Ù† Ù¾Ù¹: ${t.expected} Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§ØŒ ${r(t.input)} Ù…ÙˆØµÙˆÙ„ ÛÙˆØ§`; case "invalid_value": return t.values.length === 1 ? `ØºÙ„Ø· Ø§Ù† Ù¾Ù¹: ${P(t.values[0])} Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§` : `ØºÙ„Ø· Ø¢Ù¾Ø´Ù†: ${$(t.values, "|")} Ù…ÛŒÚº Ø³Û’ Ø§ÛŒÚ© Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `Ø¨ÛØª Ø¨Ú‘Ø§: ${t.origin ?? "ÙˆÛŒÙ„ÛŒÙˆ"} Ú©Û’ ${o}${t.maximum.toString()} ${s.unit ?? "Ø¹Ù†Ø§ØµØ±"} ÛÙˆÙ†Û’ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Û’` : `Ø¨ÛØª Ø¨Ú‘Ø§: ${t.origin ?? "ÙˆÛŒÙ„ÛŒÙˆ"} Ú©Ø§ ${o}${t.maximum.toString()} ÛÙˆÙ†Ø§ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `Ø¨ÛØª Ú†Ú¾ÙˆÙ¹Ø§: ${t.origin} Ú©Û’ ${o}${t.minimum.toString()} ${s.unit} ÛÙˆÙ†Û’ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Û’` : `Ø¨ÛØª Ú†Ú¾ÙˆÙ¹Ø§: ${t.origin} Ú©Ø§ ${o}${t.minimum.toString()} ÛÙˆÙ†Ø§ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${o.prefix}" Ø³Û’ Ø´Ø±ÙˆØ¹ ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’` : o.format === "ends_with" ? `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${o.suffix}" Ù¾Ø± Ø®ØªÙ… ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’` : o.format === "includes" ? `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${o.includes}" Ø´Ø§Ù…Ù„ ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’` : o.format === "regex" ? `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: Ù¾ÛŒÙ¹Ø±Ù† ${o.pattern} Ø³Û’ Ù…ÛŒÚ† ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’` : `ØºÙ„Ø· ${i[o.format] ?? t.format}` } case "not_multiple_of": return `ØºÙ„Ø· Ù†Ù…Ø¨Ø±: ${t.divisor} Ú©Ø§ Ù…Ø¶Ø§Ø¹Ù ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`; case "unrecognized_keys": return `ØºÛŒØ± ØªØ³Ù„ÛŒÙ… Ø´Ø¯Û Ú©ÛŒ${t.keys.length > 1 ? "Ø²" : ""}: ${$(t.keys, "ØŒ ")}`; case "invalid_key": return `${t.origin} Ù…ÛŒÚº ØºÙ„Ø· Ú©ÛŒ`; case "invalid_union": return "ØºÙ„Ø· Ø§Ù† Ù¾Ù¹"; case "invalid_element": return `${t.origin} Ù…ÛŒÚº ØºÙ„Ø· ÙˆÛŒÙ„ÛŒÙˆ`; default: return "ØºÙ„Ø· Ø§Ù† Ù¾Ù¹" } } }, "error$5"); function Jm() { return { localeError: Vm() } } a(Jm, "ur"); const Hm = a(() => { const e = { string: { unit: "kÃ½ tá»±", verb: "cÃ³" }, file: { unit: "byte", verb: "cÃ³" }, array: { unit: "pháº§n tá»­", verb: "cÃ³" }, set: { unit: "pháº§n tá»­", verb: "cÃ³" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "sá»‘"; case "object": { if (Array.isArray(t)) return "máº£ng"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "Ä‘áº§u vÃ o", email: "Ä‘á»‹a chá»‰ email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ngÃ y giá» ISO", date: "ngÃ y ISO", time: "giá» ISO", duration: "khoáº£ng thá»i gian ISO", ipv4: "Ä‘á»‹a chá»‰ IPv4", ipv6: "Ä‘á»‹a chá»‰ IPv6", cidrv4: "dáº£i IPv4", cidrv6: "dáº£i IPv6", base64: "chuá»—i mÃ£ hÃ³a base64", base64url: "chuá»—i mÃ£ hÃ³a base64url", json_string: "chuá»—i JSON", e164: "sá»‘ E.164", jwt: "JWT", template_literal: "Ä‘áº§u vÃ o" }; return t => { switch (t.code) { case "invalid_type": return `Äáº§u vÃ o khÃ´ng há»£p lá»‡: mong Ä‘á»£i ${t.expected}, nháº­n Ä‘Æ°á»£c ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Äáº§u vÃ o khÃ´ng há»£p lá»‡: mong Ä‘á»£i ${P(t.values[0])}` : `TÃ¹y chá»n khÃ´ng há»£p lá»‡: mong Ä‘á»£i má»™t trong cÃ¡c giÃ¡ trá»‹ ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `QuÃ¡ lá»›n: mong Ä‘á»£i ${t.origin ?? "giÃ¡ trá»‹"} ${s.verb} ${o}${t.maximum.toString()} ${s.unit ?? "pháº§n tá»­"}` : `QuÃ¡ lá»›n: mong Ä‘á»£i ${t.origin ?? "giÃ¡ trá»‹"} ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `QuÃ¡ nhá»: mong Ä‘á»£i ${t.origin} ${s.verb} ${o}${t.minimum.toString()} ${s.unit}` : `QuÃ¡ nhá»: mong Ä‘á»£i ${t.origin} ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i báº¯t Ä‘áº§u báº±ng "${o.prefix}"` : o.format === "ends_with" ? `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i káº¿t thÃºc báº±ng "${o.suffix}"` : o.format === "includes" ? `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i bao gá»“m "${o.includes}"` : o.format === "regex" ? `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i khá»›p vá»›i máº«u ${o.pattern}` : `${i[o.format] ?? t.format} khÃ´ng há»£p lá»‡` } case "not_multiple_of": return `Sá»‘ khÃ´ng há»£p lá»‡: pháº£i lÃ  bá»™i sá»‘ cá»§a ${t.divisor}`; case "unrecognized_keys": return `KhÃ³a khÃ´ng Ä‘Æ°á»£c nháº­n dáº¡ng: ${$(t.keys, ", ")}`; case "invalid_key": return `KhÃ³a khÃ´ng há»£p lá»‡ trong ${t.origin}`; case "invalid_union": return "Äáº§u vÃ o khÃ´ng há»£p lá»‡"; case "invalid_element": return `GiÃ¡ trá»‹ khÃ´ng há»£p lá»‡ trong ${t.origin}`; default: return "Äáº§u vÃ o khÃ´ng há»£p lá»‡" } } }, "error$4"); function Km() { return { localeError: Hm() } } a(Km, "vi"); const qm = a(() => { const e = { string: { unit: "å­—ç¬¦", verb: "åŒ…å«" }, file: { unit: "å­—èŠ‚", verb: "åŒ…å«" }, array: { unit: "é¡¹", verb: "åŒ…å«" }, set: { unit: "é¡¹", verb: "åŒ…å«" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "éžæ•°å­—(NaN)" : "æ•°å­—"; case "object": { if (Array.isArray(t)) return "æ•°ç»„"; if (t === null) return "ç©ºå€¼(null)"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "è¾“å…¥", email: "ç”µå­é‚®ä»¶", url: "URL", emoji: "è¡¨æƒ…ç¬¦å·", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISOæ—¥æœŸæ—¶é—´", date: "ISOæ—¥æœŸ", time: "ISOæ—¶é—´", duration: "ISOæ—¶é•¿", ipv4: "IPv4åœ°å€", ipv6: "IPv6åœ°å€", cidrv4: "IPv4ç½‘æ®µ", cidrv6: "IPv6ç½‘æ®µ", base64: "base64ç¼–ç å­—ç¬¦ä¸²", base64url: "base64urlç¼–ç å­—ç¬¦ä¸²", json_string: "JSONå­—ç¬¦ä¸²", e164: "E.164å·ç ", jwt: "JWT", template_literal: "è¾“å…¥" }; return t => { switch (t.code) { case "invalid_type": return `æ— æ•ˆè¾“å…¥ï¼šæœŸæœ› ${t.expected}ï¼Œå®žé™…æŽ¥æ”¶ ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `æ— æ•ˆè¾“å…¥ï¼šæœŸæœ› ${P(t.values[0])}` : `æ— æ•ˆé€‰é¡¹ï¼šæœŸæœ›ä»¥ä¸‹ä¹‹ä¸€ ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `æ•°å€¼è¿‡å¤§ï¼šæœŸæœ› ${t.origin ?? "å€¼"} ${o}${t.maximum.toString()} ${s.unit ?? "ä¸ªå…ƒç´ "}` : `æ•°å€¼è¿‡å¤§ï¼šæœŸæœ› ${t.origin ?? "å€¼"} ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `æ•°å€¼è¿‡å°ï¼šæœŸæœ› ${t.origin} ${o}${t.minimum.toString()} ${s.unit}` : `æ•°å€¼è¿‡å°ï¼šæœŸæœ› ${t.origin} ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»ä»¥ "${o.prefix}" å¼€å¤´` : o.format === "ends_with" ? `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»ä»¥ "${o.suffix}" ç»“å°¾` : o.format === "includes" ? `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»åŒ…å« "${o.includes}"` : o.format === "regex" ? `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»æ»¡è¶³æ­£åˆ™è¡¨è¾¾å¼ ${o.pattern}` : `æ— æ•ˆ${i[o.format] ?? t.format}` } case "not_multiple_of": return `æ— æ•ˆæ•°å­—ï¼šå¿…é¡»æ˜¯ ${t.divisor} çš„å€æ•°`; case "unrecognized_keys": return `å‡ºçŽ°æœªçŸ¥çš„é”®(key): ${$(t.keys, ", ")}`; case "invalid_key": return `${t.origin} ä¸­çš„é”®(key)æ— æ•ˆ`; case "invalid_union": return "æ— æ•ˆè¾“å…¥"; case "invalid_element": return `${t.origin} ä¸­åŒ…å«æ— æ•ˆå€¼(value)`; default: return "æ— æ•ˆè¾“å…¥" } } }, "error$3"); function Ym() { return { localeError: qm() } } a(Ym, "zhCN$1"); const Xm = a(() => { const e = { string: { unit: "å­—å…ƒ", verb: "æ“æœ‰" }, file: { unit: "ä½å…ƒçµ„", verb: "æ“æœ‰" }, array: { unit: "é …ç›®", verb: "æ“æœ‰" }, set: { unit: "é …ç›®", verb: "æ“æœ‰" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "è¼¸å…¥", email: "éƒµä»¶åœ°å€", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO æ—¥æœŸæ™‚é–“", date: "ISO æ—¥æœŸ", time: "ISO æ™‚é–“", duration: "ISO æœŸé–“", ipv4: "IPv4 ä½å€", ipv6: "IPv6 ä½å€", cidrv4: "IPv4 ç¯„åœ", cidrv6: "IPv6 ç¯„åœ", base64: "base64 ç·¨ç¢¼å­—ä¸²", base64url: "base64url ç·¨ç¢¼å­—ä¸²", json_string: "JSON å­—ä¸²", e164: "E.164 æ•¸å€¼", jwt: "JWT", template_literal: "è¼¸å…¥" }; return t => { switch (t.code) { case "invalid_type": return `ç„¡æ•ˆçš„è¼¸å…¥å€¼ï¼šé æœŸç‚º ${t.expected}ï¼Œä½†æ”¶åˆ° ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `ç„¡æ•ˆçš„è¼¸å…¥å€¼ï¼šé æœŸç‚º ${P(t.values[0])}` : `ç„¡æ•ˆçš„é¸é …ï¼šé æœŸç‚ºä»¥ä¸‹å…¶ä¸­ä¹‹ä¸€ ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `æ•¸å€¼éŽå¤§ï¼šé æœŸ ${t.origin ?? "å€¼"} æ‡‰ç‚º ${o}${t.maximum.toString()} ${s.unit ?? "å€‹å…ƒç´ "}` : `æ•¸å€¼éŽå¤§ï¼šé æœŸ ${t.origin ?? "å€¼"} æ‡‰ç‚º ${o}${t.maximum.toString()}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `æ•¸å€¼éŽå°ï¼šé æœŸ ${t.origin} æ‡‰ç‚º ${o}${t.minimum.toString()} ${s.unit}` : `æ•¸å€¼éŽå°ï¼šé æœŸ ${t.origin} æ‡‰ç‚º ${o}${t.minimum.toString()}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆä»¥ "${o.prefix}" é–‹é ­` : o.format === "ends_with" ? `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆä»¥ "${o.suffix}" çµå°¾` : o.format === "includes" ? `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆåŒ…å« "${o.includes}"` : o.format === "regex" ? `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆç¬¦åˆæ ¼å¼ ${o.pattern}` : `ç„¡æ•ˆçš„ ${i[o.format] ?? t.format}` } case "not_multiple_of": return `ç„¡æ•ˆçš„æ•¸å­—ï¼šå¿…é ˆç‚º ${t.divisor} çš„å€æ•¸`; case "unrecognized_keys": return `ç„¡æ³•è­˜åˆ¥çš„éµå€¼${t.keys.length > 1 ? "å€‘" : ""}ï¼š${$(t.keys, "ã€")}`; case "invalid_key": return `${t.origin} ä¸­æœ‰ç„¡æ•ˆçš„éµå€¼`; case "invalid_union": return "ç„¡æ•ˆçš„è¼¸å…¥å€¼"; case "invalid_element": return `${t.origin} ä¸­æœ‰ç„¡æ•ˆçš„å€¼`; default: return "ç„¡æ•ˆçš„è¼¸å…¥å€¼" } } }, "error$2"); function Qm() { return { localeError: Xm() } } a(Qm, "zhTW"); const ep = a(() => { const e = { string: { unit: "Ã mi", verb: "nÃ­" }, file: { unit: "bytes", verb: "nÃ­" }, array: { unit: "nkan", verb: "nÃ­" }, set: { unit: "nkan", verb: "nÃ­" } }; function n(t) { return e[t] ?? null } a(n, "getSizing"); const r = a(t => { const o = typeof t; switch (o) { case "number": return Number.isNaN(t) ? "NaN" : "ná»ÌmbÃ "; case "object": { if (Array.isArray(t)) return "akopá»"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return o }, "parsedType"), i = { regex: "áº¹Ì€rá» Ã¬bÃ¡wá»lÃ©", email: "Ã dÃ­ráº¹ÌsÃ¬ Ã¬máº¹ÌlÃ¬", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "Ã kÃ³kÃ² ISO", date: "á»já»Ì ISO", time: "Ã kÃ³kÃ² ISO", duration: "Ã kÃ³kÃ² tÃ³ pÃ© ISO", ipv4: "Ã dÃ­ráº¹ÌsÃ¬ IPv4", ipv6: "Ã dÃ­ráº¹ÌsÃ¬ IPv6", cidrv4: "Ã gbÃ¨gbÃ¨ IPv4", cidrv6: "Ã gbÃ¨gbÃ¨ IPv6", base64: "á»Ì€rá»Ì€ tÃ­ a ká»Ì nÃ­ base64", base64url: "á»Ì€rá»Ì€ base64url", json_string: "á»Ì€rá»Ì€ JSON", e164: "ná»ÌmbÃ  E.164", jwt: "JWT", template_literal: "áº¹Ì€rá» Ã¬bÃ¡wá»lÃ©" }; return t => { switch (t.code) { case "invalid_type": return `ÃŒbÃ¡wá»lÃ© aá¹£Ã¬á¹£e: a nÃ­ lÃ¡ti fi ${t.expected}, Ã má»Ì€ a rÃ­ ${r(t.input)}`; case "invalid_value": return t.values.length === 1 ? `ÃŒbÃ¡wá»lÃ© aá¹£Ã¬á¹£e: a nÃ­ lÃ¡ti fi ${P(t.values[0])}` : `Ã€á¹£Ã yÃ n aá¹£Ã¬á¹£e: yan á»Ì€kan lÃ¡ra ${$(t.values, "|")}`; case "too_big": { const o = t.inclusive ? "<=" : "<", s = n(t.origin); return s ? `TÃ³ pá»Ì€ jÃ¹: a nÃ­ lÃ¡ti jáº¹Ì pÃ© ${t.origin ?? "iye"} ${s.verb} ${o}${t.maximum} ${s.unit}` : `TÃ³ pá»Ì€ jÃ¹: a nÃ­ lÃ¡ti jáº¹Ì ${o}${t.maximum}` } case "too_small": { const o = t.inclusive ? ">=" : ">", s = n(t.origin); return s ? `KÃ©rÃ© ju: a nÃ­ lÃ¡ti jáº¹Ì pÃ© ${t.origin} ${s.verb} ${o}${t.minimum} ${s.unit}` : `KÃ©rÃ© ju: a nÃ­ lÃ¡ti jáº¹Ì ${o}${t.minimum}` } case "invalid_format": { const o = t; return o.format === "starts_with" ? `á»ŒÌ€rá»Ì€ aá¹£Ã¬á¹£e: gbá»Ìdá»Ì€ báº¹Ì€ráº¹Ì€ páº¹Ì€lÃº "${o.prefix}"` : o.format === "ends_with" ? `á»ŒÌ€rá»Ì€ aá¹£Ã¬á¹£e: gbá»Ìdá»Ì€ parÃ­ páº¹Ì€lÃº "${o.suffix}"` : o.format === "includes" ? `á»ŒÌ€rá»Ì€ aá¹£Ã¬á¹£e: gbá»Ìdá»Ì€ nÃ­ "${o.includes}"` : o.format === "regex" ? `á»ŒÌ€rá»Ì€ aá¹£Ã¬á¹£e: gbá»Ìdá»Ì€ bÃ¡ Ã páº¹áº¹ráº¹ mu ${o.pattern}` : `Aá¹£Ã¬á¹£e: ${i[o.format] ?? t.format}` } case "not_multiple_of": return `Ná»ÌmbÃ  aá¹£Ã¬á¹£e: gbá»Ìdá»Ì€ jáº¹Ì Ã¨yÃ  pÃ­pÃ­n ti ${t.divisor}`; case "unrecognized_keys": return `Bá»tÃ¬nÃ¬ Ã Ã¬má»Ì€: ${$(t.keys, ", ")}`; case "invalid_key": return `Bá»tÃ¬nÃ¬ aá¹£Ã¬á¹£e nÃ­nÃº ${t.origin}`; case "invalid_union": return "ÃŒbÃ¡wá»lÃ© aá¹£Ã¬á¹£e"; case "invalid_element": return `Iye aá¹£Ã¬á¹£e nÃ­nÃº ${t.origin}`; default: return "ÃŒbÃ¡wá»lÃ© aá¹£Ã¬á¹£e" } } }, "error$1"); function tp() { return { localeError: ep() } } a(tp, "yo"); const Cc = Object.freeze(Object.defineProperty({ __proto__: null, ar: hf, az: vf, be: bf, bg: wf, ca: xf, cs: Sf, da: zf, de: Of, en: Ac, eo: Pf, es: Lf, fa: Cf, fi: Mf, fr: Bf, frCA: Gf, he: Jf, hu: Kf, id: Yf, is: em, it: nm, ja: im, ka: sm, kh: um, km: Pc, ko: dm, lt: pm, mk: gm, ms: _m, nl: ym, no: wm, ota: xm, pl: zm, ps: Sm, pt: Om, ru: Tm, sl: Am, sv: Dm, ta: Rm, th: Zm, tr: Bm, ua: Gm, uk: Rc, ur: Jm, vi: Km, yo: tp, zhCN: Ym, zhTW: Qm }, Symbol.toStringTag, { value: "Module" })), Zc = Symbol("ZodOutput"), Mc = Symbol("ZodInput"), go = class go { constructor() { this._map = new WeakMap, this._idmap = new Map } add(n, ...r) { const i = r[0]; if (this._map.set(n, i), i && typeof i == "object" && "id" in i) { if (this._idmap.has(i.id)) throw new Error(`ID ${i.id} already exists in the registry`); this._idmap.set(i.id, n) } return this } clear() { return this._map = new WeakMap, this._idmap = new Map, this } remove(n) { const r = this._map.get(n); return r && typeof r == "object" && "id" in r && this._idmap.delete(r.id), this._map.delete(n), this } get(n) { const r = n._zod.parent; if (r) { const i = { ...this.get(r) ?? {} }; delete i.id; const t = { ...i, ...this._map.get(n) }; return Object.keys(t).length ? t : void 0 } return this._map.get(n) } has(n) { return this._map.has(n) } }; a(go, "$ZodRegistry"); let tn = go; function Pr() { return new tn } a(Pr, "registry"); const ft = Pr(); function Fc(e, n) { return new e({ type: "string", ..._(n) }) } a(Fc, "_string"); function Bc(e, n) { return new e({ type: "string", coerce: !0, ..._(n) }) } a(Bc, "_coercedString"); function Dr(e, n) { return new e({ type: "string", format: "email", check: "string_format", abort: !1, ..._(n) }) } a(Dr, "_email"); function Pn(e, n) { return new e({ type: "string", format: "guid", check: "string_format", abort: !1, ..._(n) }) } a(Pn, "_guid"); function Lr(e, n) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, ..._(n) }) } a(Lr, "_uuid"); function Rr(e, n) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v4", ..._(n) }) } a(Rr, "_uuidv4"); function Cr(e, n) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v6", ..._(n) }) } a(Cr, "_uuidv6"); function Zr(e, n) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v7", ..._(n) }) } a(Zr, "_uuidv7"); function Dn(e, n) { return new e({ type: "string", format: "url", check: "string_format", abort: !1, ..._(n) }) } a(Dn, "_url"); function Mr(e, n) { return new e({ type: "string", format: "emoji", check: "string_format", abort: !1, ..._(n) }) } a(Mr, "_emoji"); function Fr(e, n) { return new e({ type: "string", format: "nanoid", check: "string_format", abort: !1, ..._(n) }) } a(Fr, "_nanoid"); function Br(e, n) { return new e({ type: "string", format: "cuid", check: "string_format", abort: !1, ..._(n) }) } a(Br, "_cuid"); function Wr(e, n) { return new e({ type: "string", format: "cuid2", check: "string_format", abort: !1, ..._(n) }) } a(Wr, "_cuid2"); function Gr(e, n) { return new e({ type: "string", format: "ulid", check: "string_format", abort: !1, ..._(n) }) } a(Gr, "_ulid"); function Vr(e, n) { return new e({ type: "string", format: "xid", check: "string_format", abort: !1, ..._(n) }) } a(Vr, "_xid"); function Jr(e, n) { return new e({ type: "string", format: "ksuid", check: "string_format", abort: !1, ..._(n) }) } a(Jr, "_ksuid"); function Hr(e, n) { return new e({ type: "string", format: "ipv4", check: "string_format", abort: !1, ..._(n) }) } a(Hr, "_ipv4"); function Kr(e, n) { return new e({ type: "string", format: "ipv6", check: "string_format", abort: !1, ..._(n) }) } a(Kr, "_ipv6"); function qr(e, n) { return new e({ type: "string", format: "cidrv4", check: "string_format", abort: !1, ..._(n) }) } a(qr, "_cidrv4"); function Yr(e, n) { return new e({ type: "string", format: "cidrv6", check: "string_format", abort: !1, ..._(n) }) } a(Yr, "_cidrv6"); function Xr(e, n) { return new e({ type: "string", format: "base64", check: "string_format", abort: !1, ..._(n) }) } a(Xr, "_base64"); function Qr(e, n) { return new e({ type: "string", format: "base64url", check: "string_format", abort: !1, ..._(n) }) } a(Qr, "_base64url"); function ei(e, n) { return new e({ type: "string", format: "e164", check: "string_format", abort: !1, ..._(n) }) } a(ei, "_e164"); function ti(e, n) { return new e({ type: "string", format: "jwt", check: "string_format", abort: !1, ..._(n) }) } a(ti, "_jwt"); const Wc = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 }; function Gc(e, n) { return new e({ type: "string", format: "datetime", check: "string_format", offset: !1, local: !1, precision: null, ..._(n) }) } a(Gc, "_isoDateTime"); function Vc(e, n) { return new e({ type: "string", format: "date", check: "string_format", ..._(n) }) } a(Vc, "_isoDate"); function Jc(e, n) { return new e({ type: "string", format: "time", check: "string_format", precision: null, ..._(n) }) } a(Jc, "_isoTime"); function Hc(e, n) { return new e({ type: "string", format: "duration", check: "string_format", ..._(n) }) } a(Hc, "_isoDuration"); function Kc(e, n) { return new e({ type: "number", checks: [], ..._(n) }) } a(Kc, "_number"); function qc(e, n) { return new e({ type: "number", coerce: !0, checks: [], ..._(n) }) } a(qc, "_coercedNumber"); function Yc(e, n) { return new e({ type: "number", check: "number_format", abort: !1, format: "safeint", ..._(n) }) } a(Yc, "_int"); function Xc(e, n) { return new e({ type: "number", check: "number_format", abort: !1, format: "float32", ..._(n) }) } a(Xc, "_float32"); function Qc(e, n) { return new e({ type: "number", check: "number_format", abort: !1, format: "float64", ..._(n) }) } a(Qc, "_float64"); function eu(e, n) { return new e({ type: "number", check: "number_format", abort: !1, format: "int32", ..._(n) }) } a(eu, "_int32"); function tu(e, n) { return new e({ type: "number", check: "number_format", abort: !1, format: "uint32", ..._(n) }) } a(tu, "_uint32"); function nu(e, n) { return new e({ type: "boolean", ..._(n) }) } a(nu, "_boolean"); function ru(e, n) { return new e({ type: "boolean", coerce: !0, ..._(n) }) } a(ru, "_coercedBoolean"); function iu(e, n) { return new e({ type: "bigint", ..._(n) }) } a(iu, "_bigint"); function ou(e, n) { return new e({ type: "bigint", coerce: !0, ..._(n) }) } a(ou, "_coercedBigint"); function au(e, n) { return new e({ type: "bigint", check: "bigint_format", abort: !1, format: "int64", ..._(n) }) } a(au, "_int64"); function su(e, n) { return new e({ type: "bigint", check: "bigint_format", abort: !1, format: "uint64", ..._(n) }) } a(su, "_uint64"); function cu(e, n) { return new e({ type: "symbol", ..._(n) }) } a(cu, "_symbol"); function uu(e, n) { return new e({ type: "undefined", ..._(n) }) } a(uu, "_undefined$1"); function lu(e, n) { return new e({ type: "null", ..._(n) }) } a(lu, "_null$1"); function du(e) { return new e({ type: "any" }) } a(du, "_any"); function fu(e) { return new e({ type: "unknown" }) } a(fu, "_unknown"); function mu(e, n) { return new e({ type: "never", ..._(n) }) } a(mu, "_never"); function pu(e, n) { return new e({ type: "void", ..._(n) }) } a(pu, "_void$1"); function hu(e, n) { return new e({ type: "date", ..._(n) }) } a(hu, "_date"); function gu(e, n) { return new e({ type: "date", coerce: !0, ..._(n) }) } a(gu, "_coercedDate"); function vu(e, n) { return new e({ type: "nan", ..._(n) }) } a(vu, "_nan"); function mt(e, n) { return new Ir({ check: "less_than", ..._(n), value: e, inclusive: !1 }) } a(mt, "_lt"); function Ee(e, n) { return new Ir({ check: "less_than", ..._(n), value: e, inclusive: !0 }) } a(Ee, "_lte"); function pt(e, n) { return new Sr({ check: "greater_than", ..._(n), value: e, inclusive: !1 }) } a(pt, "_gt"); function _e(e, n) { return new Sr({ check: "greater_than", ..._(n), value: e, inclusive: !0 }) } a(_e, "_gte"); function _u(e) { return pt(0, e) } a(_u, "_positive"); function bu(e) { return mt(0, e) } a(bu, "_negative"); function yu(e) { return Ee(0, e) } a(yu, "_nonpositive"); function $u(e) { return _e(0, e) } a($u, "_nonnegative"); function nn(e, n) { return new Va({ check: "multiple_of", ..._(n), value: e }) } a(nn, "_multipleOf"); function Ln(e, n) { return new Ka({ check: "max_size", ..._(n), maximum: e }) } a(Ln, "_maxSize"); function rn(e, n) { return new qa({ check: "min_size", ..._(n), minimum: e }) } a(rn, "_minSize"); function ni(e, n) { return new Ya({ check: "size_equals", ..._(n), size: e }) } a(ni, "_size"); function Rn(e, n) { return new Xa({ check: "max_length", ..._(n), maximum: e }) } a(Rn, "_maxLength"); function Nt(e, n) { return new Qa({ check: "min_length", ..._(n), minimum: e }) } a(Nt, "_minLength"); function Cn(e, n) { return new es({ check: "length_equals", ..._(n), length: e }) } a(Cn, "_length"); function ri(e, n) { return new ts({ check: "string_format", format: "regex", ..._(n), pattern: e }) } a(ri, "_regex"); function ii(e) { return new ns({ check: "string_format", format: "lowercase", ..._(e) }) } a(ii, "_lowercase"); function oi(e) { return new rs({ check: "string_format", format: "uppercase", ..._(e) }) } a(oi, "_uppercase"); function ai(e, n) { return new is({ check: "string_format", format: "includes", ..._(n), includes: e }) } a(ai, "_includes"); function si(e, n) { return new os({ check: "string_format", format: "starts_with", ..._(n), prefix: e }) } a(si, "_startsWith"); function ci(e, n) { return new as({ check: "string_format", format: "ends_with", ..._(n), suffix: e }) } a(ci, "_endsWith"); function wu(e, n, r) { return new cs({ check: "property", property: e, schema: n, ..._(r) }) } a(wu, "_property"); function ui(e, n) { return new us({ check: "mime_type", mime: e, ..._(n) }) } a(ui, "_mime"); function ht(e) { return new ls({ check: "overwrite", tx: e }) } a(ht, "_overwrite"); function li(e) { return ht(n => n.normalize(e)) } a(li, "_normalize"); function di() { return ht(e => e.trim()) } a(di, "_trim"); function fi() { return ht(e => e.toLowerCase()) } a(fi, "_toLowerCase"); function mi() { return ht(e => e.toUpperCase()) } a(mi, "_toUpperCase"); function ku(e, n, r) { return new e({ type: "array", element: n, ..._(r) }) } a(ku, "_array"); function np(e, n, r) { return new e({ type: "union", options: n, ..._(r) }) } a(np, "_union"); function rp(e, n, r, i) { return new e({ type: "union", options: r, discriminator: n, ..._(i) }) } a(rp, "_discriminatedUnion"); function ip(e, n, r) { return new e({ type: "intersection", left: n, right: r }) } a(ip, "_intersection"); function op(e, n, r, i) { const t = r instanceof D, o = t ? i : r, s = t ? r : null; return new e({ type: "tuple", items: n, rest: s, ..._(o) }) } a(op, "_tuple"); function ap(e, n, r, i) { return new e({ type: "record", keyType: n, valueType: r, ..._(i) }) } a(ap, "_record"); function sp(e, n, r, i) { return new e({ type: "map", keyType: n, valueType: r, ..._(i) }) } a(sp, "_map"); function cp(e, n, r) { return new e({ type: "set", valueType: n, ..._(r) }) } a(cp, "_set"); function up(e, n, r) { const i = Array.isArray(n) ? Object.fromEntries(n.map(t => [t, t])) : n; return new e({ type: "enum", entries: i, ..._(r) }) } a(up, "_enum$1"); function lp(e, n, r) { return new e({ type: "enum", entries: n, ..._(r) }) } a(lp, "_nativeEnum"); function dp(e, n, r) { return new e({ type: "literal", values: Array.isArray(n) ? n : [n], ..._(r) }) } a(dp, "_literal"); function xu(e, n) { return new e({ type: "file", ..._(n) }) } a(xu, "_file"); function fp(e, n) { return new e({ type: "transform", transform: n }) } a(fp, "_transform"); function mp(e, n) { return new e({ type: "optional", innerType: n }) } a(mp, "_optional"); function pp(e, n) { return new e({ type: "nullable", innerType: n }) } a(pp, "_nullable"); function hp(e, n, r) { return new e({ type: "default", innerType: n, get defaultValue() { return typeof r == "function" ? r() : In(r) } }) } a(hp, "_default$1"); function gp(e, n, r) { return new e({ type: "nonoptional", innerType: n, ..._(r) }) } a(gp, "_nonoptional"); function vp(e, n) { return new e({ type: "success", innerType: n }) } a(vp, "_success"); function _p(e, n, r) { return new e({ type: "catch", innerType: n, catchValue: typeof r == "function" ? r : () => r }) } a(_p, "_catch$1"); function bp(e, n, r) { return new e({ type: "pipe", in: n, out: r }) } a(bp, "_pipe"); function yp(e, n) { return new e({ type: "readonly", innerType: n }) } a(yp, "_readonly"); function $p(e, n, r) { return new e({ type: "template_literal", parts: n, ..._(r) }) } a($p, "_templateLiteral"); function wp(e, n) { return new e({ type: "lazy", getter: n }) } a(wp, "_lazy"); function kp(e, n) { return new e({ type: "promise", innerType: n }) } a(kp, "_promise"); function Iu(e, n, r) { const i = _(r); return i.abort ?? (i.abort = !0), new e({ type: "custom", check: "custom", fn: n, ...i }) } a(Iu, "_custom"); function Su(e, n, r) { return new e({ type: "custom", check: "custom", fn: n, ..._(r) }) } a(Su, "_refine"); function ju(e) { const n = zu(r => (r.addIssue = i => { if (typeof i == "string") r.issues.push(Et(i, r.value, n._zod.def)); else { const t = i; t.fatal && (t.continue = !1), t.code ?? (t.code = "custom"), t.input ?? (t.input = r.value), t.inst ?? (t.inst = n), t.continue ?? (t.continue = !n._zod.def.abort), r.issues.push(Et(t)) } }, e(r.value, r))); return n } a(ju, "_superRefine"); function zu(e, n) { const r = new ne({ check: "custom", ..._(n) }); return r._zod.check = e, r } a(zu, "_check"); function Eu(e, n) { const r = _(n); let i = r.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], t = r.falsy ?? ["false", "0", "no", "off", "n", "disabled"]; r.case !== "sensitive" && (i = i.map(v => typeof v == "string" ? v.toLowerCase() : v), t = t.map(v => typeof v == "string" ? v.toLowerCase() : v)); const o = new Set(i), s = new Set(t), c = e.Codec ?? Ar, u = e.Boolean ?? Er, p = e.String ?? Xt, m = new p({ type: "string", error: r.error }), f = new u({ type: "boolean", error: r.error }), b = new c({ type: "pipe", in: m, out: f, transform: a(((v, h) => { let y = v; return r.case !== "sensitive" && (y = y.toLowerCase()), o.has(y) ? !0 : s.has(y) ? !1 : (h.issues.push({ code: "invalid_value", expected: "stringbool", values: [...o, ...s], input: h.value, inst: b, continue: !1 }), {}) }), "transform"), reverseTransform: a(((v, h) => v === !0 ? i[0] || "true" : t[0] || "false"), "reverseTransform"), error: r.error }); return b } a(Eu, "_stringbool"); function on(e, n, r, i = {}) { const t = _(i), o = { ..._(i), check: "string_format", type: "string", format: n, fn: typeof r == "function" ? r : c => r.test(c), ...t }; return r instanceof RegExp && (o.pattern = r), new e(o) } a(on, "_stringFormat"); const vo = class vo {
    constructor(n) { this.counter = 0, this.metadataRegistry = n?.metadata ?? ft, this.target = n?.target ?? "draft-2020-12", this.unrepresentable = n?.unrepresentable ?? "throw", this.override = n?.override ?? (() => { }), this.io = n?.io ?? "output", this.seen = new Map } process(n, r = { path: [], schemaPath: [] }) { var i; const t = n._zod.def, o = { guid: "uuid", url: "uri", datetime: "date-time", json_string: "json-string", regex: "" }, s = this.seen.get(n); if (s) return s.count++, r.schemaPath.includes(n) && (s.cycle = r.path), s.schema; const c = { schema: {}, count: 1, cycle: void 0, path: r.path }; this.seen.set(n, c); const u = n._zod.toJSONSchema?.(); if (u) c.schema = u; else { const f = { ...r, schemaPath: [...r.schemaPath, n], path: r.path }, b = n._zod.parent; if (b) c.ref = b, this.process(b, f), this.seen.get(b).isParent = !0; else { const v = c.schema; switch (t.type) { case "string": { const h = v; h.type = "string"; const { minimum: y, maximum: w, format: j, patterns: A, contentEncoding: z } = n._zod.bag; if (typeof y == "number" && (h.minLength = y), typeof w == "number" && (h.maxLength = w), j && (h.format = o[j] ?? j, h.format === "" && delete h.format), z && (h.contentEncoding = z), A && A.size > 0) { const I = [...A]; I.length === 1 ? h.pattern = I[0].source : I.length > 1 && (c.schema.allOf = [...I.map(M => ({ ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {}, pattern: M.source }))]) } break } case "number": { const h = v, { minimum: y, maximum: w, format: j, multipleOf: A, exclusiveMaximum: z, exclusiveMinimum: I } = n._zod.bag; typeof j == "string" && j.includes("int") ? h.type = "integer" : h.type = "number", typeof I == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (h.minimum = I, h.exclusiveMinimum = !0) : h.exclusiveMinimum = I), typeof y == "number" && (h.minimum = y, typeof I == "number" && this.target !== "draft-4" && (I >= y ? delete h.minimum : delete h.exclusiveMinimum)), typeof z == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (h.maximum = z, h.exclusiveMaximum = !0) : h.exclusiveMaximum = z), typeof w == "number" && (h.maximum = w, typeof z == "number" && this.target !== "draft-4" && (z <= w ? delete h.maximum : delete h.exclusiveMaximum)), typeof A == "number" && (h.multipleOf = A); break } case "boolean": { const h = v; h.type = "boolean"; break } case "bigint": { if (this.unrepresentable === "throw") throw new Error("BigInt cannot be represented in JSON Schema"); break } case "symbol": { if (this.unrepresentable === "throw") throw new Error("Symbols cannot be represented in JSON Schema"); break } case "null": { this.target === "openapi-3.0" ? (v.type = "string", v.nullable = !0, v.enum = [null]) : v.type = "null"; break } case "any": break; case "unknown": break; case "undefined": { if (this.unrepresentable === "throw") throw new Error("Undefined cannot be represented in JSON Schema"); break } case "void": { if (this.unrepresentable === "throw") throw new Error("Void cannot be represented in JSON Schema"); break } case "never": { v.not = {}; break } case "date": { if (this.unrepresentable === "throw") throw new Error("Date cannot be represented in JSON Schema"); break } case "array": { const h = v, { minimum: y, maximum: w } = n._zod.bag; typeof y == "number" && (h.minItems = y), typeof w == "number" && (h.maxItems = w), h.type = "array", h.items = this.process(t.element, { ...f, path: [...f.path, "items"] }); break } case "object": { const h = v; h.type = "object", h.properties = {}; const y = t.shape; for (const A in y) h.properties[A] = this.process(y[A], { ...f, path: [...f.path, "properties", A] }); const w = new Set(Object.keys(y)), j = new Set([...w].filter(A => { const z = t.shape[A]._zod; return this.io === "input" ? z.optin === void 0 : z.optout === void 0 })); j.size > 0 && (h.required = Array.from(j)), t.catchall?._zod.def.type === "never" ? h.additionalProperties = !1 : t.catchall ? t.catchall && (h.additionalProperties = this.process(t.catchall, { ...f, path: [...f.path, "additionalProperties"] })) : this.io === "output" && (h.additionalProperties = !1); break } case "union": { const h = v, y = t.options.map((w, j) => this.process(w, { ...f, path: [...f.path, "anyOf", j] })); h.anyOf = y; break } case "intersection": { const h = v, y = this.process(t.left, { ...f, path: [...f.path, "allOf", 0] }), w = this.process(t.right, { ...f, path: [...f.path, "allOf", 1] }), j = a(z => "allOf" in z && Object.keys(z).length === 1, "isSimpleIntersection"), A = [...j(y) ? y.allOf : [y], ...j(w) ? w.allOf : [w]]; h.allOf = A; break } case "tuple": { const h = v; h.type = "array"; const y = this.target === "draft-2020-12" ? "prefixItems" : "items", w = this.target === "draft-2020-12" || this.target === "openapi-3.0" ? "items" : "additionalItems", j = t.items.map((M, Ye) => this.process(M, { ...f, path: [...f.path, y, Ye] })), A = t.rest ? this.process(t.rest, { ...f, path: [...f.path, w, ...this.target === "openapi-3.0" ? [t.items.length] : []] }) : null; this.target === "draft-2020-12" ? (h.prefixItems = j, A && (h.items = A)) : this.target === "openapi-3.0" ? (h.items = { anyOf: j }, A && h.items.anyOf.push(A), h.minItems = j.length, A || (h.maxItems = j.length)) : (h.items = j, A && (h.additionalItems = A)); const { minimum: z, maximum: I } = n._zod.bag; typeof z == "number" && (h.minItems = z), typeof I == "number" && (h.maxItems = I); break } case "record": { const h = v; h.type = "object", (this.target === "draft-7" || this.target === "draft-2020-12") && (h.propertyNames = this.process(t.keyType, { ...f, path: [...f.path, "propertyNames"] })), h.additionalProperties = this.process(t.valueType, { ...f, path: [...f.path, "additionalProperties"] }); break } case "map": { if (this.unrepresentable === "throw") throw new Error("Map cannot be represented in JSON Schema"); break } case "set": { if (this.unrepresentable === "throw") throw new Error("Set cannot be represented in JSON Schema"); break } case "enum": { const h = v, y = or(t.entries); y.every(w => typeof w == "number") && (h.type = "number"), y.every(w => typeof w == "string") && (h.type = "string"), h.enum = y; break } case "literal": { const h = v, y = []; for (const w of t.values) if (w === void 0) { if (this.unrepresentable === "throw") throw new Error("Literal `undefined` cannot be represented in JSON Schema") } else if (typeof w == "bigint") { if (this.unrepresentable === "throw") throw new Error("BigInt literals cannot be represented in JSON Schema"); y.push(Number(w)) } else y.push(w); if (y.length !== 0) if (y.length === 1) { const w = y[0]; h.type = w === null ? "null" : typeof w, this.target === "draft-4" || this.target === "openapi-3.0" ? h.enum = [w] : h.const = w } else y.every(w => typeof w == "number") && (h.type = "number"), y.every(w => typeof w == "string") && (h.type = "string"), y.every(w => typeof w == "boolean") && (h.type = "string"), y.every(w => w === null) && (h.type = "null"), h.enum = y; break } case "file": { const h = v, y = { type: "string", format: "binary", contentEncoding: "binary" }, { minimum: w, maximum: j, mime: A } = n._zod.bag; w !== void 0 && (y.minLength = w), j !== void 0 && (y.maxLength = j), A ? A.length === 1 ? (y.contentMediaType = A[0], Object.assign(h, y)) : h.anyOf = A.map(z => ({ ...y, contentMediaType: z })) : Object.assign(h, y); break } case "transform": { if (this.unrepresentable === "throw") throw new Error("Transforms cannot be represented in JSON Schema"); break } case "nullable": { const h = this.process(t.innerType, f); this.target === "openapi-3.0" ? (c.ref = t.innerType, v.nullable = !0) : v.anyOf = [h, { type: "null" }]; break } case "nonoptional": { this.process(t.innerType, f), c.ref = t.innerType; break } case "success": { const h = v; h.type = "boolean"; break } case "default": { this.process(t.innerType, f), c.ref = t.innerType, v.default = JSON.parse(JSON.stringify(t.defaultValue)); break } case "prefault": { this.process(t.innerType, f), c.ref = t.innerType, this.io === "input" && (v._prefault = JSON.parse(JSON.stringify(t.defaultValue))); break } case "catch": { this.process(t.innerType, f), c.ref = t.innerType; let h; try { h = t.catchValue(void 0) } catch { throw new Error("Dynamic catch values are not supported in JSON Schema") } v.default = h; break } case "nan": { if (this.unrepresentable === "throw") throw new Error("NaN cannot be represented in JSON Schema"); break } case "template_literal": { const h = v, y = n._zod.pattern; if (!y) throw new Error("Pattern not found in template literal"); h.type = "string", h.pattern = y.source; break } case "pipe": { const h = this.io === "input" ? t.in._zod.def.type === "transform" ? t.out : t.in : t.out; this.process(h, f), c.ref = h; break } case "readonly": { this.process(t.innerType, f), c.ref = t.innerType, v.readOnly = !0; break } case "promise": { this.process(t.innerType, f), c.ref = t.innerType; break } case "optional": { this.process(t.innerType, f), c.ref = t.innerType; break } case "lazy": { const h = n._zod.innerType; this.process(h, f), c.ref = h; break } case "custom": { if (this.unrepresentable === "throw") throw new Error("Custom types cannot be represented in JSON Schema"); break } case "function": { if (this.unrepresentable === "throw") throw new Error("Function types cannot be represented in JSON Schema"); break } } } } const p = this.metadataRegistry.get(n); return p && Object.assign(c.schema, p), this.io === "input" && ce(n) && (delete c.schema.examples, delete c.schema.default), this.io === "input" && c.schema._prefault && ((i = c.schema).default ?? (i.default = c.schema._prefault)), delete c.schema._prefault, this.seen.get(n).schema } emit(n, r) {
      const i = { cycles: r?.cycles ?? "ref", reused: r?.reused ?? "inline", external: r?.external ?? void 0 }, t = this.seen.get(n); if (!t) throw new Error("Unprocessed schema. This is a bug in Zod."); const o = a(m => { const f = this.target === "draft-2020-12" ? "$defs" : "definitions"; if (i.external) { const y = i.external.registry.get(m[0])?.id, w = i.external.uri ?? (A => A); if (y) return { ref: w(y) }; const j = m[1].defId ?? m[1].schema.id ?? `schema${this.counter++}`; return m[1].defId = j, { defId: j, ref: `${w("__shared")}#/${f}/${j}` } } if (m[1] === t) return { ref: "#" }; const v = `#/${f}/`, h = m[1].schema.id ?? `__schema${this.counter++}`; return { defId: h, ref: v + h } }, "makeURI"), s = a(m => { if (m[1].schema.$ref) return; const f = m[1], { ref: b, defId: v } = o(m); f.def = { ...f.schema }, v && (f.defId = v); const h = f.schema; for (const y in h) delete h[y]; h.$ref = b }, "extractToDef"); if (i.cycles === "throw") for (const m of this.seen.entries()) {
        const f = m[1]; if (f.cycle) throw new Error(`Cycle detected: #/${f.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`)  
      } for (const m of this.seen.entries()) { const f = m[1]; if (n === m[0]) { s(m); continue } if (i.external) { const v = i.external.registry.get(m[0])?.id; if (n !== m[0] && v) { s(m); continue } } if (this.metadataRegistry.get(m[0])?.id) { s(m); continue } if (f.cycle) { s(m); continue } if (f.count > 1 && i.reused === "ref") { s(m); continue } } const c = a((m, f) => { const b = this.seen.get(m), v = b.def ?? b.schema, h = { ...v }; if (b.ref === null) return; const y = b.ref; if (b.ref = null, y) { c(y, f); const w = this.seen.get(y).schema; w.$ref && (f.target === "draft-7" || f.target === "draft-4" || f.target === "openapi-3.0") ? (v.allOf = v.allOf ?? [], v.allOf.push(w)) : (Object.assign(v, w), Object.assign(v, h)) } b.isParent || this.override({ zodSchema: m, jsonSchema: v, path: b.path ?? [] }) }, "flattenRef"); for (const m of [...this.seen.entries()].reverse()) c(m[0], { target: this.target }); const u = {}; if (this.target === "draft-2020-12" ? u.$schema = "https://json-schema.org/draft/2020-12/schema" : this.target === "draft-7" ? u.$schema = "http://json-schema.org/draft-07/schema#" : this.target === "draft-4" ? u.$schema = "http://json-schema.org/draft-04/schema#" : this.target === "openapi-3.0" || console.warn(`Invalid target: ${this.target}`), i.external?.uri) { const m = i.external.registry.get(n)?.id; if (!m) throw new Error("Schema is missing an `id` property"); u.$id = i.external.uri(m) } Object.assign(u, t.def); const p = i.external?.defs ?? {}; for (const m of this.seen.entries()) { const f = m[1]; f.def && f.defId && (p[f.defId] = f.def) } i.external || Object.keys(p).length > 0 && (this.target === "draft-2020-12" ? u.$defs = p : u.definitions = p); try { return JSON.parse(JSON.stringify(u)) } catch { throw new Error("Error converting schema to JSON.") }
    }
  }; a(vo, "JSONSchemaGenerator"); let an = vo; function pi(e, n) { if (e instanceof tn) { const i = new an(n), t = {}; for (const c of e._idmap.entries()) { const [u, p] = c; i.process(p) } const o = {}, s = { registry: e, uri: n?.uri, defs: t }; for (const c of e._idmap.entries()) { const [u, p] = c; o[u] = i.emit(p, { ...n, external: s }) } if (Object.keys(t).length > 0) { const c = i.target === "draft-2020-12" ? "$defs" : "definitions"; o.__shared = { [c]: t } } return { schemas: o } } const r = new an(n); return r.process(e), r.emit(e, n) } a(pi, "toJSONSchema"); function ce(e, n) { const r = n ?? { seen: new Set }; if (r.seen.has(e)) return !1; r.seen.add(e); const t = e._zod.def; switch (t.type) { case "string": case "number": case "bigint": case "boolean": case "date": case "symbol": case "undefined": case "null": case "any": case "unknown": case "never": case "void": case "literal": case "enum": case "nan": case "file": case "template_literal": return !1; case "array": return ce(t.element, r); case "object": { for (const o in t.shape) if (ce(t.shape[o], r)) return !0; return !1 } case "union": { for (const o of t.options) if (ce(o, r)) return !0; return !1 } case "intersection": return ce(t.left, r) || ce(t.right, r); case "tuple": { for (const o of t.items) if (ce(o, r)) return !0; return !!(t.rest && ce(t.rest, r)) } case "record": return ce(t.keyType, r) || ce(t.valueType, r); case "map": return ce(t.keyType, r) || ce(t.valueType, r); case "set": return ce(t.valueType, r); case "promise": case "optional": case "nonoptional": case "nullable": case "readonly": return ce(t.innerType, r); case "lazy": return ce(t.getter(), r); case "default": return ce(t.innerType, r); case "prefault": return ce(t.innerType, r); case "custom": return !1; case "transform": return !0; case "pipe": return ce(t.in, r) || ce(t.out, r); case "success": return !1; case "catch": return !1; case "function": return !1 }throw new Error(`Unknown schema type: ${t.type}`) } a(ce, "isTransforming"); const xp = Object.freeze(Object.defineProperty({ __proto__: null, $ZodAny: Bs, $ZodArray: Ks, $ZodAsyncError: We, $ZodBase64: Ns, $ZodBase64URL: Us, $ZodBigInt: Or, $ZodBigIntFormat: Cs, $ZodBoolean: Er, $ZodCIDRv4: Es, $ZodCIDRv6: Os, $ZodCUID: _s, $ZodCUID2: bs, $ZodCatch: wc, $ZodCheck: ne, $ZodCheckBigIntFormat: Ha, $ZodCheckEndsWith: as, $ZodCheckGreaterThan: Sr, $ZodCheckIncludes: is, $ZodCheckLengthEquals: es, $ZodCheckLessThan: Ir, $ZodCheckLowerCase: ns, $ZodCheckMaxLength: Xa, $ZodCheckMaxSize: Ka, $ZodCheckMimeType: us, $ZodCheckMinLength: Qa, $ZodCheckMinSize: qa, $ZodCheckMultipleOf: Va, $ZodCheckNumberFormat: Ja, $ZodCheckOverwrite: ls, $ZodCheckProperty: cs, $ZodCheckRegex: ts, $ZodCheckSizeEquals: Ya, $ZodCheckStartsWith: os, $ZodCheckStringFormat: Yt, $ZodCheckUpperCase: rs, $ZodCodec: Ar, $ZodCustom: Nc, $ZodCustomStringFormat: Ls, $ZodDate: Js, $ZodDefault: gc, $ZodDiscriminatedUnion: tc, $ZodE164: As, $ZodEmail: ps, $ZodEmoji: gs, $ZodEncodeError: jt, $ZodEnum: uc, $ZodError: ur, $ZodFile: dc, $ZodFunction: zc, $ZodGUID: fs, $ZodIPv4: js, $ZodIPv6: zs, $ZodISODate: xs, $ZodISODateTime: ks, $ZodISODuration: Ss, $ZodISOTime: Is, $ZodIntersection: nc, $ZodJWT: Ds, $ZodKSUID: ws, $ZodLazy: Oc, $ZodLiteral: lc, $ZodMap: oc, $ZodNaN: kc, $ZodNanoID: vs, $ZodNever: Gs, $ZodNonOptional: bc, $ZodNull: Fs, $ZodNullable: hc, $ZodNumber: zr, $ZodNumberFormat: Rs, $ZodObject: Xs, $ZodObjectJIT: Qs, $ZodOptional: pc, $ZodPipe: xc, $ZodPrefault: _c, $ZodPromise: Ec, $ZodReadonly: Ic, $ZodRealError: ve, $ZodRecord: ic, $ZodRegistry: tn, $ZodSet: sc, $ZodString: Xt, $ZodStringFormat: q, $ZodSuccess: $c, $ZodSymbol: Zs, $ZodTemplateLiteral: jc, $ZodTransform: fc, $ZodTuple: Ur, $ZodType: D, $ZodULID: ys, $ZodURL: hs, $ZodUUID: ms, $ZodUndefined: Ms, $ZodUnion: Nr, $ZodUnknown: Ws, $ZodVoid: Vs, $ZodXID: $s, $brand: Fo, $constructor: d, $input: Mc, $output: Zc, Doc: En, JSONSchema: Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" })), JSONSchemaGenerator: an, NEVER: Mo, TimePrecision: Wc, _any: du, _array: ku, _base64: Xr, _base64url: Qr, _bigint: iu, _boolean: nu, _catch: _p, _check: zu, _cidrv4: qr, _cidrv6: Yr, _coercedBigint: ou, _coercedBoolean: ru, _coercedDate: gu, _coercedNumber: qc, _coercedString: Bc, _cuid: Br, _cuid2: Wr, _custom: Iu, _date: hu, _decode: hr, _decodeAsync: vr, _default: hp, _discriminatedUnion: rp, _e164: ei, _email: Dr, _emoji: Mr, _encode: pr, _encodeAsync: gr, _endsWith: ci, _enum: up, _file: xu, _float32: Xc, _float64: Qc, _gt: pt, _gte: _e, _guid: Pn, _includes: ai, _int: Yc, _int32: eu, _int64: au, _intersection: ip, _ipv4: Hr, _ipv6: Kr, _isoDate: Vc, _isoDateTime: Gc, _isoDuration: Hc, _isoTime: Jc, _jwt: ti, _ksuid: Jr, _lazy: wp, _length: Cn, _literal: dp, _lowercase: ii, _lt: mt, _lte: Ee, _map: sp, _max: Ee, _maxLength: Rn, _maxSize: Ln, _mime: ui, _min: _e, _minLength: Nt, _minSize: rn, _multipleOf: nn, _nan: vu, _nanoid: Fr, _nativeEnum: lp, _negative: bu, _never: mu, _nonnegative: $u, _nonoptional: gp, _nonpositive: yu, _normalize: li, _null: lu, _nullable: pp, _number: Kc, _optional: mp, _overwrite: ht, _parse: Gt, _parseAsync: Vt, _pipe: bp, _positive: _u, _promise: kp, _property: wu, _readonly: yp, _record: ap, _refine: Su, _regex: ri, _safeDecode: br, _safeDecodeAsync: $r, _safeEncode: _r, _safeEncodeAsync: yr, _safeParse: Jt, _safeParseAsync: Ht, _set: cp, _size: ni, _startsWith: si, _string: Fc, _stringFormat: on, _stringbool: Eu, _success: vp, _superRefine: ju, _symbol: cu, _templateLiteral: $p, _toLowerCase: fi, _toUpperCase: mi, _transform: fp, _trim: di, _tuple: op, _uint32: tu, _uint64: su, _ulid: Gr, _undefined: uu, _union: np, _unknown: fu, _uppercase: oi, _url: Dn, _uuid: Lr, _uuidv4: Rr, _uuidv6: Cr, _uuidv7: Zr, _void: pu, _xid: Vr, clone: Ie, config: fe, decode: Yd, decodeAsync: Qd, encode: qd, encodeAsync: Xd, flattenError: lr, formatError: dr, globalConfig: wn, globalRegistry: ft, isValidBase64: jr, isValidBase64URL: Ts, isValidJWT: Ps, locales: Cc, parse: fr, parseAsync: mr, prettifyError: ua, regexes: xr, registry: Pr, safeDecode: tf, safeDecodeAsync: rf, safeEncode: ef, safeEncodeAsync: nf, safeParse: la, safeParseAsync: da, toDotPath: ca, toJSONSchema: pi, treeifyError: sa, util: oa, version: ds }, Symbol.toStringTag, { value: "Module" })), hi = d("ZodISODateTime", (e, n) => { ks.init(e, n), Y.init(e, n) }); function Ou(e) { return Gc(hi, e) } a(Ou, "datetime"); const gi = d("ZodISODate", (e, n) => { xs.init(e, n), Y.init(e, n) }); function Nu(e) { return Vc(gi, e) } a(Nu, "date$2"); const vi = d("ZodISOTime", (e, n) => { Is.init(e, n), Y.init(e, n) }); function Tu(e) { return Jc(vi, e) } a(Tu, "time"); const _i = d("ZodISODuration", (e, n) => { Ss.init(e, n), Y.init(e, n) }); function Uu(e) { return Hc(_i, e) } a(Uu, "duration"); const Ip = Object.freeze(Object.defineProperty({ __proto__: null, ZodISODate: gi, ZodISODateTime: hi, ZodISODuration: _i, ZodISOTime: vi, date: Nu, datetime: Ou, duration: Uu, time: Tu }, Symbol.toStringTag, { value: "Module" })), Au = a((e, n) => { ur.init(e, n), e.name = "ZodError", Object.defineProperties(e, { format: { value: a(r => dr(e, r), "value") }, flatten: { value: a(r => lr(e, r), "value") }, addIssue: { value: a(r => { e.issues.push(r), e.message = JSON.stringify(e.issues, kn, 2) }, "value") }, addIssues: { value: a(r => { e.issues.push(...r), e.message = JSON.stringify(e.issues, kn, 2) }, "value") }, isEmpty: { get() { return e.issues.length === 0 } } }) }, "initializer"), Sp = d("ZodError", Au), be = d("ZodError", Au, { Parent: Error }), Pu = Gt(be), Du = Vt(be), Lu = Jt(be), Ru = Ht(be), Cu = pr(be), Zu = hr(be), Mu = gr(be), Fu = vr(be), Bu = _r(be), Wu = br(be), Gu = yr(be), Vu = $r(be), C = d("ZodType", (e, n) => (D.init(e, n), e.def = n, e.type = n.type, Object.defineProperty(e, "_def", { value: n }), e.check = (...r) => e.clone(Ge(n, { checks: [...n.checks ?? [], ...r.map(i => typeof i == "function" ? { _zod: { check: i, def: { check: "custom" }, onattach: [] } } : i)] })), e.clone = (r, i) => Ie(e, r, i), e.brand = () => e, e.register = ((r, i) => (r.add(e, i), e)), e.parse = (r, i) => Pu(e, r, i, { callee: e.parse }), e.safeParse = (r, i) => Lu(e, r, i), e.parseAsync = async (r, i) => Du(e, r, i, { callee: e.parseAsync }), e.safeParseAsync = async (r, i) => Ru(e, r, i), e.spa = e.safeParseAsync, e.encode = (r, i) => Cu(e, r, i), e.decode = (r, i) => Zu(e, r, i), e.encodeAsync = async (r, i) => Mu(e, r, i), e.decodeAsync = async (r, i) => Fu(e, r, i), e.safeEncode = (r, i) => Bu(e, r, i), e.safeDecode = (r, i) => Wu(e, r, i), e.safeEncodeAsync = async (r, i) => Gu(e, r, i), e.safeDecodeAsync = async (r, i) => Vu(e, r, i), e.refine = (r, i) => e.check(Ul(r, i)), e.superRefine = r => e.check(Al(r)), e.overwrite = r => e.check(ht(r)), e.optional = () => Hn(e), e.nullable = () => Kn(e), e.nullish = () => Hn(Kn(e)), e.nonoptional = r => yl(e, r), e.array = () => Vn(e), e.or = r => Fi([e, r]), e.and = r => al(e, r), e.transform = r => qn(e, Gi(r)), e.default = r => vl(e, r), e.prefault = r => bl(e, r), e.catch = r => kl(e, r), e.pipe = r => qn(e, r), e.readonly = () => Sl(e), e.describe = r => { const i = e.clone(); return ft.add(i, { description: r }), i }, Object.defineProperty(e, "description", { get() { return ft.get(e)?.description }, configurable: !0 }), e.meta = (...r) => { if (r.length === 0) return ft.get(e); const i = e.clone(); return ft.add(i, r[0]), i }, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), bi = d("_ZodString", (e, n) => { Xt.init(e, n), C.init(e, n); const r = e._zod.bag; e.format = r.format ?? null, e.minLength = r.minimum ?? null, e.maxLength = r.maximum ?? null, e.regex = (...i) => e.check(ri(...i)), e.includes = (...i) => e.check(ai(...i)), e.startsWith = (...i) => e.check(si(...i)), e.endsWith = (...i) => e.check(ci(...i)), e.min = (...i) => e.check(Nt(...i)), e.max = (...i) => e.check(Rn(...i)), e.length = (...i) => e.check(Cn(...i)), e.nonempty = (...i) => e.check(Nt(1, ...i)), e.lowercase = i => e.check(ii(i)), e.uppercase = i => e.check(oi(i)), e.trim = () => e.check(di()), e.normalize = (...i) => e.check(li(...i)), e.toLowerCase = () => e.check(fi()), e.toUpperCase = () => e.check(mi()) }), Zn = d("ZodString", (e, n) => { Xt.init(e, n), bi.init(e, n), e.email = r => e.check(Dr($i, r)), e.url = r => e.check(Dn(Fn, r)), e.jwt = r => e.check(ti(Di, r)), e.emoji = r => e.check(Mr(wi, r)), e.guid = r => e.check(Pn(Mn, r)), e.uuid = r => e.check(Lr(Ve, r)), e.uuidv4 = r => e.check(Rr(Ve, r)), e.uuidv6 = r => e.check(Cr(Ve, r)), e.uuidv7 = r => e.check(Zr(Ve, r)), e.nanoid = r => e.check(Fr(ki, r)), e.guid = r => e.check(Pn(Mn, r)), e.cuid = r => e.check(Br(xi, r)), e.cuid2 = r => e.check(Wr(Ii, r)), e.ulid = r => e.check(Gr(Si, r)), e.base64 = r => e.check(Xr(Ui, r)), e.base64url = r => e.check(Qr(Ai, r)), e.xid = r => e.check(Vr(ji, r)), e.ksuid = r => e.check(Jr(zi, r)), e.ipv4 = r => e.check(Hr(Ei, r)), e.ipv6 = r => e.check(Kr(Oi, r)), e.cidrv4 = r => e.check(qr(Ni, r)), e.cidrv6 = r => e.check(Yr(Ti, r)), e.e164 = r => e.check(ei(Pi, r)), e.datetime = r => e.check(Ou(r)), e.date = r => e.check(Nu(r)), e.time = r => e.check(Tu(r)), e.duration = r => e.check(Uu(r)) }); function yi(e) { return Fc(Zn, e) } a(yi, "string$1"); const Y = d("ZodStringFormat", (e, n) => { q.init(e, n), bi.init(e, n) }), $i = d("ZodEmail", (e, n) => { ps.init(e, n), Y.init(e, n) }); function jp(e) { return Dr($i, e) } a(jp, "email"); const Mn = d("ZodGUID", (e, n) => { fs.init(e, n), Y.init(e, n) }); function zp(e) { return Pn(Mn, e) } a(zp, "guid"); const Ve = d("ZodUUID", (e, n) => { ms.init(e, n), Y.init(e, n) }); function Ep(e) { return Lr(Ve, e) } a(Ep, "uuid"); function Op(e) { return Rr(Ve, e) } a(Op, "uuidv4"); function Np(e) { return Cr(Ve, e) } a(Np, "uuidv6"); function Tp(e) { return Zr(Ve, e) } a(Tp, "uuidv7"); const Fn = d("ZodURL", (e, n) => { hs.init(e, n), Y.init(e, n) }); function Up(e) { return Dn(Fn, e) } a(Up, "url"); function Ap(e) { return Dn(Fn, { protocol: /^https?$/, hostname: za, ..._(e) }) } a(Ap, "httpUrl"); const wi = d("ZodEmoji", (e, n) => { gs.init(e, n), Y.init(e, n) }); function Pp(e) { return Mr(wi, e) } a(Pp, "emoji"); const ki = d("ZodNanoID", (e, n) => { vs.init(e, n), Y.init(e, n) }); function Dp(e) { return Fr(ki, e) } a(Dp, "nanoid"); const xi = d("ZodCUID", (e, n) => { _s.init(e, n), Y.init(e, n) }); function Lp(e) { return Br(xi, e) } a(Lp, "cuid"); const Ii = d("ZodCUID2", (e, n) => { bs.init(e, n), Y.init(e, n) }); function Rp(e) { return Wr(Ii, e) } a(Rp, "cuid2"); const Si = d("ZodULID", (e, n) => { ys.init(e, n), Y.init(e, n) }); function Cp(e) { return Gr(Si, e) } a(Cp, "ulid"); const ji = d("ZodXID", (e, n) => { $s.init(e, n), Y.init(e, n) }); function Zp(e) { return Vr(ji, e) } a(Zp, "xid"); const zi = d("ZodKSUID", (e, n) => { ws.init(e, n), Y.init(e, n) }); function Mp(e) { return Jr(zi, e) } a(Mp, "ksuid"); const Ei = d("ZodIPv4", (e, n) => { js.init(e, n), Y.init(e, n) }); function Fp(e) { return Hr(Ei, e) } a(Fp, "ipv4"); const Oi = d("ZodIPv6", (e, n) => { zs.init(e, n), Y.init(e, n) }); function Bp(e) { return Kr(Oi, e) } a(Bp, "ipv6"); const Ni = d("ZodCIDRv4", (e, n) => { Es.init(e, n), Y.init(e, n) }); function Wp(e) { return qr(Ni, e) } a(Wp, "cidrv4"); const Ti = d("ZodCIDRv6", (e, n) => { Os.init(e, n), Y.init(e, n) }); function Gp(e) { return Yr(Ti, e) } a(Gp, "cidrv6"); const Ui = d("ZodBase64", (e, n) => { Ns.init(e, n), Y.init(e, n) }); function Vp(e) { return Xr(Ui, e) } a(Vp, "base64"); const Ai = d("ZodBase64URL", (e, n) => { Us.init(e, n), Y.init(e, n) }); function Jp(e) { return Qr(Ai, e) } a(Jp, "base64url"); const Pi = d("ZodE164", (e, n) => { As.init(e, n), Y.init(e, n) }); function Hp(e) { return ei(Pi, e) } a(Hp, "e164"); const Di = d("ZodJWT", (e, n) => { Ds.init(e, n), Y.init(e, n) }); function Kp(e) { return ti(Di, e) } a(Kp, "jwt"); const sn = d("ZodCustomStringFormat", (e, n) => { Ls.init(e, n), Y.init(e, n) }); function qp(e, n, r = {}) { return on(sn, e, n, r) } a(qp, "stringFormat"); function Yp(e) { return on(sn, "hostname", kr, e) } a(Yp, "hostname"); function Xp(e) { return on(sn, "hex", Wa, e) } a(Xp, "hex"); function Qp(e, n) { const r = n?.enc ?? "hex", i = `${e}_${r}`, t = xr[i]; if (!t) throw new Error(`Unrecognized hash format: ${i}`); return on(sn, i, t, n) } a(Qp, "hash"); const Bn = d("ZodNumber", (e, n) => { zr.init(e, n), C.init(e, n), e.gt = (i, t) => e.check(pt(i, t)), e.gte = (i, t) => e.check(_e(i, t)), e.min = (i, t) => e.check(_e(i, t)), e.lt = (i, t) => e.check(mt(i, t)), e.lte = (i, t) => e.check(Ee(i, t)), e.max = (i, t) => e.check(Ee(i, t)), e.int = i => e.check(Li(i)), e.safe = i => e.check(Li(i)), e.positive = i => e.check(pt(0, i)), e.nonnegative = i => e.check(_e(0, i)), e.negative = i => e.check(mt(0, i)), e.nonpositive = i => e.check(Ee(0, i)), e.multipleOf = (i, t) => e.check(nn(i, t)), e.step = (i, t) => e.check(nn(i, t)), e.finite = () => e; const r = e._zod.bag; e.minValue = Math.max(r.minimum ?? Number.NEGATIVE_INFINITY, r.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(r.maximum ?? Number.POSITIVE_INFINITY, r.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (r.format ?? "").includes("int") || Number.isSafeInteger(r.multipleOf ?? .5), e.isFinite = !0, e.format = r.format ?? null }); function Ju(e) { return Kc(Bn, e) } a(Ju, "number$1"); const Tt = d("ZodNumberFormat", (e, n) => { Rs.init(e, n), Bn.init(e, n) }); function Li(e) { return Yc(Tt, e) } a(Li, "int"); function eh(e) { return Xc(Tt, e) } a(eh, "float32"); function th(e) { return Qc(Tt, e) } a(th, "float64"); function nh(e) { return eu(Tt, e) } a(nh, "int32"); function rh(e) { return tu(Tt, e) } a(rh, "uint32"); const Wn = d("ZodBoolean", (e, n) => { Er.init(e, n), C.init(e, n) }); function Hu(e) { return nu(Wn, e) } a(Hu, "boolean$1"); const Gn = d("ZodBigInt", (e, n) => { Or.init(e, n), C.init(e, n), e.gte = (i, t) => e.check(_e(i, t)), e.min = (i, t) => e.check(_e(i, t)), e.gt = (i, t) => e.check(pt(i, t)), e.gte = (i, t) => e.check(_e(i, t)), e.min = (i, t) => e.check(_e(i, t)), e.lt = (i, t) => e.check(mt(i, t)), e.lte = (i, t) => e.check(Ee(i, t)), e.max = (i, t) => e.check(Ee(i, t)), e.positive = i => e.check(pt(BigInt(0), i)), e.negative = i => e.check(mt(BigInt(0), i)), e.nonpositive = i => e.check(Ee(BigInt(0), i)), e.nonnegative = i => e.check(_e(BigInt(0), i)), e.multipleOf = (i, t) => e.check(nn(i, t)); const r = e._zod.bag; e.minValue = r.minimum ?? null, e.maxValue = r.maximum ?? null, e.format = r.format ?? null }); function ih(e) { return iu(Gn, e) } a(ih, "bigint$1"); const Ri = d("ZodBigIntFormat", (e, n) => { Cs.init(e, n), Gn.init(e, n) }); function oh(e) { return au(Ri, e) } a(oh, "int64"); function ah(e) { return su(Ri, e) } a(ah, "uint64"); const Ku = d("ZodSymbol", (e, n) => { Zs.init(e, n), C.init(e, n) }); function sh(e) { return cu(Ku, e) } a(sh, "symbol"); const qu = d("ZodUndefined", (e, n) => { Ms.init(e, n), C.init(e, n) }); function ch(e) { return uu(qu, e) } a(ch, "_undefined"); const Yu = d("ZodNull", (e, n) => { Fs.init(e, n), C.init(e, n) }); function Xu(e) { return lu(Yu, e) } a(Xu, "_null"); const Qu = d("ZodAny", (e, n) => { Bs.init(e, n), C.init(e, n) }); function uh() { return du(Qu) } a(uh, "any"); const el = d("ZodUnknown", (e, n) => { Ws.init(e, n), C.init(e, n) }); function Ut() { return fu(el) } a(Ut, "unknown"); const tl = d("ZodNever", (e, n) => { Gs.init(e, n), C.init(e, n) }); function Ci(e) { return mu(tl, e) } a(Ci, "never"); const nl = d("ZodVoid", (e, n) => { Vs.init(e, n), C.init(e, n) }); function lh(e) { return pu(nl, e) } a(lh, "_void"); const Zi = d("ZodDate", (e, n) => { Js.init(e, n), C.init(e, n), e.min = (i, t) => e.check(_e(i, t)), e.max = (i, t) => e.check(Ee(i, t)); const r = e._zod.bag; e.minDate = r.minimum ? new Date(r.minimum) : null, e.maxDate = r.maximum ? new Date(r.maximum) : null }); function dh(e) { return hu(Zi, e) } a(dh, "date$1"); const rl = d("ZodArray", (e, n) => { Ks.init(e, n), C.init(e, n), e.element = n.element, e.min = (r, i) => e.check(Nt(r, i)), e.nonempty = r => e.check(Nt(1, r)), e.max = (r, i) => e.check(Rn(r, i)), e.length = (r, i) => e.check(Cn(r, i)), e.unwrap = () => e.element }); function Vn(e, n) { return ku(rl, e, n) } a(Vn, "array"); function fh(e) { const n = e._zod.def.shape; return Wi(Object.keys(n)) } a(fh, "keyof"); const Jn = d("ZodObject", (e, n) => { Qs.init(e, n), C.init(e, n), F(e, "shape", () => n.shape), e.keyof = () => Wi(Object.keys(e._zod.def.shape)), e.catchall = r => e.clone({ ...e._zod.def, catchall: r }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: Ut() }), e.loose = () => e.clone({ ...e._zod.def, catchall: Ut() }), e.strict = () => e.clone({ ...e._zod.def, catchall: Ci() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = r => Xo(e, r), e.safeExtend = r => Qo(e, r), e.merge = r => ea(e, r), e.pick = r => qo(e, r), e.omit = r => Yo(e, r), e.partial = (...r) => ta(Vi, e, r[0]), e.required = (...r) => na(Ji, e, r[0]) }); function mh(e, n) { const r = { type: "object", shape: e ?? {}, ..._(n) }; return new Jn(r) } a(mh, "object"); function ph(e, n) { return new Jn({ type: "object", shape: e, catchall: Ci(), ..._(n) }) } a(ph, "strictObject"); function hh(e, n) { return new Jn({ type: "object", shape: e, catchall: Ut(), ..._(n) }) } a(hh, "looseObject"); const Mi = d("ZodUnion", (e, n) => { Nr.init(e, n), C.init(e, n), e.options = n.options }); function Fi(e, n) { return new Mi({ type: "union", options: e, ..._(n) }) } a(Fi, "union"); const il = d("ZodDiscriminatedUnion", (e, n) => { Mi.init(e, n), tc.init(e, n) }); function gh(e, n, r) { return new il({ type: "union", options: n, discriminator: e, ..._(r) }) } a(gh, "discriminatedUnion"); const ol = d("ZodIntersection", (e, n) => { nc.init(e, n), C.init(e, n) }); function al(e, n) { return new ol({ type: "intersection", left: e, right: n }) } a(al, "intersection"); const sl = d("ZodTuple", (e, n) => { Ur.init(e, n), C.init(e, n), e.rest = r => e.clone({ ...e._zod.def, rest: r }) }); function cl(e, n, r) { const i = n instanceof D, t = i ? r : n, o = i ? n : null; return new sl({ type: "tuple", items: e, rest: o, ..._(t) }) } a(cl, "tuple"); const Bi = d("ZodRecord", (e, n) => { ic.init(e, n), C.init(e, n), e.keyType = n.keyType, e.valueType = n.valueType }); function ul(e, n, r) { return new Bi({ type: "record", keyType: e, valueType: n, ..._(r) }) } a(ul, "record"); function vh(e, n, r) { const i = Ie(e); return i._zod.values = void 0, new Bi({ type: "record", keyType: i, valueType: n, ..._(r) }) } a(vh, "partialRecord"); const ll = d("ZodMap", (e, n) => { oc.init(e, n), C.init(e, n), e.keyType = n.keyType, e.valueType = n.valueType }); function _h(e, n, r) { return new ll({ type: "map", keyType: e, valueType: n, ..._(r) }) } a(_h, "map"); const dl = d("ZodSet", (e, n) => { sc.init(e, n), C.init(e, n), e.min = (...r) => e.check(rn(...r)), e.nonempty = r => e.check(rn(1, r)), e.max = (...r) => e.check(Ln(...r)), e.size = (...r) => e.check(ni(...r)) }); function bh(e, n) { return new dl({ type: "set", valueType: e, ..._(n) }) } a(bh, "set"); const cn = d("ZodEnum", (e, n) => { uc.init(e, n), C.init(e, n), e.enum = n.entries, e.options = Object.values(n.entries); const r = new Set(Object.keys(n.entries)); e.extract = (i, t) => { const o = {}; for (const s of i) if (r.has(s)) o[s] = n.entries[s]; else throw new Error(`Key ${s} not found in enum`); return new cn({ ...n, checks: [], ..._(t), entries: o }) }, e.exclude = (i, t) => { const o = { ...n.entries }; for (const s of i) if (r.has(s)) delete o[s]; else throw new Error(`Key ${s} not found in enum`); return new cn({ ...n, checks: [], ..._(t), entries: o }) } }); function Wi(e, n) { const r = Array.isArray(e) ? Object.fromEntries(e.map(i => [i, i])) : e; return new cn({ type: "enum", entries: r, ..._(n) }) } a(Wi, "_enum"); function yh(e, n) { return new cn({ type: "enum", entries: e, ..._(n) }) } a(yh, "nativeEnum"); const fl = d("ZodLiteral", (e, n) => { lc.init(e, n), C.init(e, n), e.values = new Set(n.values), Object.defineProperty(e, "value", { get() { if (n.values.length > 1) throw new Error("This schema contains multiple valid literal values. Use `.values` instead."); return n.values[0] } }) }); function $h(e, n) { return new fl({ type: "literal", values: Array.isArray(e) ? e : [e], ..._(n) }) } a($h, "literal"); const ml = d("ZodFile", (e, n) => { dc.init(e, n), C.init(e, n), e.min = (r, i) => e.check(rn(r, i)), e.max = (r, i) => e.check(Ln(r, i)), e.mime = (r, i) => e.check(ui(Array.isArray(r) ? r : [r], i)) }); function wh(e) { return xu(ml, e) } a(wh, "file"); const pl = d("ZodTransform", (e, n) => { fc.init(e, n), C.init(e, n), e._zod.parse = (r, i) => { if (i.direction === "backward") throw new jt(e.constructor.name); r.addIssue = o => { if (typeof o == "string") r.issues.push(Et(o, r.value, n)); else { const s = o; s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = r.value), s.inst ?? (s.inst = e), r.issues.push(Et(s)) } }; const t = n.transform(r.value, r); return t instanceof Promise ? t.then(o => (r.value = o, r)) : (r.value = t, r) } }); function Gi(e) { return new pl({ type: "transform", transform: e }) } a(Gi, "transform"); const Vi = d("ZodOptional", (e, n) => { pc.init(e, n), C.init(e, n), e.unwrap = () => e._zod.def.innerType }); function Hn(e) { return new Vi({ type: "optional", innerType: e }) } a(Hn, "optional"); const hl = d("ZodNullable", (e, n) => { hc.init(e, n), C.init(e, n), e.unwrap = () => e._zod.def.innerType }); function Kn(e) { return new hl({ type: "nullable", innerType: e }) } a(Kn, "nullable"); function kh(e) { return Hn(Kn(e)) } a(kh, "nullish"); const gl = d("ZodDefault", (e, n) => { gc.init(e, n), C.init(e, n), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap }); function vl(e, n) { return new gl({ type: "default", innerType: e, get defaultValue() { return typeof n == "function" ? n() : In(n) } }) } a(vl, "_default"); const _l = d("ZodPrefault", (e, n) => { _c.init(e, n), C.init(e, n), e.unwrap = () => e._zod.def.innerType }); function bl(e, n) { return new _l({ type: "prefault", innerType: e, get defaultValue() { return typeof n == "function" ? n() : In(n) } }) } a(bl, "prefault"); const Ji = d("ZodNonOptional", (e, n) => { bc.init(e, n), C.init(e, n), e.unwrap = () => e._zod.def.innerType }); function yl(e, n) { return new Ji({ type: "nonoptional", innerType: e, ..._(n) }) } a(yl, "nonoptional"); const $l = d("ZodSuccess", (e, n) => { $c.init(e, n), C.init(e, n), e.unwrap = () => e._zod.def.innerType }); function xh(e) { return new $l({ type: "success", innerType: e }) } a(xh, "success"); const wl = d("ZodCatch", (e, n) => { wc.init(e, n), C.init(e, n), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap }); function kl(e, n) { return new wl({ type: "catch", innerType: e, catchValue: typeof n == "function" ? n : () => n }) } a(kl, "_catch"); const xl = d("ZodNaN", (e, n) => { kc.init(e, n), C.init(e, n) }); function Ih(e) { return vu(xl, e) } a(Ih, "nan"); const Hi = d("ZodPipe", (e, n) => { xc.init(e, n), C.init(e, n), e.in = n.in, e.out = n.out }); function qn(e, n) { return new Hi({ type: "pipe", in: e, out: n }) } a(qn, "pipe"); const Ki = d("ZodCodec", (e, n) => { Hi.init(e, n), Ar.init(e, n) }); function Sh(e, n, r) { return new Ki({ type: "pipe", in: e, out: n, transform: r.decode, reverseTransform: r.encode }) } a(Sh, "codec"); const Il = d("ZodReadonly", (e, n) => { Ic.init(e, n), C.init(e, n), e.unwrap = () => e._zod.def.innerType }); function Sl(e) { return new Il({ type: "readonly", innerType: e }) } a(Sl, "readonly"); const jl = d("ZodTemplateLiteral", (e, n) => { jc.init(e, n), C.init(e, n) }); function jh(e, n) { return new jl({ type: "template_literal", parts: e, ..._(n) }) } a(jh, "templateLiteral"); const zl = d("ZodLazy", (e, n) => { Oc.init(e, n), C.init(e, n), e.unwrap = () => e._zod.def.getter() }); function El(e) { return new zl({ type: "lazy", getter: e }) } a(El, "lazy"); const Ol = d("ZodPromise", (e, n) => { Ec.init(e, n), C.init(e, n), e.unwrap = () => e._zod.def.innerType }); function zh(e) { return new Ol({ type: "promise", innerType: e }) } a(zh, "promise"); const Nl = d("ZodFunction", (e, n) => { zc.init(e, n), C.init(e, n) }); function Tl(e) { return new Nl({ type: "function", input: Array.isArray(e?.input) ? cl(e?.input) : e?.input ?? Vn(Ut()), output: e?.output ?? Ut() }) } a(Tl, "_function"); const Yn = d("ZodCustom", (e, n) => { Nc.init(e, n), C.init(e, n) }); function Eh(e) { const n = new ne({ check: "custom" }); return n._zod.check = e, n } a(Eh, "check"); function Oh(e, n) { return Iu(Yn, e ?? (() => !0), n) } a(Oh, "custom"); function Ul(e, n = {}) { return Su(Yn, e, n) } a(Ul, "refine"); function Al(e) { return ju(e) } a(Al, "superRefine"); function Nh(e, n = { error: `Input not instance of ${e.name}` }) { const r = new Yn({ type: "custom", check: "custom", fn: a(i => i instanceof e, "fn"), abort: !0, ..._(n) }); return r._zod.bag.Class = e, r } a(Nh, "_instanceof"); const Th = a((...e) => Eu({ Codec: Ki, Boolean: Wn, String: Zn }, ...e), "stringbool"); function Uh(e) { const n = El(() => Fi([yi(e), Ju(), Hu(), Xu(), Vn(n), ul(yi(), n)])); return n } a(Uh, "json"); function Ah(e, n) { return qn(Gi(e), n) } a(Ah, "preprocess"); const Ph = { invalid_type: "invalid_type", too_big: "too_big", too_small: "too_small", invalid_format: "invalid_format", not_multiple_of: "not_multiple_of", unrecognized_keys: "unrecognized_keys", invalid_union: "invalid_union", invalid_key: "invalid_key", invalid_element: "invalid_element", invalid_value: "invalid_value", custom: "custom" }; function Dh(e) { fe({ customError: e }) } a(Dh, "setErrorMap"); function Lh() { return fe().customError } a(Lh, "getErrorMap"); var qi; qi || (qi = {}); function Rh(e) { return Bc(Zn, e) } a(Rh, "string"); function Ch(e) { return qc(Bn, e) } a(Ch, "number"); function Zh(e) { return ru(Wn, e) } a(Zh, "boolean"); function Mh(e) { return ou(Gn, e) } a(Mh, "bigint"); function Fh(e) { return gu(Zi, e) } a(Fh, "date"); const Bh = Object.freeze(Object.defineProperty({ __proto__: null, bigint: Mh, boolean: Zh, date: Fh, number: Ch, string: Rh }, Symbol.toStringTag, { value: "Module" })); fe(Ac()); const V = Object.freeze(Object.defineProperty({ __proto__: null, $brand: Fo, $input: Mc, $output: Zc, NEVER: Mo, TimePrecision: Wc, ZodAny: Qu, ZodArray: rl, ZodBase64: Ui, ZodBase64URL: Ai, ZodBigInt: Gn, ZodBigIntFormat: Ri, ZodBoolean: Wn, ZodCIDRv4: Ni, ZodCIDRv6: Ti, ZodCUID: xi, ZodCUID2: Ii, ZodCatch: wl, ZodCodec: Ki, ZodCustom: Yn, ZodCustomStringFormat: sn, ZodDate: Zi, ZodDefault: gl, ZodDiscriminatedUnion: il, ZodE164: Pi, ZodEmail: $i, ZodEmoji: wi, ZodEnum: cn, ZodError: Sp, ZodFile: ml, get ZodFirstPartyTypeKind() { return qi }, ZodFunction: Nl, ZodGUID: Mn, ZodIPv4: Ei, ZodIPv6: Oi, ZodISODate: gi, ZodISODateTime: hi, ZodISODuration: _i, ZodISOTime: vi, ZodIntersection: ol, ZodIssueCode: Ph, ZodJWT: Di, ZodKSUID: zi, ZodLazy: zl, ZodLiteral: fl, ZodMap: ll, ZodNaN: xl, ZodNanoID: ki, ZodNever: tl, ZodNonOptional: Ji, ZodNull: Yu, ZodNullable: hl, ZodNumber: Bn, ZodNumberFormat: Tt, ZodObject: Jn, ZodOptional: Vi, ZodPipe: Hi, ZodPrefault: _l, ZodPromise: Ol, ZodReadonly: Il, ZodRealError: be, ZodRecord: Bi, ZodSet: dl, ZodString: Zn, ZodStringFormat: Y, ZodSuccess: $l, ZodSymbol: Ku, ZodTemplateLiteral: jl, ZodTransform: pl, ZodTuple: sl, ZodType: C, ZodULID: Si, ZodURL: Fn, ZodUUID: Ve, ZodUndefined: qu, ZodUnion: Mi, ZodUnknown: el, ZodVoid: nl, ZodXID: ji, _ZodString: bi, _default: vl, _function: Tl, any: uh, array: Vn, base64: Vp, base64url: Jp, bigint: ih, boolean: Hu, catch: kl, check: Eh, cidrv4: Wp, cidrv6: Gp, clone: Ie, codec: Sh, coerce: Bh, config: fe, core: xp, cuid: Lp, cuid2: Rp, custom: Oh, date: dh, decode: Zu, decodeAsync: Fu, discriminatedUnion: gh, e164: Hp, email: jp, emoji: Pp, encode: Cu, encodeAsync: Mu, endsWith: ci, enum: Wi, file: wh, flattenError: lr, float32: eh, float64: th, formatError: dr, function: Tl, getErrorMap: Lh, globalRegistry: ft, gt: pt, gte: _e, guid: zp, hash: Qp, hex: Xp, hostname: Yp, httpUrl: Ap, includes: ai, instanceof: Nh, int: Li, int32: nh, int64: oh, intersection: al, ipv4: Fp, ipv6: Bp, iso: Ip, json: Uh, jwt: Kp, keyof: fh, ksuid: Mp, lazy: El, length: Cn, literal: $h, locales: Cc, looseObject: hh, lowercase: ii, lt: mt, lte: Ee, map: _h, maxLength: Rn, maxSize: Ln, mime: ui, minLength: Nt, minSize: rn, multipleOf: nn, nan: Ih, nanoid: Dp, nativeEnum: yh, negative: bu, never: Ci, nonnegative: $u, nonoptional: yl, nonpositive: yu, normalize: li, null: Xu, nullable: Kn, nullish: kh, number: Ju, object: mh, optional: Hn, overwrite: ht, parse: Pu, parseAsync: Du, partialRecord: vh, pipe: qn, positive: _u, prefault: bl, preprocess: Ah, prettifyError: ua, promise: zh, property: wu, readonly: Sl, record: ul, refine: Ul, regex: ri, regexes: xr, registry: Pr, safeDecode: Wu, safeDecodeAsync: Vu, safeEncode: Bu, safeEncodeAsync: Gu, safeParse: Lu, safeParseAsync: Ru, set: bh, setErrorMap: Dh, size: ni, startsWith: si, strictObject: ph, string: yi, stringFormat: qp, stringbool: Th, success: xh, superRefine: Al, symbol: sh, templateLiteral: jh, toJSONSchema: pi, toLowerCase: fi, toUpperCase: mi, transform: Gi, treeifyError: sa, trim: di, tuple: cl, uint32: rh, uint64: ah, ulid: Cp, undefined: ch, union: Fi, unknown: Ut, uppercase: oi, url: Up, util: oa, uuid: Ep, uuidv4: Op, uuidv6: Np, uuidv7: Tp, void: lh, xid: Zp }, Symbol.toStringTag, { value: "Module" })), Wh = -1, Gh = "PAGE-AGENT-FREE-TESTING-RANDOM", Vh = "PAGE-AGENT-FREE-TESTING-RANDOM", Jh = "https://hwcxiuzfylggtcktqgij.supabase.co/functions/v1/llm-testing-proxy", Hh = 2, Pl = 20, Kh = .7, qh = 4096, Yh = a((e = { doHighlightElements: !0, focusHighlightIndex: -1, viewportExpansion: 0, debugMode: !1, interactiveBlacklist: [], interactiveWhitelist: [], highlightOpacity: .1, highlightLabelOpacity: .5 }) => { const { interactiveBlacklist: n, interactiveWhitelist: r, highlightOpacity: i, highlightLabelOpacity: t } = e, { doHighlightElements: o, focusHighlightIndex: s, viewportExpansion: c, debugMode: u } = e; let p = 0; const m = new WeakMap; function f(l, k) { !l || l.nodeType !== Node.ELEMENT_NODE || m.set(l, { ...m.get(l), ...k }) } a(f, "addExtraData"); const b = { boundingRects: new WeakMap, clientRects: new WeakMap, computedStyles: new WeakMap, clearCache: a(() => { b.boundingRects = new WeakMap, b.clientRects = new WeakMap, b.computedStyles = new WeakMap }, "clearCache") }; function v(l) { if (!l) return null; if (b.boundingRects.has(l)) return b.boundingRects.get(l); const k = l.getBoundingClientRect(); return k && b.boundingRects.set(l, k), k } a(v, "getCachedBoundingRect"); function h(l) { if (!l) return null; if (b.computedStyles.has(l)) return b.computedStyles.get(l); const k = window.getComputedStyle(l); return k && b.computedStyles.set(l, k), k } a(h, "getCachedComputedStyle"); function y(l) { if (!l) return null; if (b.clientRects.has(l)) return b.clientRects.get(l); const k = l.getClientRects(); return k && b.clientRects.set(l, k), k } a(y, "getCachedClientRects"); const w = {}, j = { current: 0 }, A = "playwright-highlight-container"; function z(l, k, Z = null) { if (!l) return k; const S = []; let E = null, B = 20, N = 16, L = null; try { let T = document.getElementById(A); T || (T = document.createElement("div"), T.id = A, T.style.position = "fixed", T.style.pointerEvents = "none", T.style.top = "0", T.style.left = "0", T.style.width = "100%", T.style.height = "100%", T.style.zIndex = "2147483640", T.style.backgroundColor = "transparent", document.body.appendChild(T)); const K = l.getClientRects(); if (!K || K.length === 0) return k; const he = ["#FF0000", "#00FF00", "#0000FF", "#FFA500", "#800080", "#008080", "#FF69B4", "#4B0082", "#FF4500", "#2E8B57", "#DC143C", "#4682B4"], ue = k % he.length; let st = he[ue]; const ke = st + Math.floor(i * 255).toString(16).padStart(2, "0"); st = st + Math.floor(t * 255).toString(16).padStart(2, "0"); let Se = { x: 0, y: 0 }; if (Z) { const ie = Z.getBoundingClientRect(); Se.x = ie.left, Se.y = ie.top } const Ce = document.createDocumentFragment(); for (const ie of K) { if (ie.width === 0 || ie.height === 0) continue; const oe = document.createElement("div"); oe.style.position = "fixed", oe.style.border = `2px solid ${st}`, oe.style.backgroundColor = ke, oe.style.pointerEvents = "none", oe.style.boxSizing = "border-box"; const X = ie.top + Se.y, Xe = ie.left + Se.x; oe.style.top = `${X}px`, oe.style.left = `${Xe}px`, oe.style.width = `${ie.width}px`, oe.style.height = `${ie.height}px`, Ce.appendChild(oe), S.push({ element: oe, initialRect: ie }) } const Ze = K[0]; E = document.createElement("div"), E.className = "playwright-highlight-label", E.style.position = "fixed", E.style.background = st, E.style.color = "white", E.style.padding = "1px 4px", E.style.borderRadius = "4px", E.style.fontSize = `${Math.min(12, Math.max(8, Ze.height / 2))}px`, E.textContent = k.toString(), B = E.offsetWidth > 0 ? E.offsetWidth : B, N = E.offsetHeight > 0 ? E.offsetHeight : N; const xt = Ze.top + Se.y, gn = Ze.left + Se.x; let Xn = xt + 2, Rt = gn + Ze.width - B - 2; (Ze.width < B + 4 || Ze.height < N + 4) && (Xn = xt - N - 2, Rt = gn + Ze.width - B, Rt < Se.x && (Rt = gn)), Xn = Math.max(0, Math.min(Xn, window.innerHeight - N)), Rt = Math.max(0, Math.min(Rt, window.innerWidth - B)), E.style.top = `${Xn}px`, E.style.left = `${Rt}px`, Ce.appendChild(E); const Qn = a((ie, oe) => { let X = 0; return (...Xe) => { const xe = performance.now(); if (!(xe - X < oe)) return X = xe, ie(...Xe) } }, "throttleFunction")(a(() => { const ie = l.getClientRects(); let oe = { x: 0, y: 0 }; if (Z) { const X = Z.getBoundingClientRect(); oe.x = X.left, oe.y = X.top } if (S.forEach((X, Xe) => { if (Xe < ie.length) { const xe = ie[Xe], Ct = xe.top + oe.y, ct = xe.left + oe.x; X.element.style.top = `${Ct}px`, X.element.style.left = `${ct}px`, X.element.style.width = `${xe.width}px`, X.element.style.height = `${xe.height}px`, X.element.style.display = xe.width === 0 || xe.height === 0 ? "none" : "block" } else X.element.style.display = "none" }), ie.length < S.length) for (let X = ie.length; X < S.length; X++)S[X].element.style.display = "none"; if (E && ie.length > 0) { const X = ie[0], Xe = X.top + oe.y, xe = X.left + oe.x; let Ct = Xe + 2, ct = xe + X.width - B - 2; (X.width < B + 4 || X.height < N + 4) && (Ct = Xe - N - 2, ct = xe + X.width - B, ct < oe.x && (ct = xe)), Ct = Math.max(0, Math.min(Ct, window.innerHeight - N)), ct = Math.max(0, Math.min(ct, window.innerWidth - B)), E.style.top = `${Ct}px`, E.style.left = `${ct}px`, E.style.display = "block" } else E && (E.style.display = "none") }, "updatePositions"), 16); return window.addEventListener("scroll", Qn, !0), window.addEventListener("resize", Qn), L = a(() => { window.removeEventListener("scroll", Qn, !0), window.removeEventListener("resize", Qn), S.forEach(ie => ie.element.remove()), E && E.remove() }, "cleanupFn"), T.appendChild(Ce), k + 1 } finally { L && (window._highlightCleanupFunctions = window._highlightCleanupFunctions || []).push(L) } } a(z, "highlightElement"); function I(l) { if (!l || l.nodeType !== Node.ELEMENT_NODE) return null; const k = h(l); if (!k) return null; const Z = k.display; if (Z === "inline" || Z === "inline-block") return null; const S = k.overflowX, E = k.overflowY, B = S === "auto" || S === "scroll", N = E === "auto" || E === "scroll"; if (!B && !N) return null; const L = l.scrollWidth - l.clientWidth, T = l.scrollHeight - l.clientHeight, K = 4; if (L < K && T < K || !N && L < K || !B && T < K) return null; const he = l.scrollTop, ue = l.scrollLeft, st = l.scrollWidth - l.clientWidth - l.scrollLeft, ke = l.scrollHeight - l.clientHeight - l.scrollTop, Se = { top: he, right: st, bottom: ke, left: ue }; return f(l, { scrollable: !0, scrollData: Se }), Se } a(I, "isScrollableElement"); function M(l) { try { if (c === -1) { const N = l.parentElement; if (!N) return !1; try { return N.checkVisibility({ checkOpacity: !0, checkVisibilityCSS: !0 }) } catch { const T = window.getComputedStyle(N); return T.display !== "none" && T.visibility !== "hidden" && T.opacity !== "0" } } const k = document.createRange(); k.selectNodeContents(l); const Z = k.getClientRects(); if (!Z || Z.length === 0) return !1; let S = !1, E = !1; for (const N of Z) if (N.width > 0 && N.height > 0 && (S = !0, !(N.bottom < -c || N.top > window.innerHeight + c || N.right < -c || N.left > window.innerWidth + c))) { E = !0; break } if (!S || !E) return !1; const B = l.parentElement; if (!B) return !1; try { return B.checkVisibility({ checkOpacity: !0, checkVisibilityCSS: !0 }) } catch { const L = window.getComputedStyle(B); return L.display !== "none" && L.visibility !== "hidden" && L.opacity !== "0" } } catch (k) { return console.warn("Error checking text node visibility:", k), !1 } } a(M, "isTextNodeVisible"); function Ye(l) { if (!l || !l.tagName) return !1; const k = new Set(["body", "div", "main", "article", "section", "nav", "header", "footer"]), Z = l.tagName.toLowerCase(); return k.has(Z) ? !0 : !new Set(["svg", "script", "style", "link", "meta", "noscript", "template"]).has(Z) } a(Ye, "isElementAccepted"); function re(l) { const k = h(l); return l.offsetWidth > 0 && l.offsetHeight > 0 && k?.visibility !== "hidden" && k?.display !== "none" } a(re, "isElementVisible"); function me(l) { if (!l || l.nodeType !== Node.ELEMENT_NODE || n.includes(l)) return !1; if (r.includes(l)) return !0; const k = l.tagName.toLowerCase(), Z = h(l), S = new Set(["pointer", "move", "text", "grab", "grabbing", "cell", "copy", "alias", "all-scroll", "col-resize", "context-menu", "crosshair", "e-resize", "ew-resize", "help", "n-resize", "ne-resize", "nesw-resize", "ns-resize", "nw-resize", "nwse-resize", "row-resize", "s-resize", "se-resize", "sw-resize", "vertical-text", "w-resize", "zoom-in", "zoom-out"]), E = new Set(["not-allowed", "no-drop", "wait", "progress", "initial", "inherit"]); function B(ke) { return ke.tagName.toLowerCase() === "html" ? !1 : !!(Z?.cursor && S.has(Z.cursor)) } if (a(B, "doesElementHaveInteractivePointer"), B(l)) return !0; const L = new Set(["a", "button", "input", "select", "textarea", "details", "summary", "label", "option", "optgroup", "fieldset", "legend"]), T = new Set(["disabled", "readonly"]); if (L.has(k)) { if (Z?.cursor && E.has(Z.cursor)) return !1; for (const ke of T) if (l.hasAttribute(ke) || l.getAttribute(ke) === "true" || l.getAttribute(ke) === "") return !1; return !(l.disabled || l.readOnly || l.inert) } const K = l.getAttribute("role"), he = l.getAttribute("aria-role"); if (l.getAttribute("contenteditable") === "true" || l.isContentEditable || l.classList && (l.classList.contains("button") || l.classList.contains("dropdown-toggle") || l.getAttribute("data-index") || l.getAttribute("data-toggle") === "dropdown" || l.getAttribute("aria-haspopup") === "true")) return !0; const ue = new Set(["button", "menu", "menubar", "menuitem", "menuitemradio", "menuitemcheckbox", "radio", "checkbox", "tab", "switch", "slider", "spinbutton", "combobox", "searchbox", "textbox", "listbox", "option", "scrollbar"]); if (L.has(k) || K && ue.has(K) || he && ue.has(he)) return !0; try { if (typeof getEventListeners == "function") { const Ce = getEventListeners(l), Ze = ["click", "mousedown", "mouseup", "dblclick"]; for (const xt of Ze) if (Ce[xt] && Ce[xt].length > 0) return !0 } const ke = l?.ownerDocument?.defaultView?.getEventListenersForNode || window.getEventListenersForNode; if (typeof ke == "function") { const Ce = ke(l), Ze = ["click", "mousedown", "mouseup", "keydown", "keyup", "submit", "change", "input", "focus", "blur"]; for (const xt of Ze) for (const gn of Ce) if (gn.type === xt) return !0 } const Se = ["onclick", "onmousedown", "onmouseup", "ondblclick"]; for (const Ce of Se) if (l.hasAttribute(Ce) || typeof l[Ce] == "function") return !0 } catch { } return !!I(l) } a(me, "isInteractiveElement"); function Ae(l) { if (c === -1) return !0; const k = y(l); if (!k || k.length === 0) return !1; let Z = !1; for (const T of k) if (T.width > 0 && T.height > 0 && !(T.bottom < -c || T.top > window.innerHeight + c || T.right < -c || T.left > window.innerWidth + c)) { Z = !0; break } if (!Z) return !1; if (l.ownerDocument !== window.document) return !0; let E = Array.from(k).find(T => T.width > 0 && T.height > 0); if (!E) return !1; const B = l.getRootNode(); if (B instanceof ShadowRoot) { const T = E.left + E.width / 2, K = E.top + E.height / 2; try { const he = B.elementFromPoint(T, K); if (!he) return !1; let ue = he; for (; ue && ue !== B;) { if (ue === l) return !0; ue = ue.parentElement } return !1 } catch { return !0 } } const N = 5; return [{ x: E.left + E.width / 2, y: E.top + E.height / 2 }, { x: E.left + N, y: E.top + N }, { x: E.right - N, y: E.bottom - N }].some(({ x: T, y: K }) => { try { const he = document.elementFromPoint(T, K); if (!he) return !1; let ue = he; for (; ue && ue !== document.documentElement;) { if (ue === l) return !0; ue = ue.parentElement } return !1 } catch { return !0 } }) } a(Ae, "isTopElement"); function pe(l, k) { if (k === -1) return !0; const Z = l.getClientRects(); if (!Z || Z.length === 0) { const S = v(l); return !S || S.width === 0 || S.height === 0 ? !1 : !(S.bottom < -k || S.top > window.innerHeight + k || S.right < -k || S.left > window.innerWidth + k) } for (const S of Z) if (!(S.width === 0 || S.height === 0) && !(S.bottom < -k || S.top > window.innerHeight + k || S.right < -k || S.left > window.innerWidth + k)) return !0; return !1 } a(pe, "isInExpandedViewport"); function Pe(l) { if (!l || l.nodeType !== Node.ELEMENT_NODE) return !1; const k = l.tagName.toLowerCase(); return new Set(["a", "button", "input", "select", "textarea", "details", "summary", "label"]).has(k) ? !0 : l.hasAttribute("onclick") || l.hasAttribute("role") || l.hasAttribute("tabindex") || l.hasAttribute("aria-") || l.hasAttribute("data-action") || l.getAttribute("contenteditable") === "true" } a(Pe, "isInteractiveCandidate"); const De = new Set(["a", "button", "input", "select", "textarea", "summary", "details", "label", "option"]), mn = new Set(["button", "link", "menuitem", "menuitemradio", "menuitemcheckbox", "radio", "checkbox", "tab", "switch", "slider", "spinbutton", "combobox", "searchbox", "textbox", "listbox", "option", "scrollbar"]); function Le(l) { if (!l || l.nodeType !== Node.ELEMENT_NODE || !re(l)) return !1; const k = l.hasAttribute("role") || l.hasAttribute("tabindex") || l.hasAttribute("onclick") || typeof l.onclick == "function", Z = /\b(btn|clickable|menu|item|entry|link)\b/i.test(l.className || ""), S = !!l.closest('button,a,[role="button"],.menu,.dropdown,.list,.toolbar'), E = [...l.children].some(re), B = l.parentElement && l.parentElement.isSameNode(document.body); return (me(l) || k || Z) && E && S && !B } a(Le, "isHeuristicallyInteractive"); function pn(l) { if (!l || l.nodeType !== Node.ELEMENT_NODE) return !1; const k = l.tagName.toLowerCase(), Z = l.getAttribute("role"); if (k === "iframe" || De.has(k) || Z && mn.has(Z) || l.isContentEditable || l.getAttribute("contenteditable") === "true" || l.hasAttribute("data-testid") || l.hasAttribute("data-cy") || l.hasAttribute("data-test") || l.hasAttribute("onclick") || typeof l.onclick == "function") return !0; try { const S = l?.ownerDocument?.defaultView?.getEventListenersForNode || window.getEventListenersForNode; if (typeof S == "function") { const B = S(l), N = ["click", "mousedown", "mouseup", "keydown", "keyup", "submit", "change", "input", "focus", "blur"]; for (const L of N) for (const T of B) if (T.type === L) return !0 } if (["onmousedown", "onmouseup", "onkeydown", "onkeyup", "onsubmit", "onchange", "oninput", "onfocus", "onblur"].some(B => l.hasAttribute(B))) return !0 } catch { } return !!Le(l) } a(pn, "isElementDistinctInteraction"); function hn(l, k, Z, S) { if (!l.isInteractive) return !1; let E = !1; return S ? pn(k) ? E = !0 : E = !1 : E = !0, E && (l.isInViewport = pe(k, c), (l.isInViewport || c === -1) && (l.highlightIndex = p++, o)) ? (s >= 0 ? s === l.highlightIndex && z(k, l.highlightIndex, Z) : z(k, l.highlightIndex, Z), !0) : !1 } a(hn, "handleHighlighting"); function Be(l, k = null, Z = !1) { if (!l || l.id === A || l.nodeType !== Node.ELEMENT_NODE && l.nodeType !== Node.TEXT_NODE || !l || l.id === A) return null; if (l.dataset?.browserUseIgnore === "true") return !0; if (l === document.body) { const N = { tagName: "body", attributes: {}, xpath: "/body", children: [] }; for (const T of l.childNodes) { const K = Be(T, k, !1); K && N.children.push(K) } const L = `${j.current++}`; return w[L] = N, L } if (l.nodeType !== Node.ELEMENT_NODE && l.nodeType !== Node.TEXT_NODE) return null; if (l.nodeType === Node.TEXT_NODE) { const N = l.textContent?.trim(); if (!N) return null; const L = l.parentElement; if (!L || L.tagName.toLowerCase() === "script") return null; const T = `${j.current++}`; return w[T] = { type: "TEXT_NODE", text: N, isVisible: M(l) }, T } if (l.nodeType === Node.ELEMENT_NODE && !Ye(l)) return null; if (c !== -1 && !l.shadowRoot) { const N = v(l), L = h(l), T = L && (L.position === "fixed" || L.position === "sticky"), K = l.offsetWidth > 0 || l.offsetHeight > 0; if (!N || !T && !K && (N.bottom < -c || N.top > window.innerHeight + c || N.right < -c || N.left > window.innerWidth + c)) return null } const S = { tagName: l.tagName.toLowerCase(), attributes: {}, children: [] }; if (Pe(l) || l.tagName.toLowerCase() === "iframe" || l.tagName.toLowerCase() === "body") { const N = l.getAttributeNames?.() || []; for (const L of N) { const T = l.getAttribute(L); S.attributes[L] = T } l.tagName.toLowerCase() === "input" && (l.type === "checkbox" || l.type === "radio") && (S.attributes.checked = l.checked ? "true" : "false") } let E = !1; if (l.nodeType === Node.ELEMENT_NODE && (S.isVisible = re(l), S.isVisible)) { S.isTopElement = Ae(l); const N = l.getAttribute("role"), L = N === "menu" || N === "menubar" || N === "listbox"; (S.isTopElement || L) && (S.isInteractive = me(l), E = hn(S, l, k, Z), S.ref = l) } if (l.tagName) { const N = l.tagName.toLowerCase(); if (N === "iframe") try { const L = l.contentDocument || l.contentWindow?.document; if (L) for (const T of L.childNodes) { const K = Be(T, l, !1); K && S.children.push(K) } } catch (L) { console.warn("Unable to access iframe:", L) } else if (l.isContentEditable || l.getAttribute("contenteditable") === "true" || l.id === "tinymce" || l.classList.contains("mce-content-body") || N === "body" && l.getAttribute("data-id")?.startsWith("mce_")) for (const L of l.childNodes) { const T = Be(L, k, E); T && S.children.push(T) } else { if (l.shadowRoot) { S.shadowRoot = !0; for (const L of l.shadowRoot.childNodes) { const T = Be(L, k, E); T && S.children.push(T) } } for (const L of l.childNodes) { const K = Be(L, k, E || Z); K && S.children.push(K) } } } if (S.tagName === "a" && S.children.length === 0 && !S.attributes.href) { const N = v(l); if (!(N && N.width > 0 && N.height > 0 || l.offsetWidth > 0 || l.offsetHeight > 0)) return null } S.extra = m.get(l) || null; const B = `${j.current++}`; return w[B] = S, B } a(Be, "buildDomTree"); const Re = Be(document.body); return b.clearCache(), { rootId: Re, map: w } }, "domTree"), Dl = new WeakMap; function Xh(e) { const n = []; for (const o of e.interactiveBlacklist || []) typeof o == "function" ? n.push(o()) : n.push(o); const r = []; for (const o of e.interactiveWhitelist || []) typeof o == "function" ? r.push(o()) : r.push(o); const i = Yh({ doHighlightElements: !0, debugMode: !0, focusHighlightIndex: -1, viewportExpansion: Wh, interactiveBlacklist: n, interactiveWhitelist: r, highlightOpacity: e.highlightOpacity ?? 0, highlightLabelOpacity: e.highlightLabelOpacity ?? .1 }), t = window.location.href; for (const o in i.map) { const s = i.map[o]; if (s.isInteractive && s.ref) { const c = s.ref; Dl.has(c) || (Dl.set(c, t), s.isNew = !0) } } return i } a(Xh, "getFlatTree"); function Qh(e, n) {
    const r = ["title", "type", "checked", "name", "role", "value", "placeholder", "data-date-format", "alt", "aria-label", "aria-expanded", "data-state", "aria-checked", "id", "for", "target", "aria-haspopup", "aria-controls", "aria-owns"], i = [...n || [], ...r], t = a((f, b) => f.length > b ? f.substring(0, b) + "..." : f, "capTextLength"), o = a(f => { const b = e.map[f]; if (!b) return null; if (b.type === "TEXT_NODE") { const v = b; return { type: "text", text: v.text, isVisible: v.isVisible, parent: null, children: [] } } else { const v = b, h = []; if (v.children) for (const y of v.children) { const w = o(y); w && (w.parent = null, h.push(w)) } return { type: "element", tagName: v.tagName, attributes: v.attributes ?? {}, isVisible: v.isVisible ?? !1, isInteractive: v.isInteractive ?? !1, isTopElement: v.isTopElement ?? !1, isNew: v.isNew ?? !1, highlightIndex: v.highlightIndex, parent: null, children: h, extra: v.extra ?? {} } } }, "buildTreeNode"), s = a((f, b = null) => { f.parent = b; for (const v of f.children) s(v, f) }, "setParentReferences"), c = o(e.rootId); if (!c) return ""; s(c); const u = a(f => { let b = f.parent; for (; b;) { if (b.type === "element" && b.highlightIndex !== void 0) return !0; b = b.parent } return !1 }, "hasParentWithHighlightIndex"), p = a((f, b, v) => { let h = b; const y = "	".repeat(b); if (f.type === "element") { if (f.highlightIndex !== void 0) { h += 1; const w = eg(f); let j = ""; if (i.length > 0 && f.attributes) { const I = {}; for (const re of i) { const me = f.attributes[re]; me && me.trim() !== "" && (I[re] = me.trim()) } const M = i.filter(re => re in I); if (M.length > 1) { const re = new Set, me = {}; for (const Ae of M) { const pe = I[Ae]; pe.length > 5 && (pe in me ? re.add(Ae) : me[pe] = Ae) } for (const Ae of re) delete I[Ae] } I.role === f.tagName && delete I.role; const Ye = ["aria-label", "placeholder", "title"]; for (const re of Ye) I[re] && I[re].toLowerCase().trim() === w.toLowerCase().trim() && delete I[re]; Object.keys(I).length > 0 && (j = Object.entries(I).map(([re, me]) => `${re}=${t(me, 20)}`).join(" ")) } const A = f.isNew ? `*[${f.highlightIndex}]` : `[${f.highlightIndex}]`; let z = `${y}${A}<${f.tagName ?? ""}`; if (j && (z += ` ${j}`), f.extra && f.extra.scrollable) { let I = ""; f.extra.scrollData?.left && (I += `left=${f.extra.scrollData.left}, `), f.extra.scrollData?.top && (I += `top=${f.extra.scrollData.top}, `), f.extra.scrollData?.right && (I += `right=${f.extra.scrollData.right}, `), f.extra.scrollData?.bottom && (I += `bottom=${f.extra.scrollData.bottom}`), z += ` data-scrollable="${I}"` } if (w) { const I = w.trim(); j || (z += " "), z += `>${I}` } else j || (z += " "); z += " />", v.push(z) } for (const w of f.children) p(w, h, v) } else if (f.type === "text") { if (u(f)) return; f.parent && f.parent.type === "element" && f.parent.isVisible && f.parent.isTopElement && v.push(`${y}${f.text ?? ""}`) } }, "processNode"), m = []; return p(c, 0, m), m.join(`
`)
  } a(Qh, "flatTreeToString"); const eg = a((e, n = -1) => {
    const r = [], i = a((t, o) => { if (!(n !== -1 && o > n) && !(t.type === "element" && t !== e && t.highlightIndex !== void 0)) { if (t.type === "text" && t.text) r.push(t.text); else if (t.type === "element") for (const s of t.children) i(s, o + 1) } }, "collectText"); return i(e, 0), r.join(`
`).trim()
  }, "getAllTextTillNextClickableElement"); function tg(e) { const n = new Map, r = Object.keys(e.map); for (const i of r) { const t = e.map[i]; t.isInteractive && typeof t.highlightIndex == "number" && n.set(t.highlightIndex, t) } return n } a(tg, "getSelectorMap"); function ng(e) {
    const n = e.split(`
`).map(i => i.trim()).filter(i => i.length > 0), r = new Map; for (const i of n) { const o = /^\[(\d+)\]<[^>]+>([^<]*)/.exec(i); if (o) { const s = parseInt(o[1], 10); r.set(s, i) } } return r
  } a(ng, "getElementTextMap"); function tt() { const e = window._highlightCleanupFunctions || []; for (const n of e) typeof n == "function" && n(); window._highlightCleanupFunctions = [] } a(tt, "cleanUpHighlights"), window.addEventListener("popstate", () => { tt() }), window.addEventListener("hashchange", () => { tt() }), window.addEventListener("beforeunload", () => { tt() }); const Yi = window.navigation; if (Yi && typeof Yi.addEventListener == "function") Yi.addEventListener("navigate", () => { tt() }); else { let e = window.location.href; setInterval(() => { window.location.href !== e && (e = window.location.href, tt()) }, 500) } function rg() { const e = window.innerWidth, n = window.innerHeight, r = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth || 0), i = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight || 0), t = window.scrollX || window.pageXOffset || document.documentElement.scrollLeft || 0, o = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0, s = Math.max(0, i - (window.innerHeight + o)), c = Math.max(0, r - (window.innerWidth + t)); return { viewport_width: e, viewport_height: n, page_width: r, page_height: i, scroll_x: t, scroll_y: o, pixels_above: o, pixels_below: s, pages_above: n > 0 ? o / n : 0, pages_below: n > 0 ? s / n : 0, total_pages: n > 0 ? i / n : 0, current_page_position: o / Math.max(1, i - n), pixels_left: t, pixels_right: c } } a(rg, "getPageInfo"); const Ll = { "en-US": { ui: { panel: { ready: "Ready", thinking: "Thinking...", paused: "Paused", taskInput: "Enter new task, describe steps in detail, press Enter to submit", userAnswerPrompt: "Please answer the question above, press Enter to submit", taskTerminated: "Task terminated", taskCompleted: "Task completed", continueExecution: "Continue execution", userAnswer: "User answer: {{input}}", question: "Question: {{question}}", waitingPlaceholder: "Waiting for task to start...", pause: "Pause", continue: "Continue", stop: "Stop", expand: "Expand history", collapse: "Collapse history", step: "Step {{number}} Â· {{time}}{{duration}}" }, tools: { clicking: "Clicking element [{{index}}]...", inputting: "Inputting text to element [{{index}}]...", selecting: 'Selecting option "{{text}}"...', scrolling: "Scrolling page...", waiting: "Waiting {{seconds}} seconds...", done: "Task done", clicked: "ðŸ–±ï¸ Clicked element [{{index}}]", inputted: 'Bot¨ï¸ Inputted text "{{text}}"', selected: 'â˜‘ï¸ Selected option "{{text}}"', scrolled: "ðŸ›ž Page scrolled", waited: "Bot›ï¸ Wait completed", executing: "Executing {{toolName}}...", resultSuccess: "success", resultFailure: "failed", resultError: "error" }, errors: { elementNotFound: "No interactive element found at index {{index}}", taskRequired: "Task description is required", executionFailed: "Task execution failed", notInputElement: "Element is not an input or textarea", notSelectElement: "Element is not a select element", optionNotFound: 'Option "{{text}}" not found' } } }, "zh-CN": { ui: { panel: { ready: "Fintifi Ai ", thinking: "Thinking.....", paused: "Pause", taskInput: "Search Page", userAnswerPrompt: "Try Again", taskTerminated: "ä»»åŠ¡å·²Close", taskCompleted: "ä»»åŠ¡ç»“æŸ", continueExecution: "continue Execution", userAnswer: "User: {{input}}", question: "🤔: {{question}}", waitingPlaceholder: "Fintifi Ai", pause: "Pause", continue: "ç»§ç»­", stop: "Close", expand: "Expand", collapse: "collapse", step: "Time{{number}} · {{time}}{{duration}}" }, tools: { clicking: "æ­£åœ¨ç‚¹å‡»å…ƒç´  [{{index}}]...", inputting: "æ­£åœ¨è¾“å…¥æ–‡æœ¬åˆ°å…ƒç´  [{{index}}]...", selecting: 'æ­£åœ¨é€‰æ‹©é€‰é¡¹ "{{text}}"...', scrolling: "æ­£åœ¨æ»šåŠ¨é¡µé¢...", waiting: "ç­‰å¾… {{seconds}} ç§’...", done: "ç»“æŸä»»åŠ¡", clicked: "ðŸ–±ï¸ å·²ç‚¹å‡»å…ƒç´  [{{index}}]", inputted: 'Bot¨ï¸ å·²è¾“å…¥æ–‡æœ¬ "{{text}}"', selected: 'â˜‘ï¸ å·²é€‰æ‹©é€‰é¡¹ "{{text}}"', scrolled: "ðŸ›ž é¡µé¢æ»šåŠ¨å®Œæˆ", waited: "Bot›ï¸ ç­‰å¾…å®Œæˆ", executing: "🙅🏻‍♂️{{toolName}}...", resultSuccess: "æˆåŠŸ", resultFailure: "å¤±è´¥", resultError: "é”™è¯¯" }, errors: { elementNotFound: "æœªæ‰¾åˆ°ç´¢å¼•ä¸º {{index}} çš„äº¤äº’å…ƒç´ ", taskRequired: "ä»»åŠ¡æè¿°ä¸èƒ½ä¸ºç©º", executionFailed: "ä»»åŠ¡æ‰§è¡Œå¤±è´¥", notInputElement: "å…ƒç´ ä¸æ˜¯è¾“å…¥æ¡†æˆ–æ–‡æœ¬åŸŸ", notSelectElement: "å…ƒç´ ä¸æ˜¯é€‰æ‹©æ¡†", optionNotFound: 'æœªæ‰¾åˆ°é€‰é¡¹ "{{text}}"' } } } }, _o = class _o { language; translations; constructor(n = "en-US") { this.language = n in Ll ? n : "en-US", this.translations = Ll[n] } t(n, r) { const i = this.getNestedValue(this.translations, n); return i ? r ? this.interpolate(i, r) : i : (console.warn(`Translation key "${n}" not found for language "${this.language}"`), n) } getNestedValue(n, r) { return r.split(".").reduce((i, t) => i?.[t], n) } interpolate(n, r) { return n.replace(/\{\{(\w+)\}\}/g, (i, t) => r[t] != null ? r[t].toString() : i) } getLanguage() { return this.language } }; a(_o, "I18n"); let Xi = _o; function ig(e) { return { baseURL: e.baseURL ?? Jh, apiKey: e.apiKey ?? Vh, model: e.model ?? Gh, temperature: e.temperature ?? Kh, maxTokens: e.maxTokens ?? qh, maxRetries: e.maxRetries ?? Hh } } a(ig, "parseLLMConfig"); const bo = class bo extends EventTarget { on(n, r) { const i = a(t => { const s = t.detail?.[0]; return r(s) }, "wrappedHandler"); this.addEventListener(n, i) } once(n, r) { const i = a(t => { const s = t.detail?.[0]; return r(s) }, "wrappedHandler"); this.addEventListener(n, i, { once: !0 }) } emit(n, ...r) { const i = new CustomEvent(n, { detail: r }); this.dispatchEvent(i) } }; a(bo, "EventBus"); let Qi = bo; const eo = new Map; function Rl(e) { if (eo.has(e)) return eo.get(e); const n = new Qi; return eo.set(e, n), n } a(Rl, "getEventBus"); const ee = { NETWORK_ERROR: "network_error", RATE_LIMIT: "rate_limit", SERVER_ERROR: "server_error", NO_TOOL_CALL: "no_tool_call", INVALID_TOOL_ARGS: "invalid_tool_args", TOOL_EXECUTION_ERROR: "tool_execution_error", UNKNOWN: "unknown", AUTH_ERROR: "auth_error", CONTEXT_LENGTH: "context_length", CONTENT_FILTER: "content_filter" }, yo = class yo extends Error { type; retryable; statusCode; rawError; constructor(n, r, i) { super(r), this.name = "InvokeError", this.type = n, this.retryable = this.isRetryable(n), this.rawError = i } isRetryable(n) { return [ee.NETWORK_ERROR, ee.RATE_LIMIT, ee.SERVER_ERROR, ee.NO_TOOL_CALL, ee.INVALID_TOOL_ARGS, ee.TOOL_EXECUTION_ERROR, ee.UNKNOWN].includes(n) } }; a(yo, "InvokeError"); let se = yo; function og(e, n) { return { type: "function", function: { name: e, description: n.description, parameters: pi(n.inputSchema, { target: "openapi-3.0" }) } } } a(og, "zodToOpenAITool"); function ag(e, n) { const r = e.choices?.[0]; if (!r) throw new se(ee.UNKNOWN, "No choices in response", e); switch (r.finish_reason) { case "tool_calls": case "stop": break; case "length": throw new se(ee.CONTEXT_LENGTH, "Response truncated: max tokens reached"); case "content_filter": throw new se(ee.CONTENT_FILTER, "Content filtered by safety system"); default: throw new se(ee.UNKNOWN, `Unexpected finish_reason: ${r.finish_reason}`) }if (!n.shape.action) throw new Error('inputSchema must have an "action" field'); let t = null; const o = r.message?.tool_calls?.[0]?.function; if (t = o?.arguments ?? null, t && o.name !== "AgentOutput") { console.log(ge.yellow("lenientParseMacroToolCall: #1 fixing incorrect tool call")); let u; try { u = JSON.parse(t) } catch (p) { throw new se(ee.INVALID_TOOL_ARGS, "Failed to parse tool arguments as JSON", p) } t = JSON.stringify({ action: { [o.name]: u } }) } if (t || (t = r.message?.content.trim() || null), !t) throw new se(ee.NO_TOOL_CALL, "No tool call or content found in response", e); let s; try { s = JSON.parse(t) } catch (u) { throw new se(ee.INVALID_TOOL_ARGS, "Failed to parse tool arguments as JSON", u) } if (s.action || s.evaluation_previous_goal || s.next_goal) s.action || (console.log(ge.yellow("lenientParseMacroToolCall: #2 fixing incorrect tool call")), s.action = { wait: { seconds: 1 } }); else if (s.type && s.function) { if (s.function.name !== "AgentOutput") throw new se(ee.INVALID_TOOL_ARGS, `Expected function name "AgentOutput", got "${s.function.name}"`, null); console.log(ge.yellow("lenientParseMacroToolCall: #3 fixing incorrect tool call")), s = s.function.arguments } else if (s.name && s.arguments) { if (s.name !== "AgentOutput") throw new se(ee.INVALID_TOOL_ARGS, `Expected function name "AgentOutput", got "${s.name}"`, null); console.log(ge.yellow("lenientParseMacroToolCall: #4 fixing incorrect tool call")), s = s.arguments } else console.log(ge.yellow("lenientParseMacroToolCall: #5 fixing incorrect tool call")), s = { action: s }; if (typeof s == "string") { console.log(ge.yellow("lenientParseMacroToolCall: #6 fixing incorrect tool call")); try { s = JSON.parse(s) } catch (u) { throw new se(ee.INVALID_TOOL_ARGS, "Failed to parse nested tool arguments as JSON", u) } } const c = n.safeParse(s); if (c.success) return c.data; { const u = s.action ?? {}, p = Object.keys(u)[0] || "unknown", m = JSON.stringify(u[p] || "unknown"); throw new se(ee.INVALID_TOOL_ARGS, `Tool arguments validation failed: action "${p}" with args ${m}`, c.error) } } a(ag, "lenientParseMacroToolCall"); function sg(e) { const n = e.model || ""; return n.toLowerCase().startsWith("claude") && (e.tool_choice = { type: "tool", name: "AgentOutput" }, e.thinking = { type: "disabled" }), n.toLowerCase().includes("grok") && (console.log("Applying Grok patch: removing tool_choice"), delete e.tool_choice, console.log("Applying Grok patch: disable reasoning and thinking"), e.thinking = { type: "disabled", effort: "minimal" }, e.reasoning = { enabled: !1, effort: "low" }), e } a(sg, "modelPatch"); const $o = class $o { config; constructor(n) { this.config = n } async invoke(n, r, i) { const t = Object.entries(r).map(([m, f]) => og(m, f)); let o; try { o = await fetch(`${this.config.baseURL}/chat/completions`, { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${this.config.apiKey}` }, body: JSON.stringify(sg({ model: this.config.model, temperature: this.config.temperature, max_tokens: this.config.maxTokens, messages: n, tools: t, tool_choice: { type: "function", function: { name: "AgentOutput" } }, parallel_tool_calls: !1 })), signal: i }) } catch (m) { throw new se(ee.NETWORK_ERROR, "Network request failed", m) } if (!o.ok) { const m = await o.json().catch(), f = m.error?.message || o.statusText; throw o.status === 401 || o.status === 403 ? new se(ee.AUTH_ERROR, `Authentication failed: ${f}`, m) : o.status === 429 ? new se(ee.RATE_LIMIT, `Rate limit exceeded: ${f}`, m) : o.status >= 500 ? new se(ee.SERVER_ERROR, `Server error: ${f}`, m) : new se(ee.UNKNOWN, `HTTP ${o.status}: ${f}`, m) } const s = await o.json(), c = r.AgentOutput, u = ag(s, c.inputSchema); let p; try { p = await c.execute(u) } catch (m) { throw new se(ee.TOOL_EXECUTION_ERROR, `Tool execution failed: ${m.message}`, m) } return { toolCall: { name: "AgentOutput", args: u }, toolResult: p, usage: { promptTokens: s.usage?.prompt_tokens ?? 0, completionTokens: s.usage?.completion_tokens ?? 0, totalTokens: s.usage?.total_tokens ?? 0, cachedTokens: s.usage?.prompt_tokens_details?.cached_tokens, reasoningTokens: s.usage?.completion_tokens_details?.reasoning_tokens }, rawResponse: s } } }; a($o, "OpenAIClient"); let to = $o; const wo = class wo { constructor(n, r) { te(this, "config"); te(this, "id"); te(this, "client"); G(this, Pt); this.config = ig(n), this.id = r, R(this, Pt, Rl(r)), this.client = new to({ model: this.config.model, apiKey: this.config.apiKey, baseURL: this.config.baseURL, temperature: this.config.temperature, maxTokens: this.config.maxTokens }) } async invoke(n, r, i) { return await cg(async () => await this.client.invoke(n, r, i), { maxRetries: this.config.maxRetries, onRetry: a(t => { g(this, Pt).emit("panel:update", { type: "retry", displayText: `retry-ing (${t} / ${this.config.maxRetries})` }) }, "onRetry"), onError: a((t, o) => { g(this, Pt).emit("panel:update", { type: "error", displayText: `step failed: ${t.message}` }) }, "onError") }) } }; Pt = new WeakMap, a(wo, "LLM"); let no = wo; async function cg(e, n) { let r = 0, i = null; for (; r <= n.maxRetries;) { r > 0 && (n.onRetry(r), await new Promise(t => setTimeout(t, 100))); try { return await e() } catch (t) { if (console.error(t), n.onError(t, r < n.maxRetries), t?.name === "AbortError" || t instanceof se && !t.retryable) throw t; i = t, r++, await new Promise(o => setTimeout(o, 100)) } } throw i } a(cg, "withRetry"); function ug(e) { const n = document.querySelectorAll('[data-reactroot], [data-reactid], [data-react-checksum], #root, #app, [id^="root-"], [id^="app-"], #adex-wrapper, #adex-root'); for (const r of n) r.setAttribute("data-page-agent-not-interactive", "true") } a(ug, "patchReact"); const lg = `You are an AI agent designed to operate in an iterative loop to automate browser tasks. Your ultimate goal is accomplishing the task provided in <user_request>.

<intro>
You excel at following tasks:
1. Navigating complex websites and extracting precise information
2. Automating form submissions and interactive web actions
3. Gathering and saving information 
4. Operate effectively in an agent loop
5. Efficiently performing diverse web tasks
</intro>

<language_settings>
- Default working language: **ä¸­æ–‡**
- Use the language that user is using. Return in user's language.
</language_settings>

<input>
At every step, your input will consist of: 
1. <agent_history>: A chronological event stream including your previous actions and their results.
2. <agent_state>: Current <user_request> and <step_info>.
3. <browser_state>: Current URL, interactive elements indexed for actions, and visible page content.
</input>

<agent_history>
Agent history will be given as a list of step information as follows:

<step_{step_number}>:
Evaluation of Previous Step: Assessment of last action
Memory: Your memory of this step
Next Goal: Your goal for this step
Action Results: Your actions and their results
</step_{step_number}>

and system messages wrapped in <sys> tag.
</agent_history>

<user_request>
USER REQUEST: This is your ultimate objective and always remains visible.
- This has the highest priority. Make the user happy.
- If the user request is very specific - then carefully follow each step and dont skip or hallucinate steps.
- If the task is open ended you can plan yourself how to get it done.
</user_request>

<browser_state>
1. Browser State will be given as:

Current URL: URL of the page you are currently viewing.
Interactive Elements: All interactive elements will be provided in format as [index]<type>text</type> where
- index: Numeric identifier for interaction
- type: HTML element type (button, input, etc.)
- text: Element description

Examples:
[33]<div>User form</div>
\\t*[35]<button aria-label='Submit form'>Submit</button>

Note that:
- Only elements with numeric indexes in [] are interactive
- (stacked) indentation (with \\t) is important and means that the element is a (html) child of the element above (with a lower index)
- Elements tagged with \`*[\` are the new clickable elements that appeared on the website since the last step - if url has not changed.
- Pure text elements without [] are not interactive.
</browser_state>

<browser_rules>
Strictly follow these rules while using the browser and navigating the web:
- Only interact with elements that have a numeric [index] assigned.
- Only use indexes that are explicitly provided.
- If the page changes after, for example, an input text action, analyze if you need to interact with new elements, e.g. selecting the right option from the list.
- By default, only elements in the visible viewport are listed. Use scrolling actions if you suspect relevant content is offscreen which you need to interact with. Scroll ONLY if there are more pixels below or above the page.
- You can scroll by a specific number of pages using the num_pages parameter (e.g., 0.5 for half page, 2.0 for two pages).
- All the elements that are scrollable are marked with \`data-scrollable\` attribute. Including the scrollable distance in every directions. You can scroll *the element* in case some area are overflowed.
- If a captcha appears, tell user you can not solve captcha. finished the task and ask user to solve it.
- If expected elements are missing, try scrolling, or navigating back.
- If the page is not fully loaded, use the \`wait\` action.
- Do not repeat one action for more than 3 times unless some conditions changed.
- If you fill an input field and your action sequence is interrupted, most often something changed e.g. suggestions popped up under the field.
- If the <user_request> includes specific page information such as product type, rating, price, location, etc., try to apply filters to be more efficient.
- The <user_request> is the ultimate goal. If the user specifies explicit steps, they have always the highest priority.
- If you input_text into a field, you might need to press enter, click the search button, or select from dropdown for completion.
- Don't login into a page if you don't have to. Don't login if you don't have the credentials. 
- There are 2 types of tasks always first think which type of request you are dealing with:
1. Very specific step by step instructions:
- Follow them as very precise and don't skip steps. Try to complete everything as requested.
2. Open ended tasks. Plan yourself, be creative in achieving them.
- If you get stuck e.g. with logins or captcha in open-ended tasks you can re-evaluate the task and try alternative ways, e.g. sometimes accidentally login pops up, even though there some part of the page is accessible or you get some information via web search.
</browser_rules>

<capability>
- You can only handle single page app. Do not jump out of current page.
- Do not click on link if it will open in a new page (etc. <a target="_blank">)
- It is ok to fail the task.
	- User can be wrong. If the request of user is not achievable, inappropriate or you do not have enough information or tools to achieve it. Tell user to make a better request.
	- Webpage can be broken. All webpages or apps have bugs. Some bug will make it hard for your job. It's encouraged to tell user the problem of current page. Your feedbacks (including failing) are valuable for user.
	- Trying to hard can be harmful. Repeating some action back and forth or pushing for a complex procedure with little knowledge can cause unwanted result and harmful side-effects. User would rather you to complete the task with a fail.
- If you are not clear about the request or steps. \`ask_user\` to clarify it.
- If you do not have knowledge for the current webpage or task. You must require user to give specific instructions and detailed steps.
</capability>

<task_completion_rules>
You must call the \`done\` action in one of three cases:
- When you have fully completed the USER REQUEST.
- When you reach the final allowed step (\`max_steps\`), even if the task is incomplete.
- When you feel stuck or unable to solve user request. Or user request is not clear or contains inappropriate content.
- If it is ABSOLUTELY IMPOSSIBLE to continue.

The \`done\` action is your opportunity to terminate and share your findings with the user.
- Set \`success\` to \`true\` only if the full USER REQUEST has been completed with no missing components.
- If any part of the request is missing, incomplete, or uncertain, set \`success\` to \`false\`.
- You can use the \`text\` field of the \`done\` action to communicate your findings and to provide a coherent reply to the user and fulfill the USER REQUEST.
- You are ONLY ALLOWED to call \`done\` as a single action. Don't call it together with other actions.
- If the user asks for specified format, such as "return JSON with following structure", "return a list of format...", MAKE sure to use the right format in your answer.
- If the user asks for a structured output, your \`done\` action's schema may be modified. Take this schema into account when solving the task!
</task_completion_rules>

<reasoning_rules>
Exhibit the following reasoning patterns to successfully achieve the <user_request>:

- Reason about <agent_history> to track progress and context toward <user_request>.
- Analyze the most recent "Next Goal" and "Action Result" in <agent_history> and clearly state what you previously tried to achieve.
- Analyze all relevant items in <agent_history> and <browser_state> to understand your state.
- Explicitly judge success/failure/uncertainty of the last action. Never assume an action succeeded just because it appears to be executed in your last step in <agent_history>. If the expected change is missing, mark the last action as failed (or uncertain) and plan a recovery.
- Analyze whether you are stuck, e.g. when you repeat the same actions multiple times without any progress. Then consider alternative approaches e.g. scrolling for more context or ask user for help.
- \`ask_user\` for help if you have any difficulty. Users want to be kept in the loop.
- If you see information relevant to <user_request>, plan saving the information to memory.
- Always reason about the <user_request>. Make sure to carefully analyze the specific steps and information required. E.g. specific filters, specific form fields, specific information to search. Make sure to always compare the current trajectory with the user request and think carefully if thats how the user requested it.
</reasoning_rules>

<examples>
Here are examples of good output patterns. Use them as reference but never copy them directly.

<evaluation_examples>
- Positive Examples:
"evaluation_previous_goal": "Successfully navigated to the product page and found the target information. Verdict: Success"
"evaluation_previous_goal": "Clicked the login button and user authentication form appeared. Verdict: Success"
</evaluation_examples>

<memory_examples>
"memory": "Found many pending reports that need to be analyzed in the main page. Successfully processed the first 2 reports on quarterly sales data and moving on to inventory analysis and customer feedback reports."
</memory_examples>

<next_goal_examples>
"next_goal": "Click on the 'Add to Cart' button to proceed with the purchase flow."
"next_goal": "Extract details from the first item on the page."
</next_goal_examples>
</examples>

<output>
You must ALWAYS respond with a valid JSON in this exact format:

{
  "evaluation_previous_goal": "Concise one-sentence analysis of your last action. Clearly state success, failure, or uncertain.",
  "memory": "1-3 concise sentences of specific memory of this step and overall progress. You should put here everything that will help you track progress in future steps. Like counting pages visited, items found, etc.",
  "next_goal": "State the next immediate goal and action to achieve it, in one clear sentence."
  "action":{"one_action_name": {// action-specific parameter}}
}
</output>
`; async function ye(e) { await new Promise(n => setTimeout(n, e * 1e3)) } a(ye, "waitFor"); let ro = window.location.href; async function nt() {
    return ro === window.location.href ? "" : (await ye(.3), ro = window.location.href, `
<sys> Current URL changed to: ${ro} </sys>`)
  } a(nt, "getSystemInfo"); async function Cl(e) { const n = e.getBoundingClientRect(), r = n.left + n.width / 2, i = n.top + n.height / 2; window.dispatchEvent(new CustomEvent("PageAgent::MovePointerTo", { detail: { x: r, y: i } })), await ye(.3) } a(Cl, "movePointerToElement"); function At(e, n) { const r = e.selectorMap.get(n); if (!r) throw new Error(`No interactive element found at index ${n}`); const i = r.ref; if (!i) throw new Error(`Element at index ${n} does not have a reference`); if (!(i instanceof HTMLElement)) throw new Error(`Element at index ${n} is not an HTMLElement`); return i } a(At, "getElementByIndex"); let un = null; function Zl() { un && (un.blur(), un.dispatchEvent(new MouseEvent("mouseout", { bubbles: !0, cancelable: !0 })), un = null) } a(Zl, "blurLastClickedElement"); async function io(e) { Zl(), un = e, await Bl(e), await Cl(e), window.dispatchEvent(new CustomEvent("PageAgent::ClickPointer")), await ye(.1), e.dispatchEvent(new MouseEvent("mouseenter", { bubbles: !0, cancelable: !0 })), e.dispatchEvent(new MouseEvent("mouseover", { bubbles: !0, cancelable: !0 })), e.dispatchEvent(new MouseEvent("mousedown", { bubbles: !0, cancelable: !0 })), e.focus(), e.dispatchEvent(new MouseEvent("mouseup", { bubbles: !0, cancelable: !0 })), e.dispatchEvent(new MouseEvent("click", { bubbles: !0, cancelable: !0 })), await ye(.1) } a(io, "clickElement"); const dg = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value").set, fg = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, "value").set; async function mg(e, n) { e.dispatchEvent(new KeyboardEvent("keydown", { bubbles: !0, cancelable: !0, key: n })), await ye(.01), (e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement) && (e.dispatchEvent(new Event("beforeinput", { bubbles: !0 })), await ye(.01), e.dispatchEvent(new Event("input", { bubbles: !0 })), await ye(.01)), e.dispatchEvent(new KeyboardEvent("keyup", { bubbles: !0, cancelable: !0, key: n })) } a(mg, "createSyntheticInputEvent"); async function Ml(e, n) { if (!(e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement)) throw new Error("Element is not an input or textarea"); await io(e), e instanceof HTMLTextAreaElement ? fg.call(e, n) : dg.call(e, n); const r = new Event("input", { bubbles: !0 }); e.dispatchEvent(r), await ye(.1), Zl() } a(Ml, "inputTextElement"); async function Fl(e, n) { if (!(e instanceof HTMLSelectElement)) throw new Error("Element is not a select element"); const i = Array.from(e.options).find(t => t.textContent?.trim() === n.trim()); if (!i) throw new Error(`Option with text "${n}" not found in select element`); e.value = i.value, e.dispatchEvent(new Event("change", { bubbles: !0 })), await ye(.1) } a(Fl, "selectOptionElement"); async function Bl(e) { const n = e; n.scrollIntoViewIfNeeded ? n.scrollIntoViewIfNeeded() : n.scrollIntoView({ behavior: "auto", block: "center", inline: "nearest" }) } a(Bl, "scrollIntoViewIfNeeded"); async function Wl(e, n, r) { if (r) { const c = r; console.log("[SCROLL DEBUG] Starting direct container scroll for element:", c.tagName); let u = c, p = !1, m = null, f = 0, b = 0; const v = n; for (; u && b < 10;) { const h = window.getComputedStyle(u), y = /(auto|scroll|overlay)/.test(h.overflowY), w = u.scrollHeight > u.clientHeight; if (console.log("[SCROLL DEBUG] Checking element:", u.tagName, "hasScrollableY:", y, "canScrollVertically:", w, "scrollHeight:", u.scrollHeight, "clientHeight:", u.clientHeight), y && w) { const j = u.scrollTop, A = u.scrollHeight - u.clientHeight; let z = v / 3; z > 0 ? z = Math.min(z, A - j) : z = Math.max(z, -j), u.scrollTop = j + z; const I = u.scrollTop, M = I - j; if (console.log("[SCROLL DEBUG] Scroll attempt:", u.tagName, "before:", j, "after:", I, "delta:", M), Math.abs(M) > .5) { p = !0, m = u, f = M, console.log("[SCROLL DEBUG] Successfully scrolled container:", u.tagName, "delta:", M); break } } if (u === document.body || u === document.documentElement) break; u = u.parentElement, b++ } return p ? `Scrolled container (${m?.tagName}) by ${f}px` : `No scrollable container found for element (${c.tagName})` } const i = n, t = a(c => c.clientHeight >= window.innerHeight * .5, "bigEnough"), o = a(c => c && /(auto|scroll|overlay)/.test(getComputedStyle(c).overflowY) && c.scrollHeight > c.clientHeight && t(c), "canScroll"); let s = document.activeElement; for (; s && !o(s) && s !== document.body;)s = s.parentElement; return s = o(s) ? s : Array.from(document.querySelectorAll("*")).find(o) || document.scrollingElement || document.documentElement, s === document.scrollingElement || s === document.documentElement || s === document.body ? (window.scrollBy(0, i), `Bot… Scrolled page by ${i}px.`) : (s.scrollBy({ top: i, behavior: "smooth" }), await ye(.1), `Bot… Scrolled container (${s.tagName}) by ${i}px.`) } a(Wl, "scrollVertically"); async function Gl(e, n, r) { if (r) { const c = r; console.log("[SCROLL DEBUG] Starting direct container scroll for element:", c.tagName); let u = c, p = !1, m = null, f = 0, b = 0; const v = e ? n : -n; for (; u && b < 10;) { const h = window.getComputedStyle(u), y = /(auto|scroll|overlay)/.test(h.overflowX), w = u.scrollWidth > u.clientWidth; if (console.log("[SCROLL DEBUG] Checking element:", u.tagName, "hasScrollableX:", y, "canScrollHorizontally:", w, "scrollWidth:", u.scrollWidth, "clientWidth:", u.clientWidth), y && w) { const j = u.scrollLeft, A = u.scrollWidth - u.clientWidth; let z = v / 3; z > 0 ? z = Math.min(z, A - j) : z = Math.max(z, -j), u.scrollLeft = j + z; const I = u.scrollLeft, M = I - j; if (console.log("[SCROLL DEBUG] Scroll attempt:", u.tagName, "before:", j, "after:", I, "delta:", M), Math.abs(M) > .5) { p = !0, m = u, f = M, console.log("[SCROLL DEBUG] Successfully scrolled container:", u.tagName, "delta:", M); break } } if (u === document.body || u === document.documentElement) break; u = u.parentElement, b++ } return p ? `Scrolled container (${m?.tagName}) horizontally by ${f}px` : `No horizontally scrollable container found for element (${c.tagName})` } const i = e ? n : -n, t = a(c => c.clientWidth >= window.innerWidth * .5, "bigEnough"), o = a(c => c && /(auto|scroll|overlay)/.test(getComputedStyle(c).overflowX) && c.scrollWidth > c.clientWidth && t(c), "canScroll"); let s = document.activeElement; for (; s && !o(s) && s !== document.body;)s = s.parentElement; return s = o(s) ? s : Array.from(document.querySelectorAll("*")).find(o) || document.scrollingElement || document.documentElement, s === document.scrollingElement || s === document.documentElement || s === document.body ? (window.scrollBy(i, 0), `Bot… Scrolled page horizontally by ${i}px`) : (s.scrollBy({ left: i, behavior: "smooth" }), await ye(.1), `Bot… Scrolled container (${s.tagName}) horizontally by ${i}px`) } a(Gl, "scrollHorizontally"); const pg = Object.freeze(Object.defineProperty({ __proto__: null, clickElement: io, createSyntheticInputEvent: mg, getElementByIndex: At, getSystemInfo: nt, inputTextElement: Ml, movePointerToElement: Cl, scrollHorizontally: Gl, scrollIntoViewIfNeeded: Bl, scrollVertically: Wl, selectOptionElement: Fl, waitFor: ye }, Symbol.toStringTag, { value: "Module" })); window.utils = pg; function Xg(e) { return e } a(Xg, "tool"); const Je = new Map; Je.set("done", { description: "Complete task - provide a summary of results for the user. Set success=True if task completed successfully, false otherwise. Text should be your response to the user summarizing results.", inputSchema: V.object({ text: V.string(), success: V.boolean().default(!0) }), execute: a(async function (e) { return Promise.resolve("Task completed") }, "execute") }), Je.set("wait", { description: "Wait for x seconds. default 1s (max 10 seconds, min 1 second). This can be used to wait until the page or data is fully loaded.", inputSchema: V.object({ seconds: V.number().min(1).max(10).default(1) }), execute: a(async function (e) { const n = this.lastTimeUpdate, r = Math.max(0, e.seconds - (Date.now() - n) / 1e3); return console.log(`actualWaitTime: ${r} seconds`), await ye(r), `Bot… Waited for ${e.seconds} seconds.` + await nt() }, "execute") }), Je.set("ask_user", { description: "Ask the user a question and wait for their answer. Use this if you need more information or clarification.", inputSchema: V.object({ question: V.string() }), execute: a(async function (e) { return `Bot… Received user answer: ${await this.panel.askUser(e.question)}` + await nt() }, "execute") }), Je.set("click_element_by_index", { description: "Click element by index", inputSchema: V.object({ index: V.int().min(0) }), execute: a(async function (e) { const n = At(this, e.index), r = this.elementTextMap.get(e.index); return await io(n), n instanceof HTMLAnchorElement && n.target === "_blank" ? `âš ï¸ Clicked link that opens in a new tab (${r || e.index}). You are not capable of reading new tabs.` : `Bot… Clicked element (${r || e.index}).` + await nt() }, "execute") }), Je.set("input_text", { description: "Click and input text into a input interactive element", inputSchema: V.object({ index: V.int().min(0), text: V.string() }), execute: a(async function (e) { const n = At(this, e.index), r = this.elementTextMap.get(e.index); return await Ml(n, e.text), `Bot… Input text (${e.text}) into element (${r || e.index}).` + await nt() }, "execute") }), Je.set("select_dropdown_option", { description: "Select dropdown option for interactive element index by the text of the option you want to select", inputSchema: V.object({ index: V.int().min(0), text: V.string() }), execute: a(async function (e) { const n = At(this, e.index), r = this.elementTextMap.get(e.index); return await Fl(n, e.text), `Bot… Selected option (${e.text}) in element (${r || e.index}).` + await nt() }, "execute") }), Je.set("scroll", { description: "Scroll the page by specified number of pages (set down=True to scroll down, down=False to scroll up, num_pages=number of pages to scroll like 0.5 for half page, 1.0 for one page, etc.). Optional index parameter to scroll within a specific element or its scroll container (works well for dropdowns and custom UI components). Optional pixels parameter to scroll by a specific number of pixels instead of pages.", inputSchema: V.object({ down: V.boolean().default(!0), num_pages: V.number().min(0).max(10).optional().default(.1), pixels: V.number().int().min(0).optional(), index: V.number().int().min(0).optional() }), execute: a(async function (e) { const { down: n, num_pages: r, index: i, pixels: t } = e, o = t || r * (n ? 1 : -1) * window.innerHeight, s = i !== void 0 ? At(this, i) : null; return await Wl(n, o, s) + await nt() }, "execute") }), Je.set("scroll_horizontally", { description: "Scroll the page or element horizontally (set right=True to scroll right, right=False to scroll left, pixels=number of pixels to scroll). Optional index parameter to scroll within a specific element or its scroll container (works well for wide tables).", inputSchema: V.object({ right: V.boolean().default(!0), pixels: V.number().int().min(0), index: V.number().int().min(0).optional() }), execute: a(async function (e) { const { right: n, pixels: r, index: i } = e, t = r * (n ? 1 : -1), o = i !== void 0 ? At(this, i) : null; return await Gl(n, t, o) + await nt() }, "execute") }); async function Vl(e, n = 60 * 601e3) { return e() ? !0 : new Promise((r, i) => { const t = Date.now(), o = setInterval(() => { e() ? (clearInterval(o), r(!0)) : Date.now() - t > n && (clearInterval(o), i(new Error("Timeout waiting for condition to become true"))) }, 100) }) } a(Vl, "waitUntil"); function hg(e, n) { return e.length > n ? e.substring(0, n) + "..." : e } a(hg, "truncate"); function oo(e) {
    return e.split(`
`).map(n => n.trim()).join(`
`)
  } a(oo, "trimLines"); function gg(e) { let n = Math.random().toString(36).substring(2, 11); if (!e) return n; const r = 1e3; let i = 0; for (; e.includes(n);)if (n = Math.random().toString(36).substring(2, 11), i++, i > r) throw new Error("randomID: too many try"); return n } a(gg, "randomID"), window.__PAGE_AGENT_IDS__ || (window.__PAGE_AGENT_IDS__ = []); const Jl = window.__PAGE_AGENT_IDS__; function Hl() { const e = gg(Jl); return Jl.push(e), e } a(Hl, "uid"); const ko = class ko { steps = []; currentStep = null; status = "idle"; stepCounter = 0; addStep(n) { const r = { id: this.generateId(), stepNumber: ++this.stepCounter, timestamp: new Date, ...n }; return this.steps.push(r), this.currentStep = r, this.updateStatus(r.type), r } updateCurrentStep(n) { return this.currentStep ? (Object.assign(this.currentStep, n), this.currentStep) : null } getCurrentStep() { return this.currentStep } getAllSteps() { return [...this.steps] } getStatus() { return this.status } reset() { this.steps = [], this.currentStep = null, this.status = "idle", this.stepCounter = 0 } updateStatus(n) { switch (n) { case "thinking": case "tool_executing": case "output": case "input": case "retry": this.status = "running"; break; case "completed": this.status = "completed"; break; case "error": this.status = "error"; break } } generateId() { return `step_${Date.now()}_${Math.random().toString(36).substring(2, 11)}` } }; a(ko, "UIState"); let ao = ko; const O = { wrapper: "_wrapper_1j0ct_1", "mask-running": "_mask-running_1j0ct_1", background: "_background_1j0ct_39", header: "_header_1j0ct_99", pulse: "_pulse_1j0ct_1", retryPulse: "_retryPulse_1j0ct_1", statusTextFadeOut: "_statusTextFadeOut_1j0ct_1", statusTextFadeIn: "_statusTextFadeIn_1j0ct_1", statusSection: "_statusSection_1j0ct_121", indicator: "_indicator_1j0ct_128", thinking: "_thinking_1j0ct_137", tool_executing: "_tool_executing_1j0ct_142", retry: "_retry_1j0ct_147", completed: "_completed_1j0ct_153", input: "_input_1j0ct_154", output: "_output_1j0ct_155", error: "_error_1j0ct_160", statusText: "_statusText_1j0ct_166", fadeOut: "_fadeOut_1j0ct_178", fadeIn: "_fadeIn_1j0ct_182", controls: "_controls_1j0ct_188", controlButton: "_controlButton_1j0ct_193", pauseButton: "_pauseButton_1j0ct_212", paused: "_paused_1j0ct_214", stopButton: "_stopButton_1j0ct_224", historySectionWrapper: "_historySectionWrapper_1j0ct_258", shimmer: "_shimmer_1j0ct_1", celebrate: "_celebrate_1j0ct_1", expanded: "_expanded_1j0ct_290", historySection: "_historySection_1j0ct_258", historyItem: "_historyItem_1j0ct_309", doneSuccess: "_doneSuccess_1j0ct_368", historyContent: "_historyContent_1j0ct_404", statusIcon: "_statusIcon_1j0ct_405", doneError: "_doneError_1j0ct_414", historyMeta: "_historyMeta_1j0ct_465", inputSectionWrapper: "_inputSectionWrapper_1j0ct_535", hidden: "_hidden_1j0ct_558", inputSection: "_inputSection_1j0ct_535", taskInput: "_taskInput_1j0ct_569" }, xo = class xo { constructor(n) { G(this, x); G(this, $e); G(this, Dt); G(this, we); G(this, vt); G(this, _t); G(this, Oe); G(this, dn); G(this, bt); G(this, He); G(this, Fe); G(this, yt, new ao); G(this, rt, !1); G(this, J); G(this, it, null); G(this, Ke, !1); G(this, $t, null); G(this, qe, null); G(this, Lt, !1); R(this, J, n), R(this, Fe, n.bus), R(this, $e, U(this, x, cd).call(this)), R(this, Dt, g(this, $e).querySelector(`.${O.indicator}`)), R(this, we, g(this, $e).querySelector(`.${O.statusText}`)), R(this, vt, g(this, $e).querySelector(`.${O.historySection}`)), R(this, _t, g(this, $e).querySelector(`.${O.expandButton}`)), R(this, Oe, g(this, $e).querySelector(`.${O.pauseButton}`)), R(this, dn, g(this, $e).querySelector(`.${O.stopButton}`)), R(this, bt, g(this, $e).querySelector(`.${O.inputSectionWrapper}`)), R(this, He, g(this, $e).querySelector(`.${O.taskInput}`)), U(this, x, ud).call(this), U(this, x, ld).call(this), U(this, x, _n).call(this), g(this, Fe).on("panel:show", () => U(this, x, ed).call(this)), g(this, Fe).on("panel:hide", () => U(this, x, td).call(this)), g(this, Fe).on("panel:reset", () => U(this, x, nd).call(this)), g(this, Fe).on("panel:update", r => U(this, x, vn).call(this, r)), g(this, Fe).on("panel:expand", () => U(this, x, bn).call(this)), g(this, Fe).on("panel:collapse", () => U(this, x, er).call(this)) } get wrapper() { return g(this, $e) } async askUser(n) { return new Promise(r => { R(this, Ke, !0), R(this, it, r), U(this, x, vn).call(this, { type: "output", displayText: g(this, J).i18n.t("ui.panel.question", { question: n }) }), g(this, rt) || U(this, x, bn).call(this), U(this, x, _n).call(this, g(this, J).i18n.t("ui.panel.userAnswerPrompt")) }) } dispose() { R(this, Ke, !1), U(this, x, dd).call(this), this.wrapper.remove() } }; $e = new WeakMap, Dt = new WeakMap, we = new WeakMap, vt = new WeakMap, _t = new WeakMap, Oe = new WeakMap, dn = new WeakMap, bt = new WeakMap, He = new WeakMap, Fe = new WeakMap, yt = new WeakMap, rt = new WeakMap, J = new WeakMap, it = new WeakMap, Ke = new WeakMap, $t = new WeakMap, qe = new WeakMap, Lt = new WeakMap, x = new WeakSet, vn = a(function (n) { const r = g(this, yt).addStep(n), i = hg(r.displayText, 20); R(this, qe, i), U(this, x, yn).call(this, r.type), U(this, x, To).call(this), (r.type === "completed" || r.type === "error") && (g(this, rt) || U(this, x, bn).call(this)), U(this, x, sd).call(this) ? U(this, x, _n).call(this) : U(this, x, Oo).call(this) }, "#update"), ed = a(function () { this.wrapper.style.display = "block", this.wrapper.offsetHeight, this.wrapper.style.opacity = "1", this.wrapper.style.transform = "translateX(-50%) translateY(0)" }, "#show"), td = a(function () { this.wrapper.style.opacity = "0", this.wrapper.style.transform = "translateX(-50%) translateY(20px)", this.wrapper.style.display = "none" }, "#hide"), nd = a(function () { g(this, yt).reset(), g(this, we).textContent = g(this, J).i18n.t("ui.panel.ready"), U(this, x, yn).call(this, "thinking"), U(this, x, To).call(this), U(this, x, er).call(this), g(this, J).paused = !1, U(this, x, Eo).call(this), R(this, Ke, !1), R(this, it, null), U(this, x, _n).call(this) }, "#reset"), rd = a(function () { g(this, J).paused = !g(this, J).paused, U(this, x, Eo).call(this), g(this, J).paused ? (g(this, we).textContent = g(this, J).i18n.t("ui.panel.paused"), U(this, x, yn).call(this, "thinking")) : (g(this, we).textContent = g(this, J).i18n.t("ui.panel.continueExecution"), U(this, x, yn).call(this, "tool_executing")) }, "#togglePause"), Eo = a(function () { g(this, J).paused ? (g(this, Oe).textContent = "❚❚", g(this, Oe).title = g(this, J).i18n.t("ui.panel.continue"), g(this, Oe).classList.add(O.paused)) : (g(this, Oe).textContent = "▶", g(this, Oe).title = g(this, J).i18n.t("ui.panel.pause"), g(this, Oe).classList.remove(O.paused)) }, "#updatePauseButton"), id = a(function () { U(this, x, vn).call(this, { type: "error", displayText: g(this, J).i18n.t("ui.panel.taskTerminated") }), g(this, J).dispose() }, "#stopAgent"), od = a(function () { const n = g(this, He).value.trim(); n && (U(this, x, Oo).call(this), g(this, Ke) ? U(this, x, ad).call(this, n) : g(this, J).execute(n)) }, "#submitTask"), ad = a(function (n) { U(this, x, vn).call(this, { type: "input", displayText: g(this, J).i18n.t("ui.panel.userAnswer", { input: n }) }), R(this, Ke, !1), g(this, it) && (g(this, it).call(this, n), R(this, it, null)) }, "#handleUserAnswer"), _n = a(function (n) { g(this, He).value = "", g(this, He).placeholder = n || g(this, J).i18n.t("ui.panel.taskInput"), g(this, bt).classList.remove(O.hidden), setTimeout(() => { g(this, He).focus() }, 100) }, "#showInputArea"), Oo = a(function () { g(this, bt).classList.add(O.hidden) }, "#hideInputArea"), sd = a(function () { if (g(this, Ke)) return !0; const n = g(this, yt).getAllSteps(); if (n.length === 0) return !0; const r = n[n.length - 1]; return r.type === "completed" || r.type === "error" }, "#shouldShowInputArea"), cd = a(function () {
    const n = document.createElement("div"); return n.id = "page-agent-runtime_agent-panel", n.className = `${O.wrapper} ${O.collapsed}`, n.setAttribute("data-browser-use-ignore", "true"), n.innerHTML = `
			<div class="${O.background}"></div>
			<div class="${O.historySectionWrapper}">
				<div class="${O.historySection}">
					${U(this, x, Uo).call(this, { id: "placeholder", stepNumber: 0, timestamp: new Date, type: "thinking", displayText: g(this, J).i18n.t("ui.panel.waitingPlaceholder") })}
				</div>
			</div>
			<div class="${O.header}">
				<div class="${O.statusSection}">
					<div class="${O.indicator} ${O.thinking}"></div>
					<div class="${O.statusText}">${g(this, J).i18n.t("ui.panel.ready")}</div>
				</div>
				<div class="${O.controls}">
					<button class="${O.controlButton} ${O.expandButton}" title="${g(this, J).i18n.t("ui.panel.expand")}">
						▼
					</button>
					<button class="${O.controlButton} ${O.pauseButton}" title="${g(this, J).i18n.t("ui.panel.pause")}">
						▶
					</button>
					<button class="${O.controlButton} ${O.stopButton}" title="${g(this, J).i18n.t("ui.panel.stop")}">
						X
					</button>
				</div>
			</div>
			<div class="${O.inputSectionWrapper} ${O.hidden}">
				<div class="${O.inputSection}">
					<input 
						type="text" 
						class="${O.taskInput}" 
						maxlength="200"
					/>
				</div>
			</div>
		`, document.body.appendChild(n), n
  }, "#createWrapper"), ud = a(function () { this.wrapper.querySelector(`.${O.header}`).addEventListener("click", r => { r.target.closest(`.${O.controlButton}`) || U(this, x, No).call(this) }), g(this, _t).addEventListener("click", r => { r.stopPropagation(), U(this, x, No).call(this) }), g(this, Oe).addEventListener("click", r => { r.stopPropagation(), U(this, x, rd).call(this) }), g(this, dn).addEventListener("click", r => { r.stopPropagation(), U(this, x, id).call(this) }), g(this, He).addEventListener("keydown", r => { r.isComposing || r.key === "Enter" && (r.preventDefault(), U(this, x, od).call(this)) }), g(this, bt).addEventListener("click", r => { r.stopPropagation() }) }, "#setupEventListeners"), No = a(function () { g(this, rt) ? U(this, x, er).call(this) : U(this, x, bn).call(this) }, "#toggle"), bn = a(function () { R(this, rt, !0), this.wrapper.classList.remove(O.collapsed), this.wrapper.classList.add(O.expanded), g(this, _t).textContent = "▼" }, "#expand"), er = a(function () { R(this, rt, !1), this.wrapper.classList.remove(O.expanded), this.wrapper.classList.add(O.collapsed), g(this, _t).textContent = "▼" }, "#collapse"), ld = a(function () { R(this, $t, setInterval(() => { U(this, x, fd).call(this) }, 450)) }, "#startHeaderUpdateLoop"), dd = a(function () { g(this, $t) && (clearInterval(g(this, $t)), R(this, $t, null)) }, "#stopHeaderUpdateLoop"), fd = a(function () { if (!g(this, qe) || g(this, Lt)) return; if (g(this, we).textContent === g(this, qe)) { R(this, qe, null); return } const n = g(this, qe); R(this, qe, null), U(this, x, md).call(this, n) }, "#checkAndUpdateHeader"), md = a(function (n) { R(this, Lt, !0), g(this, we).classList.add(O.fadeOut), setTimeout(() => { g(this, we).textContent = n, g(this, we).classList.remove(O.fadeOut), g(this, we).classList.add(O.fadeIn), setTimeout(() => { g(this, we).classList.remove(O.fadeIn), R(this, Lt, !1) }, 300) }, 150) }, "#animateTextChange"), yn = a(function (n) { g(this, Dt).className = O.indicator, g(this, Dt).classList.add(O[n]) }, "#updateStatusIndicator"), To = a(function () { const n = g(this, yt).getAllSteps(); g(this, vt).innerHTML = n.map(r => U(this, x, Uo).call(this, r)).join(""), U(this, x, pd).call(this) }, "#updateHistory"), pd = a(function () { setTimeout(() => { g(this, vt).scrollTop = g(this, vt).scrollHeight }, 0) }, "#scrollToBottom"), Uo = a(function (n) {
    const r = n.timestamp.toLocaleTimeString("zh-CN", { hour12: !1, hour: "2-digit", minute: "2-digit", second: "2-digit" }); let i = "", t = ""; if (n.type === "completed") if (n.toolName === "done") { const c = g(this, J).i18n.t("ui.tools.resultFailure"), u = g(this, J).i18n.t("ui.tools.resultError"), p = !n.toolResult || !n.toolResult.includes(c) && !n.toolResult.includes(u); i = p ? O.doneSuccess : O.doneError, t = p ? "ðŸŽ‰" : "âŒ" } else i = O.completed, t = "Bot…"; else n.type === "error" ? (i = O.error, t = "âŒ") : n.type === "tool_executing" ? t = "❌" : n.type === "output" ? (i = O.output, t = "Suggest–") : n.type === "input" ? (i = O.input, t = "Query") : n.type === "retry" ? (i = O.retry, t = "ðŸ”„") : t = "🧠"; const o = n.duration ? ` Â· ${n.duration}ms` : "", s = g(this, J).i18n.t("ui.panel.step", { number: n.stepNumber.toString(), time: r, duration: o || "" }); return `
			<div class="${O.historyItem} ${i}">
				<div class="${O.historyContent}">
					<span class="${O.statusIcon}">${t}</span>
					<span>${n.displayText}</span>
				</div>
				<div class="${O.historyMeta}">
					${s}
				</div>
			</div>
		`}, "#createHistoryItem"), a(xo, "Panel"); let so = xo; function vg(e, n, r) { switch (e) { case "click_element_by_index": return r.t("ui.tools.clicking", { index: n.index }); case "input_text": return r.t("ui.tools.inputting", { index: n.index }); case "select_dropdown_option": return r.t("ui.tools.selecting", { text: n.text }); case "scroll": return r.t("ui.tools.scrolling"); case "wait": return r.t("ui.tools.waiting", { seconds: n.seconds }); case "done": return r.t("ui.tools.done"); default: return r.t("ui.tools.executing", { toolName: e }) } } a(vg, "getToolExecutingText"); function _g(e, n, r) { switch (e) { case "click_element_by_index": return r.t("ui.tools.clicked", { index: n.index }); case "input_text": return r.t("ui.tools.inputted", { text: n.text }); case "select_dropdown_option": return r.t("ui.tools.selected", { text: n.text }); case "scroll": return r.t("ui.tools.scrolled"); case "wait": return r.t("ui.tools.waited"); case "done": return null; default: return null } } a(_g, "getToolCompletedText");/**
 * AI Motion - WebGL2 animated border with AI-style glow effects
 *
 * @author Simon<gaomeng1900@gmail.com>
 * @license MIT
 * @repository https://github.com/gaomeng1900/ai-motion
 */function Kl(e, n, r, i) { const t = Math.max(1, Math.min(e, n)), o = Math.min(r, 20), c = Math.min(o + i, t), u = Math.min(c, Math.floor(e / 2)), p = Math.min(c, Math.floor(n / 2)), m = a(S => S / e * 2 - 1, "toClipX"), f = a(S => S / n * 2 - 1, "toClipY"), b = 0, v = e, h = 0, y = n, w = u, j = e - u, A = p, z = n - p, I = m(b), M = m(v), Ye = f(h), re = f(y), me = m(w), Ae = m(j), pe = f(A), Pe = f(z), De = 0, mn = 0, Le = 1, pn = 1, hn = u / e, Be = 1 - u / e, Re = p / n, l = 1 - p / n, k = new Float32Array([I, Ye, M, Ye, I, pe, I, pe, M, Ye, M, pe, I, Pe, M, Pe, I, re, I, re, M, Pe, M, re, I, pe, me, pe, I, Pe, I, Pe, me, pe, me, Pe, Ae, pe, M, pe, Ae, Pe, Ae, Pe, M, pe, M, Pe]), Z = new Float32Array([De, mn, Le, mn, De, Re, De, Re, Le, mn, Le, Re, De, l, Le, l, De, pn, De, pn, Le, l, Le, pn, De, Re, hn, Re, De, l, De, l, hn, Re, hn, l, Be, Re, Le, Re, Be, l, Be, l, Le, Re, Le, l]); return { positions: k, uvs: Z } } a(Kl, "computeBorderGeometry");/**
 * AI Motion - WebGL2 animated border with AI-style glow effects
 *
 * @author Simon<gaomeng1900@gmail.com>
 * @license MIT
 * @repository https://github.com/gaomeng1900/ai-motion
 */function ql(e, n, r) { const i = e.createShader(n); if (!i) throw new Error("Failed to create shader"); if (e.shaderSource(i, r), e.compileShader(i), !e.getShaderParameter(i, e.COMPILE_STATUS)) { const t = e.getShaderInfoLog(i) || "Unknown shader error"; throw e.deleteShader(i), new Error(t) } return i } a(ql, "compileShader"); function bg(e, n, r) { const i = ql(e, e.VERTEX_SHADER, n), t = ql(e, e.FRAGMENT_SHADER, r), o = e.createProgram(); if (!o) throw new Error("Failed to create program"); if (e.attachShader(o, i), e.attachShader(o, t), e.linkProgram(o), !e.getProgramParameter(o, e.LINK_STATUS)) { const s = e.getProgramInfoLog(o) || "Unknown link error"; throw e.deleteProgram(o), e.deleteShader(i), e.deleteShader(t), new Error(s) } return e.deleteShader(i), e.deleteShader(t), o } a(bg, "createProgram"); const yg = `#version 300 es
precision lowp float;
in vec2 vUV;
out vec4 outColor;
uniform vec2 uResolution;
uniform float uTime;
uniform float uBorderWidth;
uniform float uGlowWidth;
uniform float uBorderRadius;
uniform vec3 uColors[4];
uniform float uGlowExponent;
uniform float uGlowFactor;
const float PI = 3.14159265359;
const float TWO_PI = 2.0 * PI;
const float HALF_PI = 0.5 * PI;
const vec4 startPositions = vec4(0.0, PI, HALF_PI, 1.5 * PI);
const vec4 speeds = vec4(-1.9, -1.9, -1.5, 2.1);
const vec4 innerRadius = vec4(PI * 0.8, PI * 0.7, PI * 0.3, PI * 0.1);
const vec4 outerRadius = vec4(PI * 1.2, PI * 0.9, PI * 0.6, PI * 0.4);
float random(vec2 st) {
return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}
vec2 random2(vec2 st) {
return vec2(random(st), random(st + 1.0));
}
float aaStep(float edge, float d) {
float width = fwidth(d);
return smoothstep(edge - width * 0.5, edge + width * 0.5, d);
}
float aaFract(float x) {
float f = fract(x);
float w = fwidth(x);
float smooth_f = f * (1.0 - smoothstep(1.0 - w, 1.0, f));
return smooth_f;
}
float sdRoundedBox(in vec2 p, in vec2 b, in float r) {
vec2 q = abs(p) - b + r;
return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;
}
float getInnerGlow(vec2 p, vec2 b, float radius) {
float dist_x = b.x - abs(p.x);
float dist_y = b.y - abs(p.y);
float glow_x = smoothstep(radius, 0.0, dist_x);
float glow_y = smoothstep(radius, 0.0, dist_y);
return 1.0 - (1.0 - glow_x) * (1.0 - glow_y);
}
float getVignette(vec2 uv) {
vec2 vignetteUv = uv;
vignetteUv = vignetteUv * (1.0 - vignetteUv);
float vignette = vignetteUv.x * vignetteUv.y * 25.0;
vignette = pow(vignette, 0.16);
vignette = 1.0 - vignette;
return vignette;
}
float uvToAngle(vec2 uv) {
vec2 center = vec2(0.5);
vec2 dir = uv - center;
return atan(dir.y, dir.x) + PI;
}
void main() {
vec2 uv = vUV;
vec2 pos = uv * uResolution;
vec2 centeredPos = pos - uResolution * 0.5;
vec2 size = uResolution - uBorderWidth;
vec2 halfSize = size * 0.5;
float dBorderBox = sdRoundedBox(centeredPos, halfSize, uBorderRadius);
float border = aaStep(0.0, dBorderBox);
float glow = getInnerGlow(centeredPos, halfSize, uGlowWidth);
float vignette = getVignette(uv);
glow *= vignette;
float posAngle = uvToAngle(uv);
vec4 lightCenter = mod(startPositions + speeds * uTime, TWO_PI);
vec4 angleDist = abs(posAngle - lightCenter);
vec4 disToLight = min(angleDist, TWO_PI - angleDist) / TWO_PI;
float intensityBorder[4];
intensityBorder[0] = 1.0;
intensityBorder[1] = smoothstep(0.4, 0.0, disToLight.y);
intensityBorder[2] = smoothstep(0.4, 0.0, disToLight.z);
intensityBorder[3] = smoothstep(0.2, 0.0, disToLight.w) * 0.5;
vec3 borderColor = vec3(0.0);
for(int i = 0; i < 4; i++) {
borderColor = mix(borderColor, uColors[i], intensityBorder[i]);
}
borderColor *= 1.1;
borderColor = clamp(borderColor, 0.0, 1.0);
float intensityGlow[4];
intensityGlow[0] = smoothstep(0.9, 0.0, disToLight.x);
intensityGlow[1] = smoothstep(0.7, 0.0, disToLight.y);
intensityGlow[2] = smoothstep(0.4, 0.0, disToLight.z);
intensityGlow[3] = smoothstep(0.1, 0.0, disToLight.w) * 0.7;
vec4 breath = smoothstep(0.0, 1.0, sin(uTime * 1.0 + startPositions * PI) * 0.2 + 0.8);
vec3 glowColor = vec3(0.0);
glowColor += uColors[0] * intensityGlow[0] * breath.x;
glowColor += uColors[1] * intensityGlow[1] * breath.y;
glowColor += uColors[2] * intensityGlow[2] * breath.z;
glowColor += uColors[3] * intensityGlow[3] * breath.w * glow;
glow = pow(glow, uGlowExponent);
glow *= random(pos + uTime) * 0.1 + 1.0;
glowColor *= glow * uGlowFactor;
glowColor = clamp(glowColor, 0.0, 1.0);
vec3 color = mix(glowColor, borderColor + glowColor * 0.2, border);
float alpha = mix(glow, 1.0, border);
outColor = vec4(color, alpha);
}`, $g = `#version 300 es
in vec2 aPosition;
in vec2 aUV;
out vec2 vUV;
void main() {
vUV = aUV;
gl_Position = vec4(aPosition, 0.0, 1.0);
}`;/**
 * AI Motion - WebGL2 animated border with AI-style glow effects
 *
 * @author Simon<gaomeng1900@gmail.com>
 * @license MIT
 * @repository https://github.com/gaomeng1900/ai-motion
 */const wg = ["rgb(57, 182, 255)", "rgb(189, 69, 251)", "rgb(255, 87, 51)", "rgb(255, 214, 0)"]; function kg(e) { const n = e.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/); if (!n) throw new Error(`Invalid color format: ${e}`); const [, r, i, t] = n; return [parseInt(r) / 255, parseInt(i) / 255, parseInt(t) / 255] } a(kg, "parseColor"); const Io = class Io { element; canvas; options; running = !1; disposed = !1; startTime = 0; lastTime = 0; rafId = null; glr; observer; constructor(n = {}) { this.options = { width: n.width ?? 600, height: n.height ?? 600, ratio: n.ratio ?? window.devicePixelRatio ?? 1, borderWidth: n.borderWidth ?? 8, glowWidth: n.glowWidth ?? 200, borderRadius: n.borderRadius ?? 8, mode: n.mode ?? "light", ...n }, this.canvas = document.createElement("canvas"), this.options.classNames && (this.canvas.className = this.options.classNames), this.options.styles && Object.assign(this.canvas.style, this.options.styles), this.canvas.style.display = "block", this.canvas.style.transformOrigin = "center", this.canvas.style.pointerEvents = "none", this.element = this.canvas, this.setupGL(), this.options.skipGreeting || this.greet() } start() { if (this.disposed) throw new Error("Motion instance has been disposed."); if (this.running) return; if (!this.glr) { console.error("WebGL resources are not initialized."); return } this.running = !0, this.startTime = performance.now(), this.resize(this.options.width ?? 600, this.options.height ?? 600, this.options.ratio), this.glr.gl.viewport(0, 0, this.canvas.width, this.canvas.height), this.glr.gl.useProgram(this.glr.program), this.glr.gl.uniform2f(this.glr.uResolution, this.canvas.width, this.canvas.height), this.checkGLError(this.glr.gl, "start: after initial setup"); const n = a(() => { if (!this.running || !this.glr) return; this.rafId = requestAnimationFrame(n); const r = performance.now(); if (r - this.lastTime < 1e3 / 32) return; this.lastTime = r; const t = (r - this.startTime) * .001; this.render(t) }, "loop"); this.rafId = requestAnimationFrame(n) } pause() { if (this.disposed) throw new Error("Motion instance has been disposed."); this.running = !1, this.rafId !== null && cancelAnimationFrame(this.rafId) } dispose() { if (this.disposed) return; this.disposed = !0, this.running = !1, this.rafId !== null && cancelAnimationFrame(this.rafId); const { gl: n, vao: r, positionBuffer: i, uvBuffer: t, program: o } = this.glr; r && n.deleteVertexArray(r), i && n.deleteBuffer(i), t && n.deleteBuffer(t), n.deleteProgram(o), this.observer && this.observer.disconnect(), this.canvas.remove() } resize(n, r, i) { if (this.disposed) throw new Error("Motion instance has been disposed."); if (this.options.width = n, this.options.height = r, i && (this.options.ratio = i), !this.running) return; const { gl: t, program: o, vao: s, positionBuffer: c, uvBuffer: u, uResolution: p } = this.glr, m = i ?? this.options.ratio ?? window.devicePixelRatio ?? 1, f = Math.max(1, Math.floor(n * m)), b = Math.max(1, Math.floor(r * m)); this.canvas.style.width = `${n}px`, this.canvas.style.height = `${r}px`, (this.canvas.width !== f || this.canvas.height !== b) && (this.canvas.width = f, this.canvas.height = b), t.viewport(0, 0, this.canvas.width, this.canvas.height), this.checkGLError(t, "resize: after viewport setup"); const { positions: v, uvs: h } = Kl(this.canvas.width, this.canvas.height, this.options.borderWidth * m, this.options.glowWidth * m); t.bindVertexArray(s), t.bindBuffer(t.ARRAY_BUFFER, c), t.bufferData(t.ARRAY_BUFFER, v, t.STATIC_DRAW); const y = t.getAttribLocation(o, "aPosition"); t.enableVertexAttribArray(y), t.vertexAttribPointer(y, 2, t.FLOAT, !1, 0, 0), this.checkGLError(t, "resize: after position buffer update"), t.bindBuffer(t.ARRAY_BUFFER, u), t.bufferData(t.ARRAY_BUFFER, h, t.STATIC_DRAW); const w = t.getAttribLocation(o, "aUV"); t.enableVertexAttribArray(w), t.vertexAttribPointer(w, 2, t.FLOAT, !1, 0, 0), this.checkGLError(t, "resize: after UV buffer update"), t.useProgram(o), t.uniform2f(p, this.canvas.width, this.canvas.height), t.uniform1f(this.glr.uBorderWidth, this.options.borderWidth * m), t.uniform1f(this.glr.uGlowWidth, this.options.glowWidth * m), t.uniform1f(this.glr.uBorderRadius, this.options.borderRadius * m), this.checkGLError(t, "resize: after uniform updates"); const j = performance.now(); this.lastTime = j; const A = (j - this.startTime) * .001; this.render(A) } autoResize(n) { this.observer && this.observer.disconnect(), this.observer = new ResizeObserver(() => { const r = n.getBoundingClientRect(); this.resize(r.width, r.height) }), this.observer.observe(n) } fadeIn() { if (this.disposed) throw new Error("Motion instance has been disposed."); return new Promise((n, r) => { const i = this.canvas.animate([{ opacity: 0, transform: "scale(1.2)" }, { opacity: 1, transform: "scale(1)" }], { duration: 300, easing: "ease-out", fill: "forwards" }); i.onfinish = () => n(), i.oncancel = () => r("canceled") }) } fadeOut() { if (this.disposed) throw new Error("Motion instance has been disposed."); return new Promise((n, r) => { const i = this.canvas.animate([{ opacity: 1, transform: "scale(1)" }, { opacity: 0, transform: "scale(1.2)" }], { duration: 300, easing: "ease-in", fill: "forwards" }); i.onfinish = () => n(), i.oncancel = () => r("canceled") }) } checkGLError(n, r) { let i = n.getError(); if (i !== n.NO_ERROR) { for (console.group(`ðŸ”´ WebGL Error in ${r}`); i !== n.NO_ERROR;) { const t = this.getGLErrorName(n, i); console.error(`${t} (0x${i.toString(16)})`), i = n.getError() } console.groupEnd() } } getGLErrorName(n, r) { switch (r) { case n.INVALID_ENUM: return "INVALID_ENUM"; case n.INVALID_VALUE: return "INVALID_VALUE"; case n.INVALID_OPERATION: return "INVALID_OPERATION"; case n.INVALID_FRAMEBUFFER_OPERATION: return "INVALID_FRAMEBUFFER_OPERATION"; case n.OUT_OF_MEMORY: return "OUT_OF_MEMORY"; case n.CONTEXT_LOST_WEBGL: return "CONTEXT_LOST_WEBGL"; default: return "UNKNOWN_ERROR" } } setupGL() { const n = this.canvas.getContext("webgl2", { antialias: !1, alpha: !0 }); if (!n) throw new Error("WebGL2 is required but not available."); const r = bg(n, $g, yg); this.checkGLError(n, "setupGL: after createProgram"); const i = n.createVertexArray(); n.bindVertexArray(i), this.checkGLError(n, "setupGL: after VAO creation"); const t = this.canvas.width || 2, o = this.canvas.height || 2, { positions: s, uvs: c } = Kl(t, o, this.options.borderWidth, this.options.glowWidth), u = n.createBuffer(); n.bindBuffer(n.ARRAY_BUFFER, u), n.bufferData(n.ARRAY_BUFFER, s, n.STATIC_DRAW); const p = n.getAttribLocation(r, "aPosition"); n.enableVertexAttribArray(p), n.vertexAttribPointer(p, 2, n.FLOAT, !1, 0, 0), this.checkGLError(n, "setupGL: after position buffer setup"); const m = n.createBuffer(); n.bindBuffer(n.ARRAY_BUFFER, m), n.bufferData(n.ARRAY_BUFFER, c, n.STATIC_DRAW); const f = n.getAttribLocation(r, "aUV"); n.enableVertexAttribArray(f), n.vertexAttribPointer(f, 2, n.FLOAT, !1, 0, 0), this.checkGLError(n, "setupGL: after UV buffer setup"); const b = n.getUniformLocation(r, "uResolution"), v = n.getUniformLocation(r, "uTime"), h = n.getUniformLocation(r, "uBorderWidth"), y = n.getUniformLocation(r, "uGlowWidth"), w = n.getUniformLocation(r, "uBorderRadius"), j = n.getUniformLocation(r, "uColors"), A = n.getUniformLocation(r, "uGlowExponent"), z = n.getUniformLocation(r, "uGlowFactor"); n.useProgram(r), n.uniform1f(h, this.options.borderWidth), n.uniform1f(y, this.options.glowWidth), n.uniform1f(w, this.options.borderRadius), this.options.mode === "dark" ? (n.uniform1f(A, 2), n.uniform1f(z, 1.8)) : (n.uniform1f(A, 1), n.uniform1f(z, 1)); const I = wg.map(kg); for (let M = 0; M < I.length; M++)n.uniform3f(n.getUniformLocation(r, `uColors[${M}]`), ...I[M]); this.checkGLError(n, "setupGL: after uniform setup"), n.bindVertexArray(null), n.bindBuffer(n.ARRAY_BUFFER, null), this.glr = { gl: n, program: r, vao: i, positionBuffer: u, uvBuffer: m, uResolution: b, uTime: v, uBorderWidth: h, uGlowWidth: y, uBorderRadius: w, uColors: j } } render(n) { if (!this.glr) return; const { gl: r, program: i, vao: t, uTime: o } = this.glr; r.useProgram(i), r.bindVertexArray(t), r.uniform1f(o, n), r.disable(r.DEPTH_TEST), r.disable(r.CULL_FACE), r.disable(r.BLEND), r.clearColor(0, 0, 0, 0), r.clear(r.COLOR_BUFFER_BIT), r.drawArrays(r.TRIANGLES, 0, 24), this.checkGLError(r, "render: after draw call"), r.bindVertexArray(null) } greet() { console.log("%cðŸŒˆ ai-motion 0.4.7 ðŸŒˆ", "background: linear-gradient(90deg, #39b6ff, #bd45fb, #ff5733, #ffd600); color: white; text-shadow: 0 0 2px rgba(0, 0, 0, 0.2); font-weight: bold; font-size: 1em; padding: 2px 12px; border-radius: 6px;") } }; a(Io, "Motion"); let co = Io; function xg() { const e = ["dark", "dark-mode", "theme-dark", "night", "night-mode"], n = document.documentElement, r = document.body; for (const t of e) if (n.classList.contains(t) || r.classList.contains(t)) return !0; return !!n.getAttribute("data-theme")?.toLowerCase().includes("dark") } a(xg, "hasDarkModeClass"); function Ig(e) { const n = /rgba?\((\d+),\s*(\d+),\s*(\d+)/.exec(e); return n ? { r: parseInt(n[1]), g: parseInt(n[2]), b: parseInt(n[3]) } : null } a(Ig, "parseRgbColor"); function Yl(e, n = 128) { if (!e || e === "transparent" || e.startsWith("rgba(0, 0, 0, 0)")) return !1; const r = Ig(e); return r ? .299 * r.r + .587 * r.g + .114 * r.b < n : !1 } a(Yl, "isColorDark"); function Sg() { const e = window.getComputedStyle(document.documentElement), n = window.getComputedStyle(document.body), r = e.backgroundColor, i = n.backgroundColor; return Yl(i) ? !0 : i === "transparent" || i.startsWith("rgba(0, 0, 0, 0)") ? Yl(r) : !1 } a(Sg, "isBackgroundDark"); function jg() { return !!(xg() || Sg()) } a(jg, "isPageDark"); const zg = { wrapper: "_wrapper_1oy2s_1" }, gt = { cursor: "_cursor_1vrf3_2", cursorBorder: "_cursorBorder_1vrf3_13", cursorFilling: "_cursorFilling_1vrf3_23", cursorRipple: "_cursorRipple_1vrf3_31", clicking: "_clicking_1vrf3_37" }, So = class So { constructor() { G(this, wt); te(this, "wrapper", document.createElement("div")); te(this, "motion", new co({ mode: jg() ? "dark" : "light", styles: { position: "absolute", inset: "0" } })); G(this, le, document.createElement("div")); G(this, Ne, 0); G(this, Te, 0); G(this, ot, 0); G(this, at, 0); this.wrapper.id = "page-agent-runtime_simulator-mask", this.wrapper.className = zg.wrapper, this.wrapper.setAttribute("data-browser-use-ignore", "true"), this.wrapper.appendChild(this.motion.element), this.motion.autoResize(this.wrapper), this.wrapper.addEventListener("click", n => { n.stopPropagation(), n.preventDefault() }), this.wrapper.addEventListener("mousedown", n => { n.stopPropagation(), n.preventDefault() }), this.wrapper.addEventListener("mouseup", n => { n.stopPropagation(), n.preventDefault() }), this.wrapper.addEventListener("mousemove", n => { n.stopPropagation(), n.preventDefault() }), this.wrapper.addEventListener("wheel", n => { n.stopPropagation(), n.preventDefault() }), this.wrapper.addEventListener("keydown", n => { n.stopPropagation(), n.preventDefault() }), this.wrapper.addEventListener("keyup", n => { n.stopPropagation(), n.preventDefault() }), U(this, wt, hd).call(this), document.body.appendChild(this.wrapper), U(this, wt, Ao).call(this), window.addEventListener("PageAgent::MovePointerTo", n => { const { x: r, y: i } = n.detail; this.setCursorPosition(r, i) }), window.addEventListener("PageAgent::ClickPointer", n => { this.triggerClickAnimation() }) } setCursorPosition(n, r) { R(this, ot, n), R(this, at, r) } triggerClickAnimation() { g(this, le).classList.remove(gt.clicking), g(this, le).offsetHeight, g(this, le).classList.add(gt.clicking) } show() { this.motion.start(), this.motion.fadeIn(), this.wrapper.style.display = "block", R(this, Ne, window.innerWidth / 2), R(this, Te, window.innerHeight / 2), R(this, ot, g(this, Ne)), R(this, at, g(this, Te)), g(this, le).style.left = `${g(this, Ne)}px`, g(this, le).style.top = `${g(this, Te)}px` } hide() { this.motion.fadeOut(), this.motion.pause(), g(this, le).classList.remove(gt.clicking), setTimeout(() => { this.wrapper.style.display = "none" }, 800) } dispose() { this.motion.dispose(), this.wrapper.remove() } }; le = new WeakMap, Ne = new WeakMap, Te = new WeakMap, ot = new WeakMap, at = new WeakMap, wt = new WeakSet, hd = a(function () { g(this, le).className = gt.cursor; const n = document.createElement("div"); n.className = gt.cursorRipple, g(this, le).appendChild(n); const r = document.createElement("div"); r.className = gt.cursorFilling, g(this, le).appendChild(r); const i = document.createElement("div"); i.className = gt.cursorBorder, g(this, le).appendChild(i), this.wrapper.appendChild(g(this, le)) }, "#createCursor"), Ao = a(function () { const n = g(this, Ne) + (g(this, ot) - g(this, Ne)) * .2, r = g(this, Te) + (g(this, at) - g(this, Te)) * .2, i = Math.abs(n - g(this, ot)); i > 0 && (i < 2 ? R(this, Ne, g(this, ot)) : R(this, Ne, n), g(this, le).style.left = `${g(this, Ne)}px`); const t = Math.abs(r - g(this, at)); t > 0 && (t < 2 ? R(this, Te, g(this, at)) : R(this, Te, r), g(this, le).style.top = `${g(this, Te)}px`), requestAnimationFrame(() => U(this, wt, Ao).call(this)) }, "#moveCursorToTarget"), a(So, "SimulatorMask"); let uo = So; function Eg(e, n, r) { if (!e) { const i = n ?? "Assertion failed"; throw console.error(ge.red(`âŒ assert: ${i}`)), new Error(i) } } a(Eg, "assert"); const jo = class jo extends EventTarget { constructor(r = {}) { super(); G(this, de); te(this, "config"); te(this, "id", Hl()); te(this, "bus", Rl(this.id)); te(this, "i18n"); te(this, "panel"); te(this, "tools"); te(this, "paused", !1); te(this, "disposed", !1); te(this, "task", ""); te(this, "taskId", ""); G(this, fn); G(this, kt, 0); G(this, Ue, new AbortController); te(this, "flatTree", null); te(this, "selectorMap", new Map); te(this, "elementTextMap", new Map); te(this, "simplifiedHTML", "<EMPTY>"); te(this, "lastTimeUpdate", 0); te(this, "mask", new uo); te(this, "history", []); if (this.config = r, R(this, fn, new no(this.config, this.id)), this.i18n = new Xi(this.config.language), this.panel = new so(this), this.tools = new Map(Je), this.config.customTools) for (const [i, t] of Object.entries(this.config.customTools)) { if (t === null) { this.tools.delete(i); continue } this.tools.set(i, t) } ug(), window.addEventListener("beforeunload", i => { this.disposed || this.dispose("PAGE_UNLOADING") }) } async execute(r) { if (!r) throw new Error("Task is required"); this.task = r, this.taskId = Hl(); const i = this.config.onBeforeStep || (() => { }), t = this.config.onAfterStep || (() => { }), o = this.config.onBeforeTask || (() => { }), s = this.config.onAfterTask || (() => { }); await o.call(this), this.mask.show(), this.bus.emit("panel:show"), this.bus.emit("panel:reset"), this.bus.emit("panel:update", { type: "input", displayText: this.task }), g(this, Ue) && (g(this, Ue).abort(), R(this, Ue, new AbortController)), this.history = []; try { let c = 0; for (; ;) { if (await i.call(this, c), console.group(`step: ${c + 1}`), g(this, Ue).signal.aborted) throw new Error("AbortError"); await Vl(() => !this.paused), console.log(ge.blue("Thinking...")), this.bus.emit("panel:update", { type: "thinking", displayText: this.i18n.t("ui.panel.thinking") }); const u = await g(this, fn).invoke([{ role: "system", content: U(this, de, vd).call(this) }, { role: "user", content: U(this, de, _d).call(this) }], { AgentOutput: U(this, de, gd).call(this) }, g(this, Ue).signal), p = u.toolResult, m = p.input, f = p.output, b = { evaluation_previous_goal: m.evaluation_previous_goal || "", memory: m.memory || "", next_goal: m.next_goal || "" }, v = Object.keys(m.action)[0], h = { name: v, input: m.action[v], output: f }; if (this.history.push({ brain: b, action: h, usage: u.usage }), console.log(ge.green("Step finished:"), v), console.groupEnd(), await t.call(this, c, this.history), c++, c > Pl) { U(this, de, tr).call(this, "Step count exceeded maximum limit", !1); const y = { success: !1, data: "Step count exceeded maximum limit", history: this.history }; return await s.call(this, y), y } if (v === "done") { const y = h.input?.success ?? !1, w = h.input?.text || "no text provided"; console.log(ge.green.bold("Task completed"), y, w), U(this, de, tr).call(this, w, y); const j = { success: y, data: w, history: this.history }; return await s.call(this, j), j } } } catch (c) { console.error("Task failed", c), U(this, de, tr).call(this, String(c), !1); const u = { success: !1, data: String(c), history: this.history }; return await s.call(this, u), u } } dispose(r) { console.log("Disposing PageAgent..."), this.disposed = !0, tt(), this.flatTree = null, this.selectorMap.clear(), this.elementTextMap.clear(), this.panel.dispose(), this.mask.dispose(), this.history = [], g(this, Ue).abort(r ?? "PageAgent disposed"), this.config.onDispose?.call(this, r) } }; fn = new WeakMap, kt = new WeakMap, Ue = new WeakMap, de = new WeakSet, gd = a(function () {
      const r = this.tools, i = Array.from(r.entries()).map(([s, c]) => V.object({ [s]: c.inputSchema })), t = V.union(i); return {
        inputSchema: V.object({ evaluation_previous_goal: V.string().optional(), memory: V.string().optional(), next_goal: V.string().optional(), action: t }), execute: a(async s => {
          if (g(this, Ue).signal.aborted) throw new Error("AbortError"); await Vl(() => !this.paused), console.log(ge.blue.bold("MacroTool execute"), s); const c = s.action, u = Object.keys(c)[0], p = c[u], m = oo(`Bot…: ${s.evaluation_previous_goal}
						Website: ${s.memory}
						Query: ${s.next_goal}
					`); console.log(m), this.bus.emit("panel:update", { type: "thinking", displayText: m }); const f = r.get(u); Eg(f, `Tool ${u} not found. (@note should have been caught before this!!!)`), console.log(ge.blue.bold(`Executing tool: ${u}`), p), this.bus.emit("panel:update", { type: "tool_executing", toolName: u, toolArgs: p, displayText: vg(u, p, this.i18n) }); const b = Date.now(); let v = await f.execute.bind(this)(p); const h = Date.now() - b; console.log(ge.green.bold(`Tool (${u}) executed for ${h}ms`), v), u === "wait" ? (R(this, kt, g(this, kt) + Math.round(p.seconds + h / 1e3)), v += `
<sys> You have waited ${g(this, kt)} seconds accumulatively.`, g(this, kt) >= 3 && (v += `
Do NOT wait any longer unless you have a good reason.
`), v += "</sys>") : R(this, kt, 0); const y = _g(u, p, this.i18n); return y && this.bus.emit("panel:update", { type: "tool_executing", toolName: u, toolArgs: p, toolResult: v, displayText: y, duration: h }), await new Promise(w => setTimeout(w, 100)), { input: s, output: v }
        }, "execute")
      }
    }, "#packMacroTool"), vd = a(function () { let r = lg; const i = this.config.language === "zh-CN" ? "ä¸­æ–‡" : "English"; return r = r.replace(/Default working language: \*\*.*?\*\*/, `Default working language: **${i}**`), r }, "#getSystemPrompt"), _d = a(function () {
      let r = ""; return r += `<agent_history>
`, this.history.forEach((i, t) => {
        r += `<step_${t + 1}>
				Evaluation of Previous Step: ${i.brain.evaluation_previous_goal}
				Memory: ${i.brain.memory}
				Next Goal: ${i.brain.next_goal}
				Action Results: ${i.action.output}
				</step_${t + 1}>
			`}), r += `</agent_history>

`, r += `<agent_state>
			<user_request>
			${this.task}
			</user_request>
			<step_info>
			Step ${this.history.length + 1} of ${Pl} max possible steps
			Current date and time: ${new Date().toISOString()}
			</step_info>
			</agent_state>
		`, r += U(this, de, bd).call(this), oo(r)
    }, "#assembleUserPrompt"), tr = a(function (r, i = !0) { tt(), this.bus.emit("panel:update", { type: i ? "output" : "error", displayText: r }), this.bus.emit("panel:update", { type: "completed", displayText: this.i18n.t("ui.panel.taskCompleted") }), this.mask.hide(), g(this, Ue).abort() }, "#onDone"), bd = a(function () {
      const r = window.location.href, i = document.title, t = rg(); U(this, de, yd).call(this); let o = oo(`<browser_state>
			Current Page: [${i}](${r})

			Page info: ${t.viewport_width}x${t.viewport_height}px viewport, ${t.page_width}x${t.page_height}px total page size, ${t.pages_above.toFixed(1)} pages above, ${t.pages_below.toFixed(1)} pages below, ${t.total_pages.toFixed(1)} total pages, at ${(t.current_page_position * 100).toFixed(0)}% of page

			Interactive elements from top layer of the current page (full page):

		`); return o += `[Start of page]
`, o += this.simplifiedHTML, o += `
`, o += `[End of page]
`, o += `</browser_state>
`, o
    }, "#getBrowserState"), yd = a(function () { this.dispatchEvent(new Event("beforeUpdate")), this.lastTimeUpdate = Date.now(), tt(), this.mask.wrapper.style.pointerEvents = "none", this.flatTree = Xh({ ...this.config, interactiveBlacklist: [...this.config.interactiveBlacklist || [], ...document.querySelectorAll("[data-page-agent-not-interactive]").values()] }), this.mask.wrapper.style.pointerEvents = "auto", this.simplifiedHTML = Qh(this.flatTree, this.config.include_attributes), this.selectorMap.clear(), this.selectorMap = tg(this.flatTree), this.elementTextMap.clear(), this.elementTextMap = ng(this.simplifiedHTML), this.dispatchEvent(new Event("afterUpdate")) }, "#updateTree"), a(jo, "PageAgent"); let ln = jo; window.pageAgent && window.pageAgent.dispose(), window.PageAgent = ln, console.log("ðŸš€ page-agent.js loaded!"); const Og = "PAGE-AGENT-FREE-TESTING-RANDOM", Ng = "https://hwcxiuzfylggtcktqgij.supabase.co/functions/v1/llm-testing-proxy", Tg = "PAGE-AGENT-FREE-TESTING-RANDOM", lo = document.currentScript; if (lo) { console.log("ðŸš€ page-agent.js detected current script:", lo.src); const e = new URL(lo.src), n = e.searchParams.get("model") || Og, r = e.searchParams.get("baseURL") || Ng, i = e.searchParams.get("apiKey") || Tg, t = e.searchParams.get("lang") || "zh-CN", o = { model: n, baseURL: r, apiKey: i, language: t }; window.pageAgent = new ln(o) } else console.log("ðŸš€ page-agent.js no current script detected, using default demo config"), window.pageAgent = new ln; console.log("ðŸš€ page-agent.js initialized with config:", window.pageAgent.config), window.pageAgent.bus.emit("panel:show")
}));